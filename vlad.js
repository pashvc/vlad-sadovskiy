// 1.0.145
(function(){"use strict";(function(i,a){try{if(typeof document<"u"){const e=document.createElement("style");e.id="d-id-agent-style";for(const t in a.attributes)e.setAttribute(t,a.attributes[t]);e.appendChild(document.createTextNode(i)),document.head.appendChild(e)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})('@import"https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800";.didagent__info_message_agent_unavailable_container{height:100%}.didagent__info_message_agent_unavailable_danger{width:100%;height:100%;z-index:2;margin-bottom:-4px;color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:500;font-size:12px;opacity:.85;background-color:var(--did-secondary-main);border-radius:8px;padding:0 8px;gap:8px;overflow:auto}.didagent__info_message_agent_unavailable_danger svg{color:var(--did-danger-main);display:-webkit-box;display:-ms-flexbox;display:flex;width:16px;height:16px;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.didagent__info_message_agent_unavailable_danger pre{margin:0 0 2px;white-space:pre-wrap}.didagent__info_message_agent_unavailable_message{display:-webkit-box;display:-ms-flexbox;display:flex;margin:0;-ms-flex-negative:0;flex-shrink:0;white-space:break-spaces;word-wrap:break-word;font-size:12px;-webkit-box-sizing:border-box;box-sizing:border-box;background:var(--did-secondary-main);opacity:.8;border-radius:4px;padding:4px;color:#fff;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.didagent__info_message_indication{background:var(--did-secondary-main);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:#fff;margin:0;border-radius:8px;padding-left:10px;max-width:70%}.didagent__info_message_indication pre{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;font-size:14px;white-space:pre-wrap;padding:10px 10px 10px 8px;width:90%}.didagent__info_message_indication svg{margin-left:8px}@-webkit-keyframes fadeIn{0%{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}to{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes fadeIn{0%{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}to{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes fadeOut{0%{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}}@keyframes fadeOut{0%{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}}.fade-in{-webkit-animation:fadeIn .5s forwards;animation:fadeIn .5s forwards}.fade-out{-webkit-animation:fadeOut .5s forwards;animation:fadeOut .5s forwards}.didagent__maskedicon{-webkit-mask:var(--mask-url) no-repeat center;mask:var(--mask-url) no-repeat center;background-color:var(--color);-webkit-mask-size:contain;mask-size:contain;width:var(--width, var(--size, 24px));height:var(--size, var(--height, 24px));padding:var(--padding);margin:var(--margin);-webkit-transform:rotate(var(--rotation, 0deg));-ms-transform:rotate(var(--rotation, 0deg));transform:rotate(var(--rotation, 0deg));display:block;-webkit-transition:background-color .1s ease-in-out,-webkit-transform .2s ease-in-out;transition:background-color .1s ease-in-out,-webkit-transform .2s ease-in-out;transition:transform .2s ease-in-out,background-color .1s ease-in-out;transition:transform .2s ease-in-out,background-color .1s ease-in-out,-webkit-transform .2s ease-in-out}.didagent__banner{width:100%;height:34px;z-index:2;margin-bottom:-4px;color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:400;font-size:12px;opacity:.85;background-color:var(--did-secondary-main)}.didagaent__send__button{height:100%;aspect-ratio:1;color:#fff;border:none;outline:none;cursor:pointer;padding:0;background:#2b2a28;border-radius:100vmax;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-shadow:0px 3px 3px 0px rgba(0,0,0,.07);box-shadow:0 3px 3px #00000012;-webkit-transition:background-color .1s ease-out;transition:background-color .1s ease-out}.didagaent__send__button:disabled{cursor:not-allowed}.didagent__send__button__disabled{opacity:.5}.didagaent__send__button_actions:hover{background:#2b2a28;opacity:.8}.didagaent__send__button_actions:active{opacity:.5}.didagaent__send__button__loader,.didagaent__send__button__record{background:#fff9}.didagaent__send__button__record:hover{background-color:#fff}.didagaent__send__button__record:disabled{opacity:.5}.didagaent__send__button__reload{background:var(--did-secondary-main)}.didagent__header{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 12px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-flex:1;-ms-flex:1;flex:1;background:-webkit-gradient(linear,left top,left bottom,from(rgba(9,6,4,.3)),to(rgba(9,6,4,0)));background:linear-gradient(180deg,#0906044d,#09060400);z-index:2;gap:8px;max-height:54px}.didagent__header .didagent__header-bg{border-radius:100vmax;background-color:var(--did-primary-black-00050);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border:none;outline:none}.didagent__header .didagent__header-left{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:8px;height:32px}.didagent__header .didagent__header-left>button{cursor:pointer;border:none;outline:none;aspect-ratio:1;width:32px;color:#fff;-webkit-transition:background-color .2s;transition:background-color .2s;z-index:10000;height:100%}.didagent__header .didagent__header-left>button:hover{background-color:var(--did-secondary-hover)!important}.didagent__header .didagent__header-left button.didagent__header__menu__item-active{background-color:#fff;color:var(--did-secondary-900)}.didagent__header .didagent__header-left button.didagent__header__menu__item-active:hover{background-color:#fff!important}.didagent__header .didagent__header-left .didagent__header__name{font-size:.875em;font-weight:500;margin:0;color:var(--color, white);height:100%;padding:0 8px}.didagent__header .didagent__header-left .didagent__header__name img{max-height:64px;height:100%;-o-object-fit:contain;object-fit:contain;display:block}.didagent__header .didagent__header-center{display:-webkit-box;display:-ms-flexbox;display:flex;gap:8px;height:32px;margin:0 auto}.didagent__header .didagent__header__menu__item{cursor:pointer;color:var(--did-secondary-main);height:100%;aspect-ratio:1;border:none}.didagent__header .didagent__header__menu__item:disabled{cursor:not-allowed;opacity:.5}.didagent__header .didagent__header__menu__item:active:not(:disabled){border:1px solid var(--did-primary-black-300)}.didagent__header .didagent__header__menu__item-rotate{-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.didagent__thumb__container{--flip-y: 1;--hover-color: var(--did-primary-black-00030);--color: var(--did-primary-black-00012);--cursor: pointer;cursor:var(--cursor);-webkit-transform:scaleY(var(--flip-y));-ms-transform:scaleY(var(--flip-y));transform:scaleY(var(--flip-y));width:32px;height:32px;border-radius:100%;background-color:var(--color);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;line-height:1}.didagent__thumb__container:hover{background-color:var(--hover-color)}.didagent__thumb__container:active{background-color:var(--did-primary-black-00040)}.appear-animation{opacity:1}.appear-animation span{opacity:0;-webkit-animation:character-appear .3s ease-out forwards;animation:character-appear .3s ease-out forwards}@-webkit-keyframes character-appear{0%{opacity:0}to{opacity:1}}@keyframes character-appear{0%{opacity:0}to{opacity:1}}.didagent__messages__container{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:8px;overflow:auto;min-height:50px;max-height:200px;padding-top:80px;padding-bottom:8px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-mask-image:-webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(50%,black),color-stop(97%,black),to(transparent));-webkit-mask-image:linear-gradient(to bottom,transparent,black 50%,black 97%,transparent);mask-image:-webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(50%,black),color-stop(97%,black),to(transparent));mask-image:linear-gradient(to bottom,transparent,black 50%,black 97%,transparent);z-index:2;-ms-flex-item-align:center;align-self:center}.didagent__messages__container::-webkit-scrollbar{display:none}.didagent__messages__container .didagent__message__container{position:relative;min-width:50px;max-width:75%;-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:8px}.didagent__messages__container .didagent__message__container .didagent__message{-webkit-box-sizing:border-box;box-sizing:border-box;padding:10px;font-family:inherit;margin:0;-ms-flex-negative:0;flex-shrink:0;white-space:break-spaces;word-wrap:break-word;font-size:.875em;max-width:100%}.didagent__messages__container .didagent__message__container .didagent__message__user{background:#5a5a5ae6;opacity:.8;border-radius:16px 0 16px 16px;color:#fff}.didagent__messages__container .didagent__message__container .didagent__message__assistant{background:#000000e6;opacity:.8;border-radius:0 16px 16px;color:#fff}.didagent__messages__container .didagent__message__container .didagent__message__assistant__loader{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:14px;gap:8px}.didagent__messages__container .didagent__message__container .didagent__message__url{color:#497cff}.didagent__messages__container .didagent__message__container:hover .didagent__message__rating{opacity:1}.didagent__messages__container .didagent__message__container .didagent__message__rating{opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-item-align:end;align-self:flex-end;gap:12px;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out;padding-bottom:4px}.didagent__messages__container .didagent__message__container__assistant{margin-right:auto}.didagent__messages__container .didagent__message__container__user{margin-left:auto}.didagent__starter_messages__container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:8px;width:100%;padding:0 16px 8px;max-height:180px;overflow:auto;-webkit-transition:max-height .6s ease-out,margin-bottom .6s ease-out,padding-bottom .6s ease-out,opacity .6s ease-out;transition:max-height .6s ease-out,margin-bottom .6s ease-out,padding-bottom .6s ease-out,opacity .6s ease-out;z-index:2}.didagent__starter_messages__container::-webkit-scrollbar{display:none}.didagent__starter_messages__container .didagent__starter_message__container{padding:10px 16px;border-radius:8px;width:100%;height:46px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background:var(--did-primary-black-00050);color:#fff;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-weight:400;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}.didagent__starter_messages__container .didagent__starter_message__container .didagent__starter_message__arrow{rotate:270deg;margin-left:auto}.didagent__starter_messages__container .didagent__starter_message__container:hover{background:var(--did-primary-black-00040)}.didagent__starter_messages__container .didagent__starter_message__container:active{background:var(--did-primary-black-00050)}.didagent__starter_messages__container .didagent__starter_message__container.disabled{background:#78787829;cursor:not-allowed;pointer-events:none}.didagent__starter_messages__container .didagent__starter_message__container_text{text-overflow:ellipsis;overflow:hidden;white-space:normal;padding-right:8px;-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;line-clamp:2;-webkit-line-clamp:2;-webkit-box-orient:vertical}.didagent__embedded__video__container{position:absolute;top:0;width:100%;height:100%;aspect-ratio:1/1.5;margin:0 auto}.didagent__embedded__video__container[data-blur=true]{-webkit-filter:blur(7px);filter:blur(7px)}.didagent__embedded__video__container video{-o-object-fit:cover;object-fit:cover;position:absolute;display:block;height:100%;width:100%}@media (min-width: 1280px){.didagent__embedded__video__container[data-orientation=horizontal] video{-o-object-fit:contain;object-fit:contain}}.didagent__embedded__video__container .didagent__video__skeleton{height:100%;aspect-ratio:1;margin:auto}.didagent__embedded__video__idle{opacity:1}.didagent__embedded__video__stream{opacity:0;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out}.didagent__embedded__video__stream[data-active=true]{opacity:1}:host{--did-primary-black-50: #f1f2f6;--did-primary-black-70: #c0bfbd;--did-primary-black-80: #5a5a5a;--did-primary-black-90: #1d1d1d;--did-primary-black-9060: #1d1d1d99;--did-primary-black-9080: #1d1d1dcc;--did-primary-black-100: #242625;--did-primary-black-10090: #242625ba;--did-primary-black-200: #ebebeb;--did-primary-black-300: #dbdbdb;--did-primary-black-400: #b8b8b8;--did-primary-black-500: #989898;--did-primary-black-700: #5c5c5c;--did-primary-black-00012: rgba(0, 0, 0, .125);--did-primary-black-00030: rgba(0, 0, 0, .3);--did-primary-black-00040: rgba(0, 0, 0, .4);--did-primary-black-00050: rgba(0, 0, 0, .5);--did-primary-50: #fffee9;--did-primary-100: #fffac7;--did-primary-200: #fff6a0;--did-primary-300: #fff17b;--did-primary-400: #ffec5c;--did-primary-500: #fee640;--did-primary-600: #ffdd45;--did-primary-700: #ffc941;--did-primary-800: #ffb13a;--did-primary-900: #ff882e;--did-primary-950: #ed7921;--did-primary-main: #ff882e;--did-primary-light: #fff6ef;--did-primary-bg: #ff882e1f;--did-primary-bgDark: #493021;--did-primary-hover: #ed7921;--did-primary-disabled: #94979c;--did-secondary-50: #f8f5f4;--did-secondary-60: #f3f3f3;--did-secondary-100: #eceae8;--did-secondary-200: #dedcda;--did-secondary-300: #c9c7c6;--did-secondary-400: #a4a1a0;--did-secondary-500: #82807e;--did-secondary-550: #707070;--did-secondary-600: #5b5958;--did-secondary-700: #494745;--did-secondary-800: #2b2a28;--did-secondary-900: #090604;--did-secondary-main: #090604;--did-secondary-hover: #2b2a28;--did-secondary-shades-800: rgba(43, 42, 40, 1);--did-success-main: #29cc6a;--did-danger-main: #ed254e;--did-danger-light: #fef2f2;--did-danger-dark: #cc0037}.didagent__embedded__container__loading{width:100%;height:100%;-webkit-backdrop-filter:var(--backdrop-filter);backdrop-filter:var(--backdrop-filter);background-color:var(--background-color);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;pointer-events:none;opacity:1;-webkit-transition:opacity .3s ease;transition:opacity .3s ease;position:absolute;z-index:3}.didagent__embedded__container__loading>span{color:var(--did-secondary-60);font-weight:500}.didagent__fullscreen{position:fixed!important;top:0;right:0;bottom:0;left:0;z-index:99999}.didagent__embedded__container{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;width:100%;height:100%;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:4px;overflow:hidden;min-width:250px;font-size:16px;background:#373636;isolation:isolate}.didagent__embedded__container .didagent__filler{-webkit-box-flex:1;-ms-flex:1;flex:1;width:100%;pointer-events:none}.didagent__embedded__container .didagent__close__button{display:none}.didagent__embedded__container *{-webkit-box-sizing:border-box;box-sizing:border-box}.didagent__background{width:100%;height:100%;position:absolute;top:0;left:0;background-size:cover!important;-webkit-filter:blur(15px);filter:blur(15px);scale:105%}.didagent__main__container{padding-left:12px;padding-right:12px;margin:0 auto;display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;max-width:450px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.didagent__main__input{margin-bottom:12px;width:100%;-ms-flex-item-align:center;align-self:center;margin-top:0;position:relative;height:52px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;gap:12px;background-color:var(--focus, rgba(255, 255, 255, .6));z-index:4;border-radius:8px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:8px 16px;-webkit-transition:height .3s ease,background-color .3s ease;transition:height .3s ease,background-color .3s ease}.didagent__main__input .didagent__main__input-send{height:36px}.didagent__main__input>textarea{position:relative;border:none;outline:none;resize:none;font-family:inherit;text-align:left;width:100%;height:100%;background:transparent;font-size:16px;color:var(--did-secondary-shades-800);margin-top:10px;-webkit-transition:margin-top .2s ease;transition:margin-top .2s ease;line-height:20px}.didagent__main__input>textarea::-webkit-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-moz-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea:-ms-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-ms-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-webkit-scrollbar{display:none}.didagent__fabio{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;position:fixed;aspect-ratio:1;-webkit-transition:opacity .6s ease-in-out,width .6s ease-in-out,height .6s ease-in-out;transition:opacity .6s ease-in-out,width .6s ease-in-out,height .6s ease-in-out;aspect-ratio:.6s ease-in-out;z-index:99999;isolation:isolate;bottom:2%}.didagent__fabio[data-enabled=false]{width:140px}.didagent__fabio[data-enabled=true]{width:120px}.didagent__fabio[data-position=left]{left:2%}.didagent__fabio[data-position=right]{right:2%}@media (max-height: 550px){.didagent__fabio{display:none}}.didagent__fabio *{-webkit-box-sizing:border-box;box-sizing:border-box}.didagent__fabio>button{width:100%;height:100%;border-radius:50%;padding:0;cursor:pointer;outline:0;position:relative;border:none;-webkit-box-shadow:1px 3px 4px 1px #bbbbbb42;box-shadow:1px 3px 4px 1px #bbbbbb42;-webkit-transition:bottom .6s ease-in-out,opacity .8s ease-in-out,scale .2s ease-in-out;transition:bottom .6s ease-in-out,opacity .8s ease-in-out,scale .2s ease-in-out;overflow:hidden}.didagent__fabio>button>video,.didagent__fabio>button img{border-radius:100%;position:absolute;top:50%;left:50%;translate:-50% -50%;-o-object-fit:cover;object-fit:cover;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out}.didagent__fabio>button>video{width:100%;height:100%}.didagent__fabio>button:hover{background:#494949;scale:1.1}.didagent__fabio>button:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:#0000001a;border-radius:50%}.didagent__fabio .didagent__fabio__speak_with{z-index:-1;position:absolute;top:50%;right:110%;background:#494949e6;font-size:14px;text-align:center;border-radius:10px 10px 0;translate:0px -50%;width:90px;-webkit-transition:all .5s ease-in-out;transition:all .5s ease-in-out;height:50px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;pointer-events:none}.didagent__fabio .didagent__fabio__speak_with>div{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-weight:400;color:#fff}.didagent__fabio .didagent__fabio__speak_with:after{position:absolute;top:0;left:100%;width:30px;height:100%;background:inherit}.didagent__fabio .didagent__transition_out{-webkit-transition:all .4s ease-in-out;transition:all .4s ease-in-out}.didagent__fabio .didagent__fabio__container{overflow:hidden;-webkit-transition:height .2s ease-in-out,opacity .2s ease-in-out;transition:height .2s ease-in-out,opacity .2s ease-in-out;position:absolute;bottom:0;border-radius:16px}@media (max-width: 600px){.didagent__fabio .didagent__fabio__container{position:fixed;border-radius:0;width:100%;height:100%;max-height:100vh;max-width:100vw;bottom:0;left:0}}.didagent__fabio .didagent__fabio__container .didagent__close__button{display:-webkit-box;display:-ms-flexbox;display:flex}.didagent__fabio .didagent__fabio__container[data-position=left]{left:0}.didagent__fabio .didagent__fabio__container[data-position=right]{right:0}.didagent__fabio .didagent__fabio__container[data-enabled=true]{opacity:1;pointer-events:auto;z-index:100}@media (max-width: 600px){.didagent__fabio .didagent__fabio__container[data-enabled=true]{position:fixed;border-radius:0;width:100%;height:100%;max-height:100vh;max-width:100vw;bottom:0;left:0}}@media (min-width: 600px){.didagent__fabio .didagent__fabio__container[data-enabled=true]{height:80vh;max-width:100vw;max-height:700px;aspect-ratio:2 / 3.3}}@media (min-width: 1280px){.didagent__fabio .didagent__fabio__container[data-enabled=true][data-orientation=horizontal]{aspect-ratio:4 / 3}}.didagent__fabio .didagent__fabio__container[data-enabled=false]{opacity:0;pointer-events:none;z-index:-1;height:0}',{})})();
var Km = Object.defineProperty;
var Jm = (t, e, n) => e in t ? Km(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Le = (t, e, n) => (Jm(t, typeof e != "symbol" ? e + "" : e, n), n);
var tt = /* @__PURE__ */ ((t) => (t.Unrated = "Unrated", t.Positive = "Positive", t.Negative = "Negative", t))(tt || {}), M = /* @__PURE__ */ ((t) => (t.Functional = "Functional", t.TextOnly = "TextOnly", t.Maintenance = "Maintenance", t.Playground = "Playground", t.DirectPlayback = "DirectPlayback", t))(M || {}), zn = /* @__PURE__ */ ((t) => (t.Embed = "embed", t.Query = "query", t.Partial = "partial", t.Answer = "answer", t.Complete = "done", t))(zn || {}), uv = /* @__PURE__ */ ((t) => (t.Clip = "clip", t.Talk = "talk", t))(uv || {});
const Gm = (t) => {
  switch (t) {
    case "clip":
      return "clip";
    case "talk":
      return "talk";
    default:
      throw new Error(`Unknown video type: ${t}`);
  }
};
var fn = /* @__PURE__ */ ((t) => (t.Start = "START", t.Stop = "STOP", t))(fn || {}), yo = /* @__PURE__ */ ((t) => (t.ChatAnswer = "chat/answer", t.ChatPartial = "chat/partial", t.StreamDone = "stream/done", t.StreamStarted = "stream/started", t.StreamFailed = "stream/error", t.StreamReady = "stream/ready", t.StreamCreated = "stream/created", t.StreamVideoCreated = "stream-video/started", t.StreamVideoDone = "stream-video/done", t.StreamVideoError = "stream-video/error", t.StreamVideoRejected = "stream-video/rejected", t))(yo || {}), G = /* @__PURE__ */ ((t) => (t.New = "new", t.Fail = "fail", t.Connected = "connected", t.Connecting = "connecting", t.Closed = "closed", t.Completed = "completed", t.Disconnected = "disconnected", t))(G || {});
const Co = "https://api.d-id.com", Qm = "wss://notifications.d-id.com", Ym = "79f81a83a67430be2bc0fd61042b8faa", oo = () => Math.random().toString(16).slice(2);
function pv() {
  let t = window.localStorage.getItem("did_external_key_id");
  return t || (t = Math.random().toString(16).slice(2), window.localStorage.setItem("did_external_key_id", t)), t;
}
let Zm = oo();
function dv(t) {
  if (t.type === "bearer")
    return `Bearer ${t.token}`;
  if (t.type === "basic")
    return `Basic ${btoa(`${t.username}:${t.password}`)}`;
  if (t.type === "key")
    return `Client-Key ${t.clientKey}.${pv()}_${Zm}`;
  throw new Error(`Unknown auth type: ${t}`);
}
function pu(t, e = Co, n) {
  const r = async (s, o) => {
    const a = await fetch(e + (s != null && s.startsWith("/") ? s : `/${s}`), {
      ...o,
      headers: {
        ...o == null ? void 0 : o.headers,
        Authorization: dv(t),
        "Content-Type": "application/json"
      }
    });
    if (!a.ok) {
      let i = await a.text().catch(() => "Failed to fetch");
      throw n && n(new Error(i), {
        url: s,
        options: o,
        headers: a.headers
      }), new Error(i);
    }
    return a.json();
  };
  return {
    get(s, o) {
      return r(s, {
        ...o,
        method: "GET"
      });
    },
    post(s, o, a) {
      return r(s, {
        ...a,
        body: JSON.stringify(o),
        method: "POST"
      });
    },
    delete(s, o, a) {
      return r(s, {
        ...a,
        body: JSON.stringify(o),
        method: "DELETE"
      });
    },
    patch(s, o, a) {
      return r(s, {
        ...a,
        body: JSON.stringify(o),
        method: "PATCH"
      });
    }
  };
}
function Xm(t, e = Co, n) {
  const r = pu(t, `${e}/agents`, n);
  return {
    create(s, o) {
      return r.post("/", s, o);
    },
    getAgents(s, o) {
      return r.get(`/${s ? `?tag=${s}` : ""}`, o).then((a) => a ?? []);
    },
    getById(s, o) {
      return r.get(`/${s}`, o);
    },
    delete(s, o) {
      return r.delete(`/${s}`, void 0, o);
    },
    update(s, o, a) {
      return r.patch(`/${s}`, o, a);
    },
    newChat(s, o, a) {
      return r.post(`/${s}/chat`, o, a);
    },
    chat(s, o, a, i) {
      return r.post(`/${s}/chat/${o}`, a, i);
    },
    createRating(s, o, a, i) {
      return r.post(`/${s}/chat/${o}/ratings`, a, i);
    },
    updateRating(s, o, a, i, c) {
      return r.patch(`/${s}/chat/${o}/ratings/${a}`, i, c);
    },
    deleteRating(s, o, a, i) {
      return r.delete(`/${s}/chat/${o}/ratings/${a}`, i);
    },
    getSTTToken(s, o) {
      return r.get(`/${s}/stt-token`, o);
    }
  };
}
const eS = (t) => new Promise((e) => setTimeout(e, t));
function tS(t) {
  return new Promise((e, n) => {
    const {
      callbacks: r,
      host: s,
      auth: o
    } = t, {
      onMessage: a = null,
      onOpen: i = null,
      onClose: c = null,
      onError: u = null
    } = r || {}, p = new WebSocket(`${s}?authorization=${dv(o)}`);
    p.onmessage = a, p.onclose = c, p.onerror = (d) => {
      console.error(d), u == null || u("Websocket failed to connect", d), n(d);
    }, p.onopen = (d) => {
      i == null || i(d), e(p);
    };
  });
}
async function nS(t) {
  const {
    retries: e = 1
  } = t;
  let n = null;
  for (let r = 0; (n == null ? void 0 : n.readyState) !== WebSocket.OPEN; r++)
    try {
      n = await tS(t);
    } catch (s) {
      if (r === e)
        throw s;
      await eS(r * 500);
    }
  return n;
}
async function rS(t, e, n) {
  const r = n != null && n.onMessage ? [n.onMessage] : [], s = await nS({
    auth: t,
    host: e,
    callbacks: {
      onError: n == null ? void 0 : n.onError,
      onMessage: (o) => {
        const a = JSON.parse(o.data);
        r.forEach((i) => i(a.event, a));
      }
    }
  });
  return {
    socket: s,
    disconnect: () => s.close(),
    subscribeToEvents: (o) => r.push(o)
  };
}
const iS = "X-Playground-Chat";
function sS(t, e, n, r) {
  const s = pu(t, `${e}/agents/${n}`, r);
  return {
    createStream(o) {
      return s.post("/streams", {
        output_resolution: o.output_resolution,
        compatibility_mode: o.compatibility_mode,
        stream_warmup: o.stream_warmup,
        session_timeout: o.session_timeout,
        stream_greeting: o.stream_greeting
      });
    },
    startConnection(o, a, i) {
      return s.post(`/streams/${o}/sdp`, {
        session_id: i,
        answer: a
      });
    },
    addIceCandidate(o, a, i) {
      return s.post(`/streams/${o}/ice`, {
        session_id: i,
        ...a
      });
    },
    sendStreamRequest(o, a, i) {
      return s.post(`/streams/${o}`, {
        session_id: a,
        ...i
      });
    },
    close(o, a) {
      return s.delete(`/streams/${o}`, {
        session_id: a
      });
    }
  };
}
function oS(t, e, n, r) {
  const s = pu(t, `${e}/agents/${n}`, r);
  return {
    createStream(o, a) {
      return s.post("/streams", {
        driver_url: o.driver_url,
        face: o.face,
        config: o.config,
        output_resolution: o.output_resolution,
        compatibility_mode: o.compatibility_mode,
        stream_warmup: o.stream_warmup,
        session_timeout: o.session_timeout,
        stream_greeting: o.stream_greeting
      }, a);
    },
    startConnection(o, a, i, c) {
      return s.post(`/streams/${o}/sdp`, {
        session_id: i,
        answer: a
      }, c);
    },
    addIceCandidate(o, a, i, c) {
      return s.post(`/streams/${o}/ice`, {
        session_id: i,
        ...a
      }, c);
    },
    sendStreamRequest(o, a, i, c) {
      return s.post(`/streams/${o}`, {
        session_id: a,
        ...i
      }, c);
    },
    close(o, a, i) {
      return s.delete(`/streams/${o}`, {
        session_id: a
      }, i);
    }
  };
}
let lv = !1;
const bt = (t, e) => lv && console.log(t, e), aS = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function up(t) {
  switch (t) {
    case "connected":
      return G.Connected;
    case "checking":
      return G.Connecting;
    case "failed":
      return G.Fail;
    case "new":
      return G.New;
    case "closed":
      return G.Closed;
    case "disconnected":
      return G.Disconnected;
    case "completed":
      return G.Completed;
    default:
      return G.New;
  }
}
function cS() {
  let t = 0;
  return (e) => {
    for (const n of e.values())
      if (n && n.type === "inbound-rtp" && n.kind === "video") {
        const r = n.bytesReceived, s = r - t > 0;
        return t = r, s;
      }
    return !1;
  };
}
function uS(t, e, n = !1, r, s) {
  const o = Math.max(Math.ceil(10), 1);
  let a = 0, i = !1;
  const c = n ? 1 : 0;
  let u = 0;
  const p = cS();
  return setInterval(async () => {
    const d = await t.getStats();
    p(d) ? (a = 0, i || (e == null || e(fn.Start), u >= c && !r() && s(), u++, i = !0)) : i && (a++, a >= o && (e == null || e(fn.Stop), i = !1));
  }, 100);
}
async function pS(t, e, {
  debug: n = !1,
  callbacks: r,
  auth: s,
  baseURL: o = Co,
  warmup: a
}) {
  lv = n;
  const {
    startConnection: i,
    sendStreamRequest: c,
    close: u,
    createStream: p,
    addIceCandidate: d
  } = e.videoType === uv.Clip ? sS(s, o, t, r.onError) : oS(s, o, t, r.onError), {
    id: l,
    offer: h,
    ice_servers: v,
    session_id: g
  } = await p(e), f = new aS({
    iceServers: v
  }), m = f.createDataChannel("JanusDataChannel");
  if (!g)
    throw new Error("Could not create session_id");
  let S = !1;
  const y = () => S, E = () => {
    var R;
    S = !0, (R = r.onConnectionStateChange) == null || R.call(r, G.Connected);
  }, _ = uS(f, r.onVideoStateChange, a, y, E);
  f.onicecandidate = (R) => {
    var T;
    bt("peerConnection.onicecandidate", R);
    try {
      R.candidate && R.candidate.sdpMid && R.candidate.sdpMLineIndex !== null ? d(l, {
        candidate: R.candidate.candidate,
        sdpMid: R.candidate.sdpMid,
        sdpMLineIndex: R.candidate.sdpMLineIndex
      }, g) : d(l, {
        candidate: null
      }, g);
    } catch (A) {
      (T = r.onError) == null || T.call(r, A, {
        streamId: l
      });
    }
  }, m.onmessage = (R) => {
    if (m.readyState === "open") {
      const [T, A] = R.data.split(":");
      T === yo.StreamReady && !S && E();
    }
  }, f.oniceconnectionstatechange = () => {
    var R;
    bt("peerConnection.oniceconnectionstatechange => " + f.iceConnectionState);
    const T = up(f.iceConnectionState);
    T !== G.Connected && ((R = r.onConnectionStateChange) == null || R.call(r, T));
  }, f.ontrack = (R) => {
    var T;
    bt("peerConnection.ontrack", R), (T = r.onSrcObjectReady) == null || T.call(r, R.streams[0]);
  }, await f.setRemoteDescription(h), bt("set remote description OK");
  const C = await f.createAnswer();
  return bt("create answer OK"), await f.setLocalDescription(C), bt("set local description OK"), await i(l, C, g), bt("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(R) {
      return c(l, g, R);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var R, T;
      if (l) {
        const A = up(f.iceConnectionState);
        if (f) {
          if (A === G.New) {
            (R = r.onVideoStateChange) == null || R.call(r, fn.Stop), clearInterval(_);
            return;
          }
          f.close(), f.oniceconnectionstatechange = null, f.onnegotiationneeded = null, f.onicecandidate = null, f.ontrack = null;
        }
        try {
          A === G.Connected && await u(l, g).catch((U) => {
          });
        } catch (U) {
          bt("Error on close stream connection", U);
        }
        (T = r.onVideoStateChange) == null || T.call(r, fn.Stop), clearInterval(_);
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: g,
    /**
     * Id of current RTC stream
     */
    streamId: l
  };
}
let Ya = {};
function dS(t) {
  const e = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk", n = t.agent.presenter, r = {
    token: t.token || "testKey",
    distinct_id: t.distinctId || pv(),
    agentId: t.agent.id,
    agentType: n.type === "clip" && n.presenter_id.startsWith("v2_") ? "clip_v2" : n.type,
    owner_id: t.agent.owner_id ?? ""
  };
  return {
    ...r,
    isEnabled: t.isEnabled ?? !0,
    getRandom: () => Math.random().toString(16).slice(2),
    track(s, o) {
      if (!this.isEnabled)
        return Promise.resolve();
      const {
        audioPath: a,
        ...i
      } = o || {}, c = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([{
            event: s,
            properties: {
              ...i,
              ...r,
              source: e,
              time: Date.now(),
              $insert_id: this.getRandom(),
              origin: window.location.href,
              "Screen Height": window.screen.height || window.innerWidth,
              "Screen Width": window.screen.width || window.innerHeight,
              "User Agent": navigator.userAgent
            }
          }])
        })
      };
      return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", c).then((u) => u.json()).catch((u) => console.error(u));
    },
    linkTrack(s, o, a, i) {
      Ya[s] || (Ya[s] = {
        events: {},
        resolvedDependencies: []
      }), i.includes(a) || i.push(a);
      const c = Ya[s];
      if (c.events[a] = {
        props: o
      }, c.resolvedDependencies.push(a), i.every((u) => c.resolvedDependencies.includes(u))) {
        const u = i.reduce((p, d) => c.events[d] ? {
          ...p,
          ...c.events[d].props
        } : p, {});
        this.track(s, u), c.resolvedDependencies = c.resolvedDependencies.filter((p) => !i.includes(p)), i.forEach((p) => {
          delete c.events[p];
        });
      }
    }
  };
}
function lS(t) {
  var e, n, r, s;
  const o = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop", a = () => {
    const c = navigator.platform;
    return c.toLowerCase().includes("win") ? "Windows" : c.toLowerCase().includes("mac") ? "Mac OS X" : c.toLowerCase().includes("linux") ? "Linux" : "Unknown";
  }, i = t.presenter;
  return {
    $os: `${a()}`,
    isMobile: `${o() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: i.type === "clip" && i.presenter_id.startsWith("v2_") ? "clip_v2" : i.type,
    agentVoice: {
      voiceId: (n = (e = t.presenter) == null ? void 0 : e.voice) == null ? void 0 : n.voice_id,
      provider: (s = (r = t.presenter) == null ? void 0 : r.voice) == null ? void 0 : s.type
    }
  };
}
function hS(t, e, n) {
  var r, s;
  const {
    event: o,
    ...a
  } = t, {
    template: i
  } = (e == null ? void 0 : e.llm) || {}, {
    language: c
  } = ((r = e == null ? void 0 : e.presenter) == null ? void 0 : r.voice) || {}, {
    stitch: u
  } = (e == null ? void 0 : e.presenter) || {};
  return {
    ...a,
    llm: {
      ...a.llm,
      template: i
    },
    script: {
      ...a.script,
      provider: {
        ...(s = a == null ? void 0 : a.script) == null ? void 0 : s.provider,
        language: c
      }
    },
    stitch: u,
    ...n
  };
}
let dn = 0;
const vS = 20 * 1e3;
function fS(t, e, n, r) {
  var s, o, a, i, c;
  return {
    videoType: Gm(t.presenter.type),
    output_resolution: (s = n == null ? void 0 : n.streamOptions) == null ? void 0 : s.outputResolution,
    session_timeout: (o = n == null ? void 0 : n.streamOptions) == null ? void 0 : o.sessionTimeout,
    stream_warmup: (a = n == null ? void 0 : n.streamOptions) == null ? void 0 : a.streamWarmup,
    compatibility_mode: (i = n == null ? void 0 : n.streamOptions) == null ? void 0 : i.compatibilityMode,
    stream_greeting: (c = n == null ? void 0 : n.streamOptions) != null && c.streamGreeting && !e ? r : void 0
  };
}
function hv(t) {
  return t === M.Playground ? {
    headers: {
      [iS]: "true"
    }
  } : {};
}
async function vv(t, e, n, r, s) {
  try {
    const o = await e.newChat(t, {
      persist: s ?? !1
    }, hv(r));
    return n.track("agent-chat", {
      event: "created",
      chat_id: o.id,
      agent_id: t,
      mode: r
    }), o;
  } catch (o) {
    try {
      console.error(o);
      const a = JSON.parse(o.message);
      if ((a == null ? void 0 : a.kind) === "InsufficientCreditsError")
        throw new Error("InsufficientCreditsError");
    } catch (a) {
      console.error("Error parsing the error message:", a);
    }
    throw new Error("Cannot create new chat");
  }
}
function gS(t, e, n, r, s, o) {
  return new Promise(async (a, i) => {
    var c;
    dn = 0;
    const u = setTimeout(() => {
      d(new Error("Could not connect"));
    }, vS), p = (v) => {
      clearTimeout(u), a(v);
    }, d = (v) => {
      clearTimeout(u), i(v);
    };
    let l;
    !s && e.mode !== M.DirectPlayback && (l = vv(t.id, n, r, e.mode, e.persistentChat).catch((v) => {
      d(v);
    }));
    const h = await pS(t.id, fS(t, s, e, o), {
      ...e,
      analytics: r,
      warmup: (c = e.streamOptions) == null ? void 0 : c.streamWarmup,
      callbacks: {
        ...e.callbacks,
        onConnectionStateChange: async (v) => {
          var g, f, m, S;
          v === G.Connected ? (l && (s = await l), h ? ((f = (g = e.callbacks).onConnectionStateChange) == null || f.call(g, v), p({
            chat: s,
            streamingManager: h
          })) : s && d(new Error("Something went wrong while initializing the manager"))) : (S = (m = e.callbacks).onConnectionStateChange) == null || S.call(m, v);
        },
        onVideoStateChange(v) {
          var g, f;
          (f = (g = e.callbacks).onVideoStateChange) == null || f.call(g, v), dn > 0 && v === fn.Start && r.linkTrack("agent-video", {
            event: "start",
            latency: Date.now() - dn
          }, "start", [yo.StreamVideoCreated]);
        }
      }
    }).catch(d);
  });
}
function mS(t) {
  var e;
  const n = (e = t.greetings) == null ? void 0 : e.filter((r) => r.length > 0);
  if (n && n.length > 0) {
    const r = Math.floor(Math.random() * n.length);
    return n[r];
  } else
    return `Hi! I'm ${t.preview_name || "My Agent"}. How can I help you?`;
}
function pp(t, e) {
  return e && e.length > 0 ? e : [{
    content: t,
    id: oo(),
    role: "assistant",
    created_at: (/* @__PURE__ */ new Date()).toISOString()
  }];
}
function SS(t) {
  if (t.answer !== void 0)
    return t.answer;
  let e = 0, n = "";
  for (; e in t; )
    n += t[e], e++;
  return n;
}
function yS(t, e, n, r, s) {
  if (!(t === zn.Partial || t === zn.Answer))
    return;
  const o = r.messages[r.messages.length - 1];
  if ((o == null ? void 0 : o.role) !== "assistant")
    return;
  const {
    content: a,
    sequence: i
  } = e;
  t === zn.Partial ? n[i] = a : n.answer = a;
  const c = SS(n);
  (o.content !== c || t === zn.Answer) && (o.content = c, s == null || s([...r.messages], t));
}
async function CS(t, e) {
  var n, r, s;
  let o = {}, a = !0;
  const i = {
    messages: [],
    chatMode: e.mode || M.Functional
  }, c = e.baseURL || Co, u = e.wsURL || Qm, p = e.mixpanelKey || Ym, d = Xm(e.auth, c, e.callbacks.onError), l = await d.getById(t), h = mS(l);
  i.messages = pp(h, e.initialMessages), (r = (n = e.callbacks).onNewMessage) == null || r.call(n, [...i.messages], "answer");
  const v = dS({
    token: p,
    agent: l,
    isEnabled: e.enableAnalitics,
    distinctId: e.distinctId
  });
  v.track("agent-sdk", {
    event: "loaded",
    ...lS(l)
  });
  const g = {
    onMessage: (y, E) => {
      var _, C;
      if ("content" in E)
        yS(y, E, o, i, e.callbacks.onNewMessage), y === zn.Answer && v.track("agent-message-received", {
          messages: i.messages.length,
          mode: i.chatMode
        });
      else {
        const R = yo, T = [R.StreamVideoDone, R.StreamVideoError, R.StreamVideoRejected], A = [R.StreamFailed, R.StreamVideoError, R.StreamVideoRejected], U = hS(E, l, {
          mode: i.chatMode
        });
        if (y = y, y === R.StreamVideoCreated)
          v.linkTrack("agent-video", U, R.StreamVideoCreated, ["start"]);
        else if (T.includes(y)) {
          const K = y.split("/")[1];
          v.track("agent-video", {
            ...U,
            event: K
          });
        }
        A.includes(y) && ((C = (_ = e.callbacks).onError) == null || C.call(_, new Error(`Stream failed with event ${y}`), {
          data: E
        })), E.event === R.StreamDone && m();
      }
    }
  };
  async function f(y) {
    var E, _, C, R, T, A, U;
    (_ = (E = e.callbacks).onConnectionStateChange) == null || _.call(E, G.Connecting), dn = 0;
    const K = 3;
    y && !a && (delete i.chat, i.messages = pp(h), (R = (C = e.callbacks).onNewMessage) == null || R.call(C, [...i.messages], "answer"));
    const Y = e.mode === M.DirectPlayback ? Promise.resolve(void 0) : rS(e.auth, u, g);
    async function J() {
      var X, Z, ye;
      for (let Ie = 1; Ie <= K; Ie++)
        try {
          const Ve = await gS(l, e, d, v, i.chat, y ? h : void 0);
          return Ve.chat && Ve.chat.id !== ((X = i.chat) == null ? void 0 : X.id) && (i.chat = Ve.chat, (ye = (Z = e.callbacks).onNewChat) == null || ye.call(Z, Ve.chat.id)), Ve;
        } catch (Ve) {
          if ((Ve == null ? void 0 : Ve.message) !== "Could not connect")
            throw Ve;
        }
      throw new Error("Could not connect");
    }
    const he = J().catch((X) => {
      var Z, ye;
      throw S(M.Maintenance), (ye = (Z = e.callbacks).onConnectionStateChange) == null || ye.call(Z, G.Fail), X;
    }), [ve, {
      streamingManager: re,
      chat: N
    }] = await Promise.all([Y, he]);
    N && N.id !== ((T = i.chat) == null ? void 0 : T.id) && ((U = (A = e.callbacks).onNewChat) == null || U.call(A, N.id)), i.streamingManager = re, i.socketManager = ve, i.chat = N, a = !1, S((N == null ? void 0 : N.chat_mode) ?? e.mode ?? M.Functional);
  }
  async function m() {
    var y, E, _, C;
    (y = i.socketManager) == null || y.disconnect(), await ((E = i.streamingManager) == null ? void 0 : E.disconnect()), delete i.streamingManager, delete i.socketManager, (C = (_ = e.callbacks).onConnectionStateChange) == null || C.call(_, G.Disconnected);
  }
  async function S(y) {
    var E, _;
    y !== i.chatMode && (v.track("agent-mode-change", {
      mode: y
    }), i.chatMode = y, i.chatMode !== M.Functional && await m(), (_ = (E = e.callbacks).onModeChange) == null || _.call(E, y));
  }
  return {
    agent: l,
    starterMessages: ((s = l.knowledge) == null ? void 0 : s.starter_message) || [],
    getSTTToken: () => d.getSTTToken(l.id),
    changeMode: S,
    async connect() {
      var y;
      await f(!0), v.track("agent-chat", {
        event: "connect",
        chatId: (y = i.chat) == null ? void 0 : y.id,
        agentId: l.id,
        mode: i.chatMode
      });
    },
    async reconnect() {
      var y;
      await m(), await f(!1), v.track("agent-chat", {
        event: "reconnect",
        chatId: (y = i.chat) == null ? void 0 : y.id,
        agentId: l.id,
        mode: i.chatMode
      });
    },
    async disconnect() {
      var y;
      await m(), v.track("agent-chat", {
        event: "disconnect",
        chatId: (y = i.chat) == null ? void 0 : y.id,
        agentId: l.id,
        mode: i.chatMode
      });
    },
    async chat(y) {
      var E, _, C, R, T, A;
      const U = oo();
      o = {};
      try {
        if (dn = Date.now(), e.mode === M.DirectPlayback)
          throw new Error("Direct playback is enabled, chat is disabled");
        if (y.length >= 800)
          throw new Error("Message cannot be more than 800 characters");
        if (y.length === 0)
          throw new Error("Message cannot be empty");
        if (i.chatMode === M.Maintenance)
          throw new Error("Chat is in maintenance mode");
        if (![M.TextOnly, M.Playground].includes(i.chatMode))
          if (i.streamingManager) {
            if (!i.chat)
              throw new Error("Chat is not initialized");
          } else
            throw new Error("Streaming manager is not initialized");
        i.messages.push({
          id: oo(),
          role: "user",
          content: y,
          created_at: new Date(dn).toISOString()
        }), (_ = (E = e.callbacks).onNewMessage) == null || _.call(E, [...i.messages], "user"), i.chat || (i.chat = await vv(l.id, d, v, i.chatMode, e.persistentChat), (R = (C = e.callbacks).onNewChat) == null || R.call(C, i.chat.id));
        const K = {
          id: U,
          role: "assistant",
          content: "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          matches: []
        }, Y = [...i.messages];
        i.messages.push(K);
        const J = (ve) => {
          var re, N;
          return d.chat(l.id, ve, {
            sessionId: (re = i.streamingManager) == null ? void 0 : re.sessionId,
            streamId: (N = i.streamingManager) == null ? void 0 : N.streamId,
            chatMode: i.chatMode,
            messages: Y.map(({
              matches: X,
              ...Z
            }) => Z)
          }, hv(i.chatMode));
        }, he = await J(i.chat.id).catch(async (ve) => {
          var re;
          if (!((re = ve == null ? void 0 : ve.message) != null && re.includes("missing or invalid session_id")))
            throw ve;
          return await m(), await f(!1), J(i.chat.id);
        });
        return v.track("agent-message-send", {
          event: "success",
          mode: i.chatMode,
          messages: i.messages.length + 1
        }), K.context = he.context, K.matches = he.matches, he.result && (K.content = he.result, v.track("agent-message-received", {
          latency: Date.now() - dn,
          mode: i.chatMode,
          messages: i.messages.length
        }), (A = (T = e.callbacks).onNewMessage) == null || A.call(T, [...i.messages], "answer")), he;
      } catch (K) {
        throw i.messages[i.messages.length - 1].id === U && i.messages.pop(), v.track("agent-message-send", {
          event: "error",
          mode: i.chatMode,
          messages: i.messages.length
        }), K;
      }
    },
    rate(y, E, _) {
      var C, R, T, A;
      const U = i.messages.find((Y) => Y.id === y);
      if (i.chat) {
        if (!U)
          throw new Error("Message not found");
      } else
        throw new Error("Chat is not initialized");
      const K = ((C = U.matches) == null ? void 0 : C.map((Y) => [Y.document_id, Y.id])) ?? [];
      return v.track("agent-rate", {
        event: _ ? "update" : "create",
        thumb: E === 1 ? "up" : "down",
        knowledge_id: ((R = l.knowledge) == null ? void 0 : R.id) ?? "",
        mode: i.chatMode,
        matches: K,
        score: E
      }), _ ? d.updateRating(l.id, i.chat.id, _, {
        knowledge_id: ((T = l.knowledge) == null ? void 0 : T.id) ?? "",
        message_id: y,
        matches: K,
        score: E
      }) : d.createRating(l.id, i.chat.id, {
        knowledge_id: ((A = l.knowledge) == null ? void 0 : A.id) ?? "",
        message_id: y,
        matches: K,
        score: E
      });
    },
    deleteRate(y) {
      var E;
      if (!i.chat)
        throw new Error("Chat is not initialized");
      return v.track("agent-rate-delete", {
        type: "text",
        chat_id: (E = i.chat) == null ? void 0 : E.id,
        id: y,
        mode: i.chatMode
      }), d.deleteRating(l.id, i.chat.id, y);
    },
    speak(y) {
      if (!i.streamingManager)
        throw new Error("Please connect to the agent first");
      function E() {
        if (typeof y == "string") {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: y,
            ssml: !1
          };
        }
        if (y.type === "text" && !y.provider) {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: y.input,
            ssml: y.ssml
          };
        }
        return y;
      }
      const _ = E();
      return v.track("agent-speak", _), i.streamingManager.speak({
        script: _
      });
    }
  };
}
var _o, q, fv, un, dp, gv, bc, du, Ac, Mc, mv, es = {}, Sv = [], _S = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Ro = Array.isArray;
function kt(t, e) {
  for (var n in e)
    t[n] = e[n];
  return t;
}
function yv(t) {
  var e = t.parentNode;
  e && e.removeChild(t);
}
function ts(t, e, n) {
  var r, s, o, a = {};
  for (o in e)
    o == "key" ? r = e[o] : o == "ref" ? s = e[o] : a[o] = e[o];
  if (arguments.length > 2 && (a.children = arguments.length > 3 ? _o.call(arguments, 2) : n), typeof t == "function" && t.defaultProps != null)
    for (o in t.defaultProps)
      a[o] === void 0 && (a[o] = t.defaultProps[o]);
  return Ys(t, a, r, s, null);
}
function Ys(t, e, n, r, s) {
  var o = { type: t, props: e, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: s ?? ++fv, __i: -1, __u: 0 };
  return s == null && q.vnode != null && q.vnode(o), o;
}
function xt(t) {
  return t.children;
}
function Ct(t, e) {
  this.props = t, this.context = e;
}
function gn(t, e) {
  if (e == null)
    return t.__ ? gn(t.__, t.__i + 1) : null;
  for (var n; e < t.__k.length; e++)
    if ((n = t.__k[e]) != null && n.__e != null)
      return n.__e;
  return typeof t.type == "function" ? gn(t) : null;
}
function Cv(t) {
  var e, n;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
      if ((n = t.__k[e]) != null && n.__e != null) {
        t.__e = t.__c.base = n.__e;
        break;
      }
    return Cv(t);
  }
}
function Oc(t) {
  (!t.__d && (t.__d = !0) && un.push(t) && !ao.__r++ || dp !== q.debounceRendering) && ((dp = q.debounceRendering) || gv)(ao);
}
function ao() {
  var t, e, n, r, s, o, a, i;
  for (un.sort(bc); t = un.shift(); )
    t.__d && (e = un.length, r = void 0, o = (s = (n = t).__v).__e, a = [], i = [], n.__P && ((r = kt({}, s)).__v = s.__v + 1, q.vnode && q.vnode(r), lu(n.__P, r, s, n.__n, n.__P.namespaceURI, 32 & s.__u ? [o] : null, a, o ?? gn(s), !!(32 & s.__u), i), r.__v = s.__v, r.__.__k[r.__i] = r, Pv(a, r, i), r.__e != o && Cv(r)), un.length > e && un.sort(bc));
  ao.__r = 0;
}
function _v(t, e, n, r, s, o, a, i, c, u, p) {
  var d, l, h, v, g, f = r && r.__k || Sv, m = e.length;
  for (n.__d = c, RS(n, e, f), c = n.__d, d = 0; d < m; d++)
    (h = n.__k[d]) != null && typeof h != "boolean" && typeof h != "function" && (l = h.__i === -1 ? es : f[h.__i] || es, h.__i = d, lu(t, h, l, s, o, a, i, c, u, p), v = h.__e, h.ref && l.ref != h.ref && (l.ref && hu(l.ref, null, h), p.push(h.ref, h.__c || v, h)), g == null && v != null && (g = v), 65536 & h.__u || l.__k === h.__k ? (c && !c.isConnected && (c = gn(l)), c = Rv(h, c, t)) : typeof h.type == "function" && h.__d !== void 0 ? c = h.__d : v && (c = v.nextSibling), h.__d = void 0, h.__u &= -196609);
  n.__d = c, n.__e = g;
}
function RS(t, e, n) {
  var r, s, o, a, i, c = e.length, u = n.length, p = u, d = 0;
  for (t.__k = [], r = 0; r < c; r++)
    a = r + d, (s = t.__k[r] = (s = e[r]) == null || typeof s == "boolean" || typeof s == "function" ? null : typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? Ys(null, s, null, null, null) : Ro(s) ? Ys(xt, { children: s }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? Ys(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s) != null ? (s.__ = t, s.__b = t.__b + 1, i = PS(s, n, a, p), s.__i = i, o = null, i !== -1 && (p--, (o = n[i]) && (o.__u |= 131072)), o == null || o.__v === null ? (i == -1 && d--, typeof s.type != "function" && (s.__u |= 65536)) : i !== a && (i === a + 1 ? d++ : i > a ? p > c - a ? d += i - a : d-- : i < a ? i == a - 1 && (d = i - a) : d = 0, i !== r + d && (s.__u |= 65536))) : (o = n[a]) && o.key == null && o.__e && !(131072 & o.__u) && (o.__e == t.__d && (t.__d = gn(o)), kc(o, o, !1), n[a] = null, p--);
  if (p)
    for (r = 0; r < u; r++)
      (o = n[r]) != null && !(131072 & o.__u) && (o.__e == t.__d && (t.__d = gn(o)), kc(o, o));
}
function Rv(t, e, n) {
  var r, s;
  if (typeof t.type == "function") {
    for (r = t.__k, s = 0; r && s < r.length; s++)
      r[s] && (r[s].__ = t, e = Rv(r[s], e, n));
    return e;
  }
  t.__e != e && (n.insertBefore(t.__e, e || null), e = t.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType === 8);
  return e;
}
function co(t, e) {
  return e = e || [], t == null || typeof t == "boolean" || (Ro(t) ? t.some(function(n) {
    co(n, e);
  }) : e.push(t)), e;
}
function PS(t, e, n, r) {
  var s = t.key, o = t.type, a = n - 1, i = n + 1, c = e[n];
  if (c === null || c && s == c.key && o === c.type && !(131072 & c.__u))
    return n;
  if (r > (c != null && !(131072 & c.__u) ? 1 : 0))
    for (; a >= 0 || i < e.length; ) {
      if (a >= 0) {
        if ((c = e[a]) && !(131072 & c.__u) && s == c.key && o === c.type)
          return a;
        a--;
      }
      if (i < e.length) {
        if ((c = e[i]) && !(131072 & c.__u) && s == c.key && o === c.type)
          return i;
        i++;
      }
    }
  return -1;
}
function lp(t, e, n) {
  e[0] === "-" ? t.setProperty(e, n ?? "") : t[e] = n == null ? "" : typeof n != "number" || _S.test(e) ? n : n + "px";
}
function Bs(t, e, n, r, s) {
  var o;
  e:
    if (e === "style")
      if (typeof n == "string")
        t.style.cssText = n;
      else {
        if (typeof r == "string" && (t.style.cssText = r = ""), r)
          for (e in r)
            n && e in n || lp(t.style, e, "");
        if (n)
          for (e in n)
            r && n[e] === r[e] || lp(t.style, e, n[e]);
      }
    else if (e[0] === "o" && e[1] === "n")
      o = e !== (e = e.replace(/(PointerCapture)$|Capture$/i, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + o] = n, n ? r ? n.u = r.u : (n.u = du, t.addEventListener(e, o ? Mc : Ac, o)) : t.removeEventListener(e, o ? Mc : Ac, o);
    else {
      if (s == "http://www.w3.org/2000/svg")
        e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e in t)
        try {
          t[e] = n ?? "";
          break e;
        } catch {
        }
      typeof n == "function" || (n == null || n === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, n));
    }
}
function hp(t) {
  return function(e) {
    if (this.l) {
      var n = this.l[e.type + t];
      if (e.t == null)
        e.t = du++;
      else if (e.t < n.u)
        return;
      return n(q.event ? q.event(e) : e);
    }
  };
}
function lu(t, e, n, r, s, o, a, i, c, u) {
  var p, d, l, h, v, g, f, m, S, y, E, _, C, R, T, A = e.type;
  if (e.constructor !== void 0)
    return null;
  128 & n.__u && (c = !!(32 & n.__u), o = [i = e.__e = n.__e]), (p = q.__b) && p(e);
  e:
    if (typeof A == "function")
      try {
        if (m = e.props, S = (p = A.contextType) && r[p.__c], y = p ? S ? S.props.value : p.__ : r, n.__c ? f = (d = e.__c = n.__c).__ = d.__E : ("prototype" in A && A.prototype.render ? e.__c = d = new A(m, y) : (e.__c = d = new Ct(m, y), d.constructor = A, d.render = TS), S && S.sub(d), d.props = m, d.state || (d.state = {}), d.context = y, d.__n = r, l = d.__d = !0, d.__h = [], d._sb = []), d.__s == null && (d.__s = d.state), A.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = kt({}, d.__s)), kt(d.__s, A.getDerivedStateFromProps(m, d.__s))), h = d.props, v = d.state, d.__v = e, l)
          A.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), d.componentDidMount != null && d.__h.push(d.componentDidMount);
        else {
          if (A.getDerivedStateFromProps == null && m !== h && d.componentWillReceiveProps != null && d.componentWillReceiveProps(m, y), !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(m, d.__s, y) === !1 || e.__v === n.__v)) {
            for (e.__v !== n.__v && (d.props = m, d.state = d.__s, d.__d = !1), e.__e = n.__e, e.__k = n.__k, e.__k.forEach(function(U) {
              U && (U.__ = e);
            }), E = 0; E < d._sb.length; E++)
              d.__h.push(d._sb[E]);
            d._sb = [], d.__h.length && a.push(d);
            break e;
          }
          d.componentWillUpdate != null && d.componentWillUpdate(m, d.__s, y), d.componentDidUpdate != null && d.__h.push(function() {
            d.componentDidUpdate(h, v, g);
          });
        }
        if (d.context = y, d.props = m, d.__P = t, d.__e = !1, _ = q.__r, C = 0, "prototype" in A && A.prototype.render) {
          for (d.state = d.__s, d.__d = !1, _ && _(e), p = d.render(d.props, d.state, d.context), R = 0; R < d._sb.length; R++)
            d.__h.push(d._sb[R]);
          d._sb = [];
        } else
          do
            d.__d = !1, _ && _(e), p = d.render(d.props, d.state, d.context), d.state = d.__s;
          while (d.__d && ++C < 25);
        d.state = d.__s, d.getChildContext != null && (r = kt(kt({}, r), d.getChildContext())), l || d.getSnapshotBeforeUpdate == null || (g = d.getSnapshotBeforeUpdate(h, v)), _v(t, Ro(T = p != null && p.type === xt && p.key == null ? p.props.children : p) ? T : [T], e, n, r, s, o, a, i, c, u), d.base = e.__e, e.__u &= -161, d.__h.length && a.push(d), f && (d.__E = d.__ = null);
      } catch (U) {
        e.__v = null, c || o != null ? (e.__e = i, e.__u |= c ? 160 : 32, o[o.indexOf(i)] = null) : (e.__e = n.__e, e.__k = n.__k), q.__e(U, e, n);
      }
    else
      o == null && e.__v === n.__v ? (e.__k = n.__k, e.__e = n.__e) : e.__e = ES(n.__e, e, n, r, s, o, a, c, u);
  (p = q.diffed) && p(e);
}
function Pv(t, e, n) {
  e.__d = void 0;
  for (var r = 0; r < n.length; r++)
    hu(n[r], n[++r], n[++r]);
  q.__c && q.__c(e, t), t.some(function(s) {
    try {
      t = s.__h, s.__h = [], t.some(function(o) {
        o.call(s);
      });
    } catch (o) {
      q.__e(o, s.__v);
    }
  });
}
function ES(t, e, n, r, s, o, a, i, c) {
  var u, p, d, l, h, v, g, f = n.props, m = e.props, S = e.type;
  if (S === "svg" ? s = "http://www.w3.org/2000/svg" : S === "math" ? s = "http://www.w3.org/1998/Math/MathML" : s || (s = "http://www.w3.org/1999/xhtml"), o != null) {
    for (u = 0; u < o.length; u++)
      if ((h = o[u]) && "setAttribute" in h == !!S && (S ? h.localName === S : h.nodeType === 3)) {
        t = h, o[u] = null;
        break;
      }
  }
  if (t == null) {
    if (S === null)
      return document.createTextNode(m);
    t = document.createElementNS(s, S, m.is && m), o = null, i = !1;
  }
  if (S === null)
    f === m || i && t.data === m || (t.data = m);
  else {
    if (o = o && _o.call(t.childNodes), f = n.props || es, !i && o != null)
      for (f = {}, u = 0; u < t.attributes.length; u++)
        f[(h = t.attributes[u]).name] = h.value;
    for (u in f)
      if (h = f[u], u != "children") {
        if (u == "dangerouslySetInnerHTML")
          d = h;
        else if (u !== "key" && !(u in m)) {
          if (u == "value" && "defaultValue" in m || u == "checked" && "defaultChecked" in m)
            continue;
          Bs(t, u, null, h, s);
        }
      }
    for (u in m)
      h = m[u], u == "children" ? l = h : u == "dangerouslySetInnerHTML" ? p = h : u == "value" ? v = h : u == "checked" ? g = h : u === "key" || i && typeof h != "function" || f[u] === h || Bs(t, u, h, f[u], s);
    if (p)
      i || d && (p.__html === d.__html || p.__html === t.innerHTML) || (t.innerHTML = p.__html), e.__k = [];
    else if (d && (t.innerHTML = ""), _v(t, Ro(l) ? l : [l], e, n, r, S === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s, o, a, o ? o[0] : n.__k && gn(n, 0), i, c), o != null)
      for (u = o.length; u--; )
        o[u] != null && yv(o[u]);
    i || (u = "value", v !== void 0 && (v !== t[u] || S === "progress" && !v || S === "option" && v !== f[u]) && Bs(t, u, v, f[u], s), u = "checked", g !== void 0 && g !== t[u] && Bs(t, u, g, f[u], s));
  }
  return t;
}
function hu(t, e, n) {
  try {
    typeof t == "function" ? t(e) : t.current = e;
  } catch (r) {
    q.__e(r, n);
  }
}
function kc(t, e, n) {
  var r, s;
  if (q.unmount && q.unmount(t), (r = t.ref) && (r.current && r.current !== t.__e || hu(r, null, e)), (r = t.__c) != null) {
    if (r.componentWillUnmount)
      try {
        r.componentWillUnmount();
      } catch (o) {
        q.__e(o, e);
      }
    r.base = r.__P = null;
  }
  if (r = t.__k)
    for (s = 0; s < r.length; s++)
      r[s] && kc(r[s], e, n || typeof t.type != "function");
  n || t.__e == null || yv(t.__e), t.__c = t.__ = t.__e = t.__d = void 0;
}
function TS(t, e, n) {
  return this.constructor(t, n);
}
function uo(t, e, n) {
  var r, s, o, a;
  q.__ && q.__(t, e), s = (r = typeof n == "function") ? null : e.__k, o = [], a = [], lu(e, t = (!r && n || e).__k = ts(xt, null, [t]), s || es, es, e.namespaceURI, !r && n ? [n] : s ? null : e.firstChild ? _o.call(e.childNodes) : null, o, !r && n ? n : s ? s.__e : e.firstChild, r, a), Pv(o, t, a);
}
function vu(t, e) {
  var n = { __c: e = "__cC" + mv++, __: t, Consumer: function(r, s) {
    return r.children(s);
  }, Provider: function(r) {
    var s, o;
    return this.getChildContext || (s = [], (o = {})[e] = this, this.getChildContext = function() {
      return o;
    }, this.shouldComponentUpdate = function(a) {
      this.props.value !== a.value && s.some(function(i) {
        i.__e = !0, Oc(i);
      });
    }, this.sub = function(a) {
      s.push(a);
      var i = a.componentWillUnmount;
      a.componentWillUnmount = function() {
        s.splice(s.indexOf(a), 1), i && i.call(a);
      };
    }), r.children;
  } };
  return n.Provider.__ = n.Consumer.contextType = n;
}
_o = Sv.slice, q = { __e: function(t, e, n, r) {
  for (var s, o, a; e = e.__; )
    if ((s = e.__c) && !s.__)
      try {
        if ((o = s.constructor) && o.getDerivedStateFromError != null && (s.setState(o.getDerivedStateFromError(t)), a = s.__d), s.componentDidCatch != null && (s.componentDidCatch(t, r || {}), a = s.__d), a)
          return s.__E = s;
      } catch (i) {
        t = i;
      }
  throw t;
} }, fv = 0, Ct.prototype.setState = function(t, e) {
  var n;
  n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = kt({}, this.state), typeof t == "function" && (t = t(kt({}, n), this.props)), t && kt(n, t), t != null && this.__v && (e && this._sb.push(e), Oc(this));
}, Ct.prototype.forceUpdate = function(t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), Oc(this));
}, Ct.prototype.render = xt, un = [], gv = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, bc = function(t, e) {
  return t.__v.__b - e.__v.__b;
}, ao.__r = 0, du = 0, Ac = hp(!1), Mc = hp(!0), mv = 0;
const wS = "https://a4cf74d1408b08300392573972263164@o226878.ingest.us.sentry.io/4507283201064960", IS = "prod", bS = "https://api.d-id.com", AS = "wss://notifications.d-id.com", MS = "1.0.145", Dc = {
  mixpanelKey: "79f81a83a67430be2bc0fd61042b8faa"
};
function Ev() {
  return Math.random().toString(16).slice(2);
}
function OS() {
  const t = localStorage.getItem("tracking_id") ?? Ev();
  return localStorage.setItem("tracking_id", t), t;
}
const Tv = {
  token: Dc.mixpanelKey,
  $insert_id: Ev(),
  origin: window.location.href,
  "Screen Height": window.screen.height || window.innerWidth,
  "Screen Width": window.screen.width || window.innerHeight,
  "User Agent": navigator.userAgent
};
function vp(t) {
  Object.assign(Tv, t);
}
function zt(t, e) {
  if (window.localStorage.getItem("track_enabled") === "false")
    return;
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: new URLSearchParams({
      data: JSON.stringify([{
        event: t,
        properties: {
          ...e,
          time: Date.now(),
          distinct_id: OS(),
          ...Tv,
          agent_ui_version: MS
        }
      }])
    })
  };
  return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", n).then((r) => r.json()).catch((r) => console.error(r));
}
var Bt, ne, Za, fp, ns = 0, wv = [], Zs = [], pe = q, gp = pe.__b, mp = pe.__r, Sp = pe.diffed, yp = pe.__c, Cp = pe.unmount, _p = pe.__;
function Qn(t, e) {
  pe.__h && pe.__h(ne, t, ns || e), ns = 0;
  var n = ne.__H || (ne.__H = { __: [], __h: [] });
  return t >= n.__.length && n.__.push({ __V: Zs }), n.__[t];
}
function F(t) {
  return ns = 1, kS(Iv, t);
}
function kS(t, e, n) {
  var r = Qn(Bt++, 2);
  if (r.t = t, !r.__c && (r.__ = [n ? n(e) : Iv(void 0, e), function(i) {
    var c = r.__N ? r.__N[0] : r.__[0], u = r.t(c, i);
    c !== u && (r.__N = [u, r.__[1]], r.__c.setState({}));
  }], r.__c = ne, !ne.u)) {
    var s = function(i, c, u) {
      if (!r.__c.__H)
        return !0;
      var p = r.__c.__H.__.filter(function(l) {
        return !!l.__c;
      });
      if (p.every(function(l) {
        return !l.__N;
      }))
        return !o || o.call(this, i, c, u);
      var d = !1;
      return p.forEach(function(l) {
        if (l.__N) {
          var h = l.__[0];
          l.__ = l.__N, l.__N = void 0, h !== l.__[0] && (d = !0);
        }
      }), !(!d && r.__c.props === i) && (!o || o.call(this, i, c, u));
    };
    ne.u = !0;
    var o = ne.shouldComponentUpdate, a = ne.componentWillUpdate;
    ne.componentWillUpdate = function(i, c, u) {
      if (this.__e) {
        var p = o;
        o = void 0, s(i, c, u), o = p;
      }
      a && a.call(this, i, c, u);
    }, ne.shouldComponentUpdate = s;
  }
  return r.__N || r.__;
}
function oe(t, e) {
  var n = Qn(Bt++, 3);
  !pe.__s && gu(n.__H, e) && (n.__ = t, n.i = e, ne.__H.__h.push(n));
}
function DS(t, e) {
  var n = Qn(Bt++, 4);
  !pe.__s && gu(n.__H, e) && (n.__ = t, n.i = e, ne.__h.push(n));
}
function pt(t) {
  return ns = 5, fu(function() {
    return { current: t };
  }, []);
}
function fu(t, e) {
  var n = Qn(Bt++, 7);
  return gu(n.__H, e) ? (n.__V = t(), n.i = e, n.__h = t, n.__V) : n.__;
}
function mn(t, e) {
  return ns = 8, fu(function() {
    return t;
  }, e);
}
function Ue(t) {
  var e = ne.context[t.__c], n = Qn(Bt++, 9);
  return n.c = t, e ? (n.__ == null && (n.__ = !0, e.sub(ne)), e.props.value) : t.__;
}
function NS(t) {
  var e = Qn(Bt++, 10), n = F();
  return e.__ = t, ne.componentDidCatch || (ne.componentDidCatch = function(r, s) {
    e.__ && e.__(r, s), n[1](r);
  }), [n[0], function() {
    n[1](void 0);
  }];
}
function LS() {
  for (var t; t = wv.shift(); )
    if (t.__P && t.__H)
      try {
        t.__H.__h.forEach(Xs), t.__H.__h.forEach(Nc), t.__H.__h = [];
      } catch (e) {
        t.__H.__h = [], pe.__e(e, t.__v);
      }
}
pe.__b = function(t) {
  ne = null, gp && gp(t);
}, pe.__ = function(t, e) {
  t && e.__k && e.__k.__m && (t.__m = e.__k.__m), _p && _p(t, e);
}, pe.__r = function(t) {
  mp && mp(t), Bt = 0;
  var e = (ne = t.__c).__H;
  e && (Za === ne ? (e.__h = [], ne.__h = [], e.__.forEach(function(n) {
    n.__N && (n.__ = n.__N), n.__V = Zs, n.__N = n.i = void 0;
  })) : (e.__h.forEach(Xs), e.__h.forEach(Nc), e.__h = [], Bt = 0)), Za = ne;
}, pe.diffed = function(t) {
  Sp && Sp(t);
  var e = t.__c;
  e && e.__H && (e.__H.__h.length && (wv.push(e) !== 1 && fp === pe.requestAnimationFrame || ((fp = pe.requestAnimationFrame) || zS)(LS)), e.__H.__.forEach(function(n) {
    n.i && (n.__H = n.i), n.__V !== Zs && (n.__ = n.__V), n.i = void 0, n.__V = Zs;
  })), Za = ne = null;
}, pe.__c = function(t, e) {
  e.some(function(n) {
    try {
      n.__h.forEach(Xs), n.__h = n.__h.filter(function(r) {
        return !r.__ || Nc(r);
      });
    } catch (r) {
      e.some(function(s) {
        s.__h && (s.__h = []);
      }), e = [], pe.__e(r, n.__v);
    }
  }), yp && yp(t, e);
}, pe.unmount = function(t) {
  Cp && Cp(t);
  var e, n = t.__c;
  n && n.__H && (n.__H.__.forEach(function(r) {
    try {
      Xs(r);
    } catch (s) {
      e = s;
    }
  }), n.__H = void 0, e && pe.__e(e, n.__v));
};
var Rp = typeof requestAnimationFrame == "function";
function zS(t) {
  var e, n = function() {
    clearTimeout(r), Rp && cancelAnimationFrame(e), setTimeout(t);
  }, r = setTimeout(n, 100);
  Rp && (e = requestAnimationFrame(n));
}
function Xs(t) {
  var e = ne, n = t.__c;
  typeof n == "function" && (t.__c = void 0, n()), ne = e;
}
function Nc(t) {
  var e = ne;
  t.__c = t.__(), ne = e;
}
function gu(t, e) {
  return !t || t.length !== e.length || e.some(function(n, r) {
    return n !== t[r];
  });
}
function Iv(t, e) {
  return typeof e == "function" ? e(t) : e;
}
var jS = 0;
function w(t, e, n, r, s, o) {
  e || (e = {});
  var a, i, c = e;
  if ("ref" in c)
    for (i in c = {}, e)
      i == "ref" ? a = e[i] : c[i] = e[i];
  var u = { type: t, props: c, key: n, ref: a, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --jS, __i: -1, __u: 0, __source: s, __self: o };
  if (typeof t == "function" && (a = t.defaultProps))
    for (i in a)
      c[i] === void 0 && (c[i] = a[i]);
  return q.vnode && q.vnode(u), u;
}
const bv = {
  mode: "fabio",
  visible: !0,
  agentId: "",
  track: !0,
  chatMode: M.Functional,
  loaderConfig: {
    show: !0,
    style: "opaque",
    text: "Loading..."
  },
  orientation: "vertical",
  position: "right"
}, $t = vu({
  configure: () => {
  },
  configurations: bv
}), xS = ({
  children: t,
  initialConfigurations: e
}) => {
  const [n, r] = F({
    ...bv,
    ...e
  }), s = mn((o) => r((a) => ({
    ...a,
    ...o
  })), [r]);
  return oe(() => {
    window.DID_AGENTS_API.configure = s;
  }, [s]), oe(() => {
    window.DID_AGENTS_API.showLoader = (o, a) => {
      const i = {
        ...n.loaderConfig,
        show: !0
      };
      a && (i.style = a), o !== void 0 && (i.text = o), s({
        loaderConfig: i
      });
    }, window.DID_AGENTS_API.hideLoader = () => {
      s({
        loaderConfig: {
          ...n.loaderConfig,
          show: !1
        }
      });
    };
  }, [s, n.loaderConfig]), w($t.Provider, {
    value: {
      configurations: n,
      configure: s
    },
    children: t
  });
};
var de = /* @__PURE__ */ ((t) => (t[t.New = 0] = "New", t[t.Loading = 1] = "Loading", t[t.Buffering = 2] = "Buffering", t[t.Start = 3] = "Start", t[t.Fail = 4] = "Fail", t))(de || {});
const ps = vu({
  authenticate: () => {
  },
  auth: {},
  host: "",
  wsHost: "",
  isAuthenticated: !1
});
ps.displayName = "DidFetch";
function BS({
  children: t,
  auth: e,
  didApiUrl: n,
  didSocketApiUrl: r
}) {
  const [s, o] = F(e), a = async (i) => {
    o((c) => JSON.stringify(i) === JSON.stringify(c) ? c : i);
  };
  return w(ps.Provider, {
    value: {
      auth: s,
      host: n,
      wsHost: r,
      authenticate: a,
      isAuthenticated: !!s
    },
    children: t
  });
}
const Yn = vu({
  connectionState: G.New,
  streamState: de.New,
  connect: async () => {
  },
  reconnect: async () => {
  },
  disconnect: async () => {
  },
  setStreamState: () => {
  },
  streamedMessage: "",
  messages: [],
  error: "",
  chatId: void 0,
  setError: () => {
  },
  terminating: !1,
  enabled: !1
});
Yn.displayName = "Streaming Manager";
const qS = ["TooManyRequestsError", "InsufficientCreditsError"];
function FS({
  agentId: t,
  children: e,
  enabled: n,
  onAgentReady: r,
  onError: s
}) {
  const [o, a] = F(G.New), [i, c] = F(de.New), [u, p] = F(), [d, l] = F(""), [h, v] = F(), [g, f] = F(""), [m, S] = F(!1), [y, E] = F([]), [_, C] = F(void 0), {
    configurations: R,
    configure: T
  } = Ue($t), {
    auth: A,
    host: U,
    wsHost: K
  } = Ue(ps), Y = mn((re, N) => {
    s == null || s(re, N);
    try {
      const {
        kind: X
      } = JSON.parse(re.message);
      qS.includes(X) && T({
        chatMode: M.Maintenance
      });
    } catch {
    }
  }, [s, T]), J = mn(async () => {
    h && (S(!0), await h.disconnect().catch(), S(!1));
  }, [h]);
  async function he() {
    var re;
    if (f(""), h && ![M.TextOnly, M.Playground].includes(R.chatMode))
      return h;
    if (A && U && K) {
      let N;
      try {
        N = await CS(t, {
          mode: R.chatMode,
          auth: A,
          baseURL: U,
          wsURL: K,
          streamOptions: {
            streamWarmup: !0
          },
          callbacks: {
            onVideoStateChange(Z) {
              const ye = Z === fn.Start ? de.Start : de.New;
              c(ye);
            },
            onConnectionStateChange: (Z) => {
              a((ye) => Z === G.Disconnected ? ye === G.Connected ? Z : ye : Z);
            },
            onNewMessage: E,
            onSrcObjectReady: p,
            onModeChange: (Z) => T({
              chatMode: Z
            }),
            onNewChat: (Z) => {
              C(Z), vp({
                chat_id: Z
              });
            },
            onError: Y
          },
          initialMessages: R.chatMode === M.Playground ? [] : y,
          persistentChat: !0,
          enableAnalitics: R.track
        }), vp({
          agentId: N.agent.id,
          agentType: N.agent.presenter.type
        });
        const X = {
          ...N,
          chat: async (Z) => {
            var ye;
            if (window.dataLayer.push({
              event: "agent_interaction",
              message: Z
            }), !N)
              throw new Error("Manager is not initialized");
            return [M.TextOnly, M.Playground].includes(R.chatMode) ? (l(""), N.chat(Z).catch((Ie) => {
              throw (Ie == null ? void 0 : Ie.kind) === "InsufficientCreditsError" && (N == null || N.changeMode(M.TextOnly)), Ie;
            })) : (ye = N.agent.presenter) != null && ye.voice ? (l(""), await N.chat(Z).catch((Ie) => {
              throw (Ie == null ? void 0 : Ie.kind) === "InsufficientCreditsError" && (N == null || N.changeMode(M.TextOnly)), Ie;
            })) : Promise.reject(new Error("Agent has no voice, can not chat"));
          }
        };
        return (re = X.agent.presenter) != null && re.idle_video || (R.chatMode === M.Playground ? X.changeMode(R.chatMode) : X.changeMode(M.TextOnly)), v(X), r == null || r(X.agent), X;
      } catch (X) {
        console.error(X), X instanceof TypeError && c(de.Fail), N == null || N.changeMode(M.Maintenance), f("Agent is unavailable at the moment");
      }
    }
  }
  async function ve(re = !1) {
    l("");
    const N = await he();
    if (N && R.chatMode !== M.Playground)
      return R.chatMode === M.Maintenance && N.changeMode(M.Functional), re ? N.reconnect() : N.connect();
  }
  return oe(() => {
    const re = he();
    window.DID_AGENTS_API.updateAgent = () => {
      [M.TextOnly, M.Playground].includes(R.chatMode) && he();
    }, n && [M.Functional, M.Maintenance].includes(R.chatMode) && re.then(async (N) => {
      N && o !== G.Connected && await N.reconnect().catch((X) => {
        X.message.includes("Invalid access for non-embed agent") && f("The agent is temporarily unavailable. Please try again later");
      });
    });
  }, [A, U, K, n, R.chatMode]), oe(() => (window.addEventListener("beforeunload", () => {
    J();
  }), () => J()), [J]), w(Yn.Provider, {
    value: {
      streamedMessage: d,
      srcObject: u,
      streamState: i,
      connectionState: o,
      setStreamState: c,
      disconnect: J,
      connect: () => ve(!1),
      reconnect: () => ve(!0),
      error: g,
      setError: f,
      chatId: _,
      agentManager: h,
      messages: y,
      terminating: m,
      enabled: n
    },
    children: e
  });
}
const Av = "data:image/svg+xml,%3csvg%20version='1.1'%20id='L9'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20100%20100'%20enable-background='new%200%200%200%200'%20xml:space='preserve'%3e%3cpath%20fill='%23fff'%20d='M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50%20M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50'%3e%3canimateTransform%20attributeName='transform'%20attributeType='XML'%20type='rotate'%20dur='1s'%20from='0%2050%2050'%20to='360%2050%2050'%20repeatCount='indefinite'%20/%3e%3c/path%3e%3c/svg%3e", Lc = [G.Fail, G.Disconnected, G.Completed], $S = "#e6e6e6";
function US(t) {
  const e = t.style.height;
  t.style.height = "0";
  const n = t.scrollHeight / parseInt(getComputedStyle(t).lineHeight);
  return t.style.height = e, parseInt(n + "");
}
function HS() {
  try {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
  } catch (t) {
    console.error("Error occurred while detecting iOS:", t);
  }
  return !1;
}
function WS() {
  const t = navigator.userAgent.match(/OS (\d+)_\d+(_\d+)? like Mac OS X/i);
  return t ? parseInt(t[1], 10) : void 0;
}
const VS = (t, e) => new Promise((n) => {
  const r = document.createElement("canvas"), s = r.getContext("2d");
  if (!r || !s) {
    console.error("Failed adding background to presenter poster - could not create canvas or context"), n(t);
    return;
  }
  const o = new Image();
  o.src = t, o.onload = () => {
    r.width = o.width, r.height = o.height, s.fillStyle = e, s.fillRect(0, 0, r.width, r.height), s.drawImage(o, 0, 0), n(r.toDataURL());
  }, o.onerror = () => {
    console.error("Failed adding background to presenter poster - could not load image"), n(t);
  };
}), Mv = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20height='800px'%20width='800px'%20version='1.1'%20id='Capa_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20viewBox='0%200%20199.943%20199.943'%20xml:space='preserve'%3e%3cg%3e%3cg%3e%3cpath%20style='fill:%23010002;'%20d='M99.972,0.004C44.85,0.004,0,44.847,0,99.968c0,55.125,44.847,99.972,99.972,99.972%20s99.972-44.847,99.972-99.972C199.943,44.847,155.093,0.004,99.972,0.004z%20M99.972,190.957c-50.168,0-90.996-40.813-90.996-90.989%20c0-50.172,40.828-90.992,90.996-90.992c50.175,0,91.003,40.817,91.003,90.992S150.147,190.957,99.972,190.957z'/%3e%3cpath%20style='fill:%23010002;'%20d='M99.324,67.354c-3.708,0-6.725,3.01-6.725,6.728v75.979c0,3.722,3.017,6.739,6.725,6.739%20c3.722,0,6.739-3.017,6.739-6.739V74.082C106.063,70.364,103.042,67.354,99.324,67.354z'/%3e%3ccircle%20style='fill:%23010002;'%20cx='99.746'%20cy='48.697'%20r='8.178'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
function Ye({
  src: t,
  size: e,
  color: n = "currentcolor",
  padding: r = "0",
  rotated: s,
  margin: o = "0",
  width: a,
  className: i = ""
}) {
  return w("svg", {
    className: "didagent__maskedicon " + i,
    style: {
      "--mask-url": `url("${t}")`,
      "--color": n,
      "--width": a,
      "--size": e,
      "--padding": r,
      "--margin": o,
      "--rotation": s ? "180deg" : "0deg"
    }
  });
}
const KS = ({
  text: t,
  hide: e
}) => e ? null : w("div", {
  className: "didagent__info_message_agent_unavailable_container",
  children: w("div", {
    className: "didagent__info_message_agent_unavailable_danger",
    children: [w(Ye, {
      src: Mv,
      size: "20px"
    }), w("div", {
      children: t
    })]
  })
});
function JS({
  content: t,
  display: e
}) {
  const [n, r] = F(!1), [s, o] = F("");
  return oe(() => {
    if (!e)
      r(!1);
    else {
      r(!0), o("fade-in");
      const a = setTimeout(() => {
        o("fade-out");
        const i = setTimeout(() => r(!1), 500);
        return () => clearTimeout(i);
      }, 3e3);
      return () => clearTimeout(a);
    }
  }, [e]), n ? w("div", {
    className: `didagent__info_message_indication ${s}`,
    children: [w(Ye, {
      src: Mv,
      size: "16px"
    }), w("pre", {
      className: "didagent__info_message_agent_unavailable_message",
      children: t
    })]
  }) : null;
}
function GS({
  content: t,
  hide: e
}) {
  return e || !t ? null : w("div", {
    className: "didagent__banner",
    children: t
  });
}
const QS = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M10.4453%2011.5556C10.4453%208.48731%2012.9326%206%2016.0009%206C19.0691%206%2021.5564%208.48731%2021.5564%2011.5556V14.8889C21.5564%2017.9571%2019.0691%2020.4444%2016.0009%2020.4444C12.9326%2020.4444%2010.4453%2017.9571%2010.4453%2014.8889V11.5556Z'%20fill='white'%20stroke='white'%20stroke-width='1.66667'/%3e%3cpath%20d='M24.8911%2013.7812V14.8924C24.8911%2019.8016%2020.9114%2023.7813%2016.0022%2023.7813C11.093%2023.7813%207.11328%2019.8016%207.11328%2014.8924V13.7812'%20stroke='white'%20stroke-width='1.66667'%20stroke-linecap='round'/%3e%3cpath%20d='M16%2023.7812V27.1146'%20stroke='white'%20stroke-width='1.66667'%20stroke-linecap='round'/%3e%3c/svg%3e", YS = "data:image/svg+xml,%3csvg%20width='23'%20height='24'%20viewBox='0%200%2023%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.68322%2018.9259L14.3358%2016.4985C18.4002%2014.3779%2020.4324%2013.3176%2020.4324%2011.6386C20.4324%209.95953%2018.4002%208.89925%2014.3358%206.77869L9.68324%204.35127C6.40287%202.63977%204.76268%201.78403%203.81181%202.0467C2.90723%202.29659%202.20074%203.0338%201.96126%203.97771C1.70953%204.96992%202.52962%206.68142%204.1698%2010.1044C4.37307%2010.5286%204.78866%2010.8108%205.24318%2010.813L12.6703%2010.8491C13.0882%2010.8511%2013.4253%2011.2062%2013.4234%2011.6423C13.4214%2012.0783%2013.0811%2012.4301%2012.6633%2012.428L5.35607%2012.3926C4.8551%2012.3901%204.39385%2012.7052%204.1698%2013.1728C2.52963%2016.5957%201.70953%2018.3072%201.96126%2019.2994C2.20074%2020.2434%202.90723%2020.9806%203.81181%2021.2305C4.76268%2021.4931%206.40287%2020.6374%209.68322%2018.9259Z'%20fill='white'/%3e%3c/svg%3e", ZS = "data:image/svg+xml,%3csvg%20id='wave'%20data-name='Layer%201'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2050%2038.05'%3e%3cstyle%3e%20%23Line_1%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.15s;%20}%20%23Line_2%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.3s;%20}%20%23Line_3%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.45s;%20}%20%23Line_4%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.6s;%20}%20%23Line_5%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.75s;%20}%20%23Line_6%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.9s;%20}%20%23Line_7%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.05s;%20}%20%23Line_8%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.2s;%20}%20%23Line_9%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.35s;%20}%20@keyframes%20pulse%20{%200%25%20{%20transform:%20scaleY(1);%20transform-origin:%2050%25%2050%25;%20}%2050%25%20{%20transform:%20scaleY(0.7);%20transform-origin:%2050%25%2050%25;%20}%20100%25%20{%20transform:%20scaleY(1);%20transform-origin:%2050%25%2050%25;%20}%20}%20%3c/style%3e%3cpath%20id='Line_1'%20data-name='Line%201'%20d='M0.91,15L0.78,15A1,1,0,0,0,0,16v6a1,1,0,1,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H0.91Z'%20/%3e%3cpath%20id='Line_2'%20data-name='Line%202'%20d='M6.91,9L6.78,9A1,1,0,0,0,6,10V28a1,1,0,1,0,2,0s0,0,0,0V10A1,1,0,0,0,7,9H6.91Z'%20/%3e%3cpath%20id='Line_3'%20data-name='Line%203'%20d='M12.91,0L12.78,0A1,1,0,0,0,12,1V37a1,1,0,1,0,2,0s0,0,0,0V1a1,1,0,0,0-1-1H12.91Z'%20/%3e%3cpath%20id='Line_4'%20data-name='Line%204'%20d='M18.91,10l-0.12,0A1,1,0,0,0,18,11V27a1,1,0,1,0,2,0s0,0,0,0V11a1,1,0,0,0-1-1H18.91Z'%20/%3e%3cpath%20id='Line_5'%20data-name='Line%205'%20d='M24.91,15l-0.12,0A1,1,0,0,0,24,16v6a1,1,0,0,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H24.91Z'%20/%3e%3cpath%20id='Line_6'%20data-name='Line%206'%20d='M30.91,10l-0.12,0A1,1,0,0,0,30,11V27a1,1,0,1,0,2,0s0,0,0,0V11a1,1,0,0,0-1-1H30.91Z'%20/%3e%3cpath%20id='Line_7'%20data-name='Line%207'%20d='M36.91,0L36.78,0A1,1,0,0,0,36,1V37a1,1,0,1,0,2,0s0,0,0,0V1a1,1,0,0,0-1-1H36.91Z'%20/%3e%3cpath%20id='Line_8'%20data-name='Line%208'%20d='M42.91,9L42.78,9A1,1,0,0,0,42,10V28a1,1,0,1,0,2,0s0,0,0,0V10a1,1,0,0,0-1-1H42.91Z'%20/%3e%3cpath%20id='Line_9'%20data-name='Line%209'%20d='M48.91,15l-0.12,0A1,1,0,0,0,48,16v6a1,1,0,1,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H48.91Z'%20/%3e%3c/svg%3e", Ov = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M16.9399%206.96684L6.87207%2017.0347M6.87203%206.9668L16.9399%2017.0346'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'/%3e%3c/svg%3e";
var $ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function XS(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var Ln = {}, Xa = {}, Po = {}, ec = {}, ue = {}, Zn = {}, Ze = {}, kv = {}, Eo = {}, To = {};
Object.defineProperty(To, "__esModule", {
  value: !0
});
To.default = ty;
let qs;
const ey = new Uint8Array(16);
function ty() {
  if (!qs && (qs = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !qs))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return qs(ey);
}
var Ut = {}, Pn = {}, wo = {};
Object.defineProperty(wo, "__esModule", {
  value: !0
});
wo.default = void 0;
var ny = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
wo.default = ny;
Object.defineProperty(Pn, "__esModule", {
  value: !0
});
Pn.default = void 0;
var ry = iy(wo);
function iy(t) {
  return t && t.__esModule ? t : { default: t };
}
function sy(t) {
  return typeof t == "string" && ry.default.test(t);
}
var oy = sy;
Pn.default = oy;
Object.defineProperty(Ut, "__esModule", {
  value: !0
});
Ut.default = void 0;
Ut.unsafeStringify = Dv;
var ay = cy(Pn);
function cy(t) {
  return t && t.__esModule ? t : { default: t };
}
const _e = [];
for (let t = 0; t < 256; ++t)
  _e.push((t + 256).toString(16).slice(1));
function Dv(t, e = 0) {
  return _e[t[e + 0]] + _e[t[e + 1]] + _e[t[e + 2]] + _e[t[e + 3]] + "-" + _e[t[e + 4]] + _e[t[e + 5]] + "-" + _e[t[e + 6]] + _e[t[e + 7]] + "-" + _e[t[e + 8]] + _e[t[e + 9]] + "-" + _e[t[e + 10]] + _e[t[e + 11]] + _e[t[e + 12]] + _e[t[e + 13]] + _e[t[e + 14]] + _e[t[e + 15]];
}
function uy(t, e = 0) {
  const n = Dv(t, e);
  if (!(0, ay.default)(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
var py = uy;
Ut.default = py;
Object.defineProperty(Eo, "__esModule", {
  value: !0
});
Eo.default = void 0;
var dy = hy(To), ly = Ut;
function hy(t) {
  return t && t.__esModule ? t : { default: t };
}
let Pp, tc, nc = 0, rc = 0;
function vy(t, e, n) {
  let r = e && n || 0;
  const s = e || new Array(16);
  t = t || {};
  let o = t.node || Pp, a = t.clockseq !== void 0 ? t.clockseq : tc;
  if (o == null || a == null) {
    const l = t.random || (t.rng || dy.default)();
    o == null && (o = Pp = [l[0] | 1, l[1], l[2], l[3], l[4], l[5]]), a == null && (a = tc = (l[6] << 8 | l[7]) & 16383);
  }
  let i = t.msecs !== void 0 ? t.msecs : Date.now(), c = t.nsecs !== void 0 ? t.nsecs : rc + 1;
  const u = i - nc + (c - rc) / 1e4;
  if (u < 0 && t.clockseq === void 0 && (a = a + 1 & 16383), (u < 0 || i > nc) && t.nsecs === void 0 && (c = 0), c >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  nc = i, rc = c, tc = a, i += 122192928e5;
  const p = ((i & 268435455) * 1e4 + c) % 4294967296;
  s[r++] = p >>> 24 & 255, s[r++] = p >>> 16 & 255, s[r++] = p >>> 8 & 255, s[r++] = p & 255;
  const d = i / 4294967296 * 1e4 & 268435455;
  s[r++] = d >>> 8 & 255, s[r++] = d & 255, s[r++] = d >>> 24 & 15 | 16, s[r++] = d >>> 16 & 255, s[r++] = a >>> 8 | 128, s[r++] = a & 255;
  for (let l = 0; l < 6; ++l)
    s[r + l] = o[l];
  return e || (0, ly.unsafeStringify)(s);
}
var fy = vy;
Eo.default = fy;
var Io = {}, qt = {}, ds = {};
Object.defineProperty(ds, "__esModule", {
  value: !0
});
ds.default = void 0;
var gy = my(Pn);
function my(t) {
  return t && t.__esModule ? t : { default: t };
}
function Sy(t) {
  if (!(0, gy.default)(t))
    throw TypeError("Invalid UUID");
  let e;
  const n = new Uint8Array(16);
  return n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, n[1] = e >>> 16 & 255, n[2] = e >>> 8 & 255, n[3] = e & 255, n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, n[5] = e & 255, n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, n[7] = e & 255, n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, n[9] = e & 255, n[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = e / 4294967296 & 255, n[12] = e >>> 24 & 255, n[13] = e >>> 16 & 255, n[14] = e >>> 8 & 255, n[15] = e & 255, n;
}
var yy = Sy;
ds.default = yy;
Object.defineProperty(qt, "__esModule", {
  value: !0
});
qt.URL = qt.DNS = void 0;
qt.default = Ey;
var Cy = Ut, _y = Ry(ds);
function Ry(t) {
  return t && t.__esModule ? t : { default: t };
}
function Py(t) {
  t = unescape(encodeURIComponent(t));
  const e = [];
  for (let n = 0; n < t.length; ++n)
    e.push(t.charCodeAt(n));
  return e;
}
const Nv = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
qt.DNS = Nv;
const Lv = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
qt.URL = Lv;
function Ey(t, e, n) {
  function r(s, o, a, i) {
    var c;
    if (typeof s == "string" && (s = Py(s)), typeof o == "string" && (o = (0, _y.default)(o)), ((c = o) === null || c === void 0 ? void 0 : c.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let u = new Uint8Array(16 + s.length);
    if (u.set(o), u.set(s, o.length), u = n(u), u[6] = u[6] & 15 | e, u[8] = u[8] & 63 | 128, a) {
      i = i || 0;
      for (let p = 0; p < 16; ++p)
        a[i + p] = u[p];
      return a;
    }
    return (0, Cy.unsafeStringify)(u);
  }
  try {
    r.name = t;
  } catch {
  }
  return r.DNS = Nv, r.URL = Lv, r;
}
var bo = {};
Object.defineProperty(bo, "__esModule", {
  value: !0
});
bo.default = void 0;
function Ty(t) {
  if (typeof t == "string") {
    const e = unescape(encodeURIComponent(t));
    t = new Uint8Array(e.length);
    for (let n = 0; n < e.length; ++n)
      t[n] = e.charCodeAt(n);
  }
  return wy(Iy(by(t), t.length * 8));
}
function wy(t) {
  const e = [], n = t.length * 32, r = "0123456789abcdef";
  for (let s = 0; s < n; s += 8) {
    const o = t[s >> 5] >>> s % 32 & 255, a = parseInt(r.charAt(o >>> 4 & 15) + r.charAt(o & 15), 16);
    e.push(a);
  }
  return e;
}
function zv(t) {
  return (t + 64 >>> 9 << 4) + 14 + 1;
}
function Iy(t, e) {
  t[e >> 5] |= 128 << e % 32, t[zv(e) - 1] = e;
  let n = 1732584193, r = -271733879, s = -1732584194, o = 271733878;
  for (let a = 0; a < t.length; a += 16) {
    const i = n, c = r, u = s, p = o;
    n = be(n, r, s, o, t[a], 7, -680876936), o = be(o, n, r, s, t[a + 1], 12, -389564586), s = be(s, o, n, r, t[a + 2], 17, 606105819), r = be(r, s, o, n, t[a + 3], 22, -1044525330), n = be(n, r, s, o, t[a + 4], 7, -176418897), o = be(o, n, r, s, t[a + 5], 12, 1200080426), s = be(s, o, n, r, t[a + 6], 17, -1473231341), r = be(r, s, o, n, t[a + 7], 22, -45705983), n = be(n, r, s, o, t[a + 8], 7, 1770035416), o = be(o, n, r, s, t[a + 9], 12, -1958414417), s = be(s, o, n, r, t[a + 10], 17, -42063), r = be(r, s, o, n, t[a + 11], 22, -1990404162), n = be(n, r, s, o, t[a + 12], 7, 1804603682), o = be(o, n, r, s, t[a + 13], 12, -40341101), s = be(s, o, n, r, t[a + 14], 17, -1502002290), r = be(r, s, o, n, t[a + 15], 22, 1236535329), n = Ae(n, r, s, o, t[a + 1], 5, -165796510), o = Ae(o, n, r, s, t[a + 6], 9, -1069501632), s = Ae(s, o, n, r, t[a + 11], 14, 643717713), r = Ae(r, s, o, n, t[a], 20, -373897302), n = Ae(n, r, s, o, t[a + 5], 5, -701558691), o = Ae(o, n, r, s, t[a + 10], 9, 38016083), s = Ae(s, o, n, r, t[a + 15], 14, -660478335), r = Ae(r, s, o, n, t[a + 4], 20, -405537848), n = Ae(n, r, s, o, t[a + 9], 5, 568446438), o = Ae(o, n, r, s, t[a + 14], 9, -1019803690), s = Ae(s, o, n, r, t[a + 3], 14, -187363961), r = Ae(r, s, o, n, t[a + 8], 20, 1163531501), n = Ae(n, r, s, o, t[a + 13], 5, -1444681467), o = Ae(o, n, r, s, t[a + 2], 9, -51403784), s = Ae(s, o, n, r, t[a + 7], 14, 1735328473), r = Ae(r, s, o, n, t[a + 12], 20, -1926607734), n = Me(n, r, s, o, t[a + 5], 4, -378558), o = Me(o, n, r, s, t[a + 8], 11, -2022574463), s = Me(s, o, n, r, t[a + 11], 16, 1839030562), r = Me(r, s, o, n, t[a + 14], 23, -35309556), n = Me(n, r, s, o, t[a + 1], 4, -1530992060), o = Me(o, n, r, s, t[a + 4], 11, 1272893353), s = Me(s, o, n, r, t[a + 7], 16, -155497632), r = Me(r, s, o, n, t[a + 10], 23, -1094730640), n = Me(n, r, s, o, t[a + 13], 4, 681279174), o = Me(o, n, r, s, t[a], 11, -358537222), s = Me(s, o, n, r, t[a + 3], 16, -722521979), r = Me(r, s, o, n, t[a + 6], 23, 76029189), n = Me(n, r, s, o, t[a + 9], 4, -640364487), o = Me(o, n, r, s, t[a + 12], 11, -421815835), s = Me(s, o, n, r, t[a + 15], 16, 530742520), r = Me(r, s, o, n, t[a + 2], 23, -995338651), n = Oe(n, r, s, o, t[a], 6, -198630844), o = Oe(o, n, r, s, t[a + 7], 10, 1126891415), s = Oe(s, o, n, r, t[a + 14], 15, -1416354905), r = Oe(r, s, o, n, t[a + 5], 21, -57434055), n = Oe(n, r, s, o, t[a + 12], 6, 1700485571), o = Oe(o, n, r, s, t[a + 3], 10, -1894986606), s = Oe(s, o, n, r, t[a + 10], 15, -1051523), r = Oe(r, s, o, n, t[a + 1], 21, -2054922799), n = Oe(n, r, s, o, t[a + 8], 6, 1873313359), o = Oe(o, n, r, s, t[a + 15], 10, -30611744), s = Oe(s, o, n, r, t[a + 6], 15, -1560198380), r = Oe(r, s, o, n, t[a + 13], 21, 1309151649), n = Oe(n, r, s, o, t[a + 4], 6, -145523070), o = Oe(o, n, r, s, t[a + 11], 10, -1120210379), s = Oe(s, o, n, r, t[a + 2], 15, 718787259), r = Oe(r, s, o, n, t[a + 9], 21, -343485551), n = Dt(n, i), r = Dt(r, c), s = Dt(s, u), o = Dt(o, p);
  }
  return [n, r, s, o];
}
function by(t) {
  if (t.length === 0)
    return [];
  const e = t.length * 8, n = new Uint32Array(zv(e));
  for (let r = 0; r < e; r += 8)
    n[r >> 5] |= (t[r / 8] & 255) << r % 32;
  return n;
}
function Dt(t, e) {
  const n = (t & 65535) + (e & 65535);
  return (t >> 16) + (e >> 16) + (n >> 16) << 16 | n & 65535;
}
function Ay(t, e) {
  return t << e | t >>> 32 - e;
}
function Ao(t, e, n, r, s, o) {
  return Dt(Ay(Dt(Dt(e, t), Dt(r, o)), s), n);
}
function be(t, e, n, r, s, o, a) {
  return Ao(e & n | ~e & r, t, e, s, o, a);
}
function Ae(t, e, n, r, s, o, a) {
  return Ao(e & r | n & ~r, t, e, s, o, a);
}
function Me(t, e, n, r, s, o, a) {
  return Ao(e ^ n ^ r, t, e, s, o, a);
}
function Oe(t, e, n, r, s, o, a) {
  return Ao(n ^ (e | ~r), t, e, s, o, a);
}
var My = Ty;
bo.default = My;
Object.defineProperty(Io, "__esModule", {
  value: !0
});
Io.default = void 0;
var Oy = jv(qt), ky = jv(bo);
function jv(t) {
  return t && t.__esModule ? t : { default: t };
}
const Dy = (0, Oy.default)("v3", 48, ky.default);
var Ny = Dy;
Io.default = Ny;
var Mo = {}, Oo = {};
Object.defineProperty(Oo, "__esModule", {
  value: !0
});
Oo.default = void 0;
const Ly = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var zy = {
  randomUUID: Ly
};
Oo.default = zy;
Object.defineProperty(Mo, "__esModule", {
  value: !0
});
Mo.default = void 0;
var Ep = xv(Oo), jy = xv(To), xy = Ut;
function xv(t) {
  return t && t.__esModule ? t : { default: t };
}
function By(t, e, n) {
  if (Ep.default.randomUUID && !e && !t)
    return Ep.default.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || jy.default)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
    n = n || 0;
    for (let s = 0; s < 16; ++s)
      e[n + s] = r[s];
    return e;
  }
  return (0, xy.unsafeStringify)(r);
}
var qy = By;
Mo.default = qy;
var ko = {}, Do = {};
Object.defineProperty(Do, "__esModule", {
  value: !0
});
Do.default = void 0;
function Fy(t, e, n, r) {
  switch (t) {
    case 0:
      return e & n ^ ~e & r;
    case 1:
      return e ^ n ^ r;
    case 2:
      return e & n ^ e & r ^ n & r;
    case 3:
      return e ^ n ^ r;
  }
}
function ic(t, e) {
  return t << e | t >>> 32 - e;
}
function $y(t) {
  const e = [1518500249, 1859775393, 2400959708, 3395469782], n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof t == "string") {
    const a = unescape(encodeURIComponent(t));
    t = [];
    for (let i = 0; i < a.length; ++i)
      t.push(a.charCodeAt(i));
  } else
    Array.isArray(t) || (t = Array.prototype.slice.call(t));
  t.push(128);
  const r = t.length / 4 + 2, s = Math.ceil(r / 16), o = new Array(s);
  for (let a = 0; a < s; ++a) {
    const i = new Uint32Array(16);
    for (let c = 0; c < 16; ++c)
      i[c] = t[a * 64 + c * 4] << 24 | t[a * 64 + c * 4 + 1] << 16 | t[a * 64 + c * 4 + 2] << 8 | t[a * 64 + c * 4 + 3];
    o[a] = i;
  }
  o[s - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), o[s - 1][14] = Math.floor(o[s - 1][14]), o[s - 1][15] = (t.length - 1) * 8 & 4294967295;
  for (let a = 0; a < s; ++a) {
    const i = new Uint32Array(80);
    for (let h = 0; h < 16; ++h)
      i[h] = o[a][h];
    for (let h = 16; h < 80; ++h)
      i[h] = ic(i[h - 3] ^ i[h - 8] ^ i[h - 14] ^ i[h - 16], 1);
    let c = n[0], u = n[1], p = n[2], d = n[3], l = n[4];
    for (let h = 0; h < 80; ++h) {
      const v = Math.floor(h / 20), g = ic(c, 5) + Fy(v, u, p, d) + l + e[v] + i[h] >>> 0;
      l = d, d = p, p = ic(u, 30) >>> 0, u = c, c = g;
    }
    n[0] = n[0] + c >>> 0, n[1] = n[1] + u >>> 0, n[2] = n[2] + p >>> 0, n[3] = n[3] + d >>> 0, n[4] = n[4] + l >>> 0;
  }
  return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255];
}
var Uy = $y;
Do.default = Uy;
Object.defineProperty(ko, "__esModule", {
  value: !0
});
ko.default = void 0;
var Hy = Bv(qt), Wy = Bv(Do);
function Bv(t) {
  return t && t.__esModule ? t : { default: t };
}
const Vy = (0, Hy.default)("v5", 80, Wy.default);
var Ky = Vy;
ko.default = Ky;
var No = {};
Object.defineProperty(No, "__esModule", {
  value: !0
});
No.default = void 0;
var Jy = "00000000-0000-0000-0000-000000000000";
No.default = Jy;
var Lo = {};
Object.defineProperty(Lo, "__esModule", {
  value: !0
});
Lo.default = void 0;
var Gy = Qy(Pn);
function Qy(t) {
  return t && t.__esModule ? t : { default: t };
}
function Yy(t) {
  if (!(0, Gy.default)(t))
    throw TypeError("Invalid UUID");
  return parseInt(t.slice(14, 15), 16);
}
var Zy = Yy;
Lo.default = Zy;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "NIL", {
    enumerable: !0,
    get: function() {
      return o.default;
    }
  }), Object.defineProperty(t, "parse", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), Object.defineProperty(t, "stringify", {
    enumerable: !0,
    get: function() {
      return c.default;
    }
  }), Object.defineProperty(t, "v1", {
    enumerable: !0,
    get: function() {
      return e.default;
    }
  }), Object.defineProperty(t, "v3", {
    enumerable: !0,
    get: function() {
      return n.default;
    }
  }), Object.defineProperty(t, "v4", {
    enumerable: !0,
    get: function() {
      return r.default;
    }
  }), Object.defineProperty(t, "v5", {
    enumerable: !0,
    get: function() {
      return s.default;
    }
  }), Object.defineProperty(t, "validate", {
    enumerable: !0,
    get: function() {
      return i.default;
    }
  }), Object.defineProperty(t, "version", {
    enumerable: !0,
    get: function() {
      return a.default;
    }
  });
  var e = p(Eo), n = p(Io), r = p(Mo), s = p(ko), o = p(No), a = p(Lo), i = p(Pn), c = p(Ut), u = p(ds);
  function p(d) {
    return d && d.__esModule ? d : { default: d };
  }
})(kv);
Object.defineProperty(Ze, "__esModule", { value: !0 });
Ze.createNoDashGuid = Ze.createGuid = void 0;
const Xy = kv, qv = () => Xy.v4();
Ze.createGuid = qv;
const eC = () => qv().replace(new RegExp("-", "g"), "").toUpperCase();
Ze.createNoDashGuid = eC;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PlatformEvent = t.EventType = void 0;
  const e = Ze;
  (function(r) {
    r[r.Debug = 0] = "Debug", r[r.Info = 1] = "Info", r[r.Warning = 2] = "Warning", r[r.Error = 3] = "Error", r[r.None = 4] = "None";
  })(t.EventType || (t.EventType = {}));
  class n {
    constructor(s, o) {
      this.privName = s, this.privEventId = e.createNoDashGuid(), this.privEventTime = (/* @__PURE__ */ new Date()).toISOString(), this.privEventType = o, this.privMetadata = {};
    }
    get name() {
      return this.privName;
    }
    get eventId() {
      return this.privEventId;
    }
    get eventTime() {
      return this.privEventTime;
    }
    get eventType() {
      return this.privEventType;
    }
    get metadata() {
      return this.privMetadata;
    }
  }
  t.PlatformEvent = n;
})(Zn);
Object.defineProperty(ue, "__esModule", { value: !0 });
ue.AudioStreamNodeErrorEvent = ue.AudioStreamNodeDetachedEvent = ue.AudioStreamNodeAttachedEvent = ue.AudioStreamNodeAttachingEvent = ue.AudioStreamNodeEvent = ue.AudioSourceErrorEvent = ue.AudioSourceOffEvent = ue.AudioSourceReadyEvent = ue.AudioSourceInitializingEvent = ue.AudioSourceEvent = void 0;
const zc = Zn;
class Xn extends zc.PlatformEvent {
  constructor(e, n, r = zc.EventType.Info) {
    super(e, r), this.privAudioSourceId = n;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
}
ue.AudioSourceEvent = Xn;
class tC extends Xn {
  constructor(e) {
    super("AudioSourceInitializingEvent", e);
  }
}
ue.AudioSourceInitializingEvent = tC;
class nC extends Xn {
  constructor(e) {
    super("AudioSourceReadyEvent", e);
  }
}
ue.AudioSourceReadyEvent = nC;
class rC extends Xn {
  constructor(e) {
    super("AudioSourceOffEvent", e);
  }
}
ue.AudioSourceOffEvent = rC;
class iC extends Xn {
  constructor(e, n) {
    super("AudioSourceErrorEvent", e, zc.EventType.Error), this.privError = n;
  }
  get error() {
    return this.privError;
  }
}
ue.AudioSourceErrorEvent = iC;
class ls extends Xn {
  constructor(e, n, r) {
    super(e, n), this.privAudioNodeId = r;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
}
ue.AudioStreamNodeEvent = ls;
class sC extends ls {
  constructor(e, n) {
    super("AudioStreamNodeAttachingEvent", e, n);
  }
}
ue.AudioStreamNodeAttachingEvent = sC;
class oC extends ls {
  constructor(e, n) {
    super("AudioStreamNodeAttachedEvent", e, n);
  }
}
ue.AudioStreamNodeAttachedEvent = oC;
class aC extends ls {
  constructor(e, n) {
    super("AudioStreamNodeDetachedEvent", e, n);
  }
}
ue.AudioStreamNodeDetachedEvent = aC;
class cC extends ls {
  constructor(e, n, r) {
    super("AudioStreamNodeErrorEvent", e, n), this.privError = r;
  }
  get error() {
    return this.privError;
  }
}
ue.AudioStreamNodeErrorEvent = cC;
var le = {};
Object.defineProperty(le, "__esModule", { value: !0 });
le.ConnectionMessageSentEvent = le.ConnectionMessageReceivedEvent = le.ConnectionEstablishErrorEvent = le.ConnectionErrorEvent = le.ConnectionClosedEvent = le.ConnectionEstablishedEvent = le.ConnectionStartEvent = le.ConnectionEvent = le.ServiceEvent = void 0;
const Sn = Zn;
class uC extends Sn.PlatformEvent {
  constructor(e, n, r = Sn.EventType.Info) {
    super(e, r), this.privJsonResult = n;
  }
  get jsonString() {
    return this.privJsonResult;
  }
}
le.ServiceEvent = uC;
class Ht extends Sn.PlatformEvent {
  constructor(e, n, r = Sn.EventType.Info) {
    super(e, r), this.privConnectionId = n;
  }
  get connectionId() {
    return this.privConnectionId;
  }
}
le.ConnectionEvent = Ht;
class pC extends Ht {
  constructor(e, n, r) {
    super("ConnectionStartEvent", e), this.privUri = n, this.privHeaders = r;
  }
  get uri() {
    return this.privUri;
  }
  get headers() {
    return this.privHeaders;
  }
}
le.ConnectionStartEvent = pC;
class dC extends Ht {
  constructor(e) {
    super("ConnectionEstablishedEvent", e);
  }
}
le.ConnectionEstablishedEvent = dC;
class lC extends Ht {
  constructor(e, n, r) {
    super("ConnectionClosedEvent", e, Sn.EventType.Debug), this.privReason = r, this.privStatusCode = n;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
le.ConnectionClosedEvent = lC;
class hC extends Ht {
  constructor(e, n, r) {
    super("ConnectionErrorEvent", e, Sn.EventType.Debug), this.privMessage = n, this.privType = r;
  }
  get message() {
    return this.privMessage;
  }
  get type() {
    return this.privType;
  }
}
le.ConnectionErrorEvent = hC;
class vC extends Ht {
  constructor(e, n, r) {
    super("ConnectionEstablishErrorEvent", e, Sn.EventType.Error), this.privStatusCode = n, this.privReason = r;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
le.ConnectionEstablishErrorEvent = vC;
class fC extends Ht {
  constructor(e, n, r) {
    super("ConnectionMessageReceivedEvent", e), this.privNetworkReceivedTime = n, this.privMessage = r;
  }
  get networkReceivedTime() {
    return this.privNetworkReceivedTime;
  }
  get message() {
    return this.privMessage;
  }
}
le.ConnectionMessageReceivedEvent = fC;
class gC extends Ht {
  constructor(e, n, r) {
    super("ConnectionMessageSentEvent", e), this.privNetworkSentTime = n, this.privMessage = r;
  }
  get networkSentTime() {
    return this.privNetworkSentTime;
  }
  get message() {
    return this.privMessage;
  }
}
le.ConnectionMessageSentEvent = gC;
var mu = {}, Ee = {};
Object.defineProperty(Ee, "__esModule", { value: !0 });
Ee.ObjectDisposedError = Ee.InvalidOperationError = Ee.ArgumentNullError = void 0;
class mC extends Error {
  /**
   * Creates an instance of ArgumentNullError.
   *
   * @param {string} argumentName - Name of the argument that is null
   *
   * @memberOf ArgumentNullError
   */
  constructor(e) {
    super(e), this.name = "ArgumentNull", this.message = e;
  }
}
Ee.ArgumentNullError = mC;
class SC extends Error {
  /**
   * Creates an instance of InvalidOperationError.
   *
   * @param {string} error - The error
   *
   * @memberOf InvalidOperationError
   */
  constructor(e) {
    super(e), this.name = "InvalidOperation", this.message = e;
  }
}
Ee.InvalidOperationError = SC;
class yC extends Error {
  /**
   * Creates an instance of ObjectDisposedError.
   *
   * @param {string} objectName - The object that is disposed
   * @param {string} error - The error
   *
   * @memberOf ObjectDisposedError
   */
  constructor(e, n) {
    super(n), this.name = e + "ObjectDisposed", this.message = n;
  }
}
Ee.ObjectDisposedError = yC;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ConnectionMessage = t.MessageType = void 0;
  const e = Ee, n = Ze;
  var r;
  (function(o) {
    o[o.Text = 0] = "Text", o[o.Binary = 1] = "Binary";
  })(r = t.MessageType || (t.MessageType = {}));
  class s {
    constructor(a, i, c, u) {
      if (this.privBody = null, a === r.Text && i && typeof i != "string")
        throw new e.InvalidOperationError("Payload must be a string");
      if (a === r.Binary && i && !(i instanceof ArrayBuffer))
        throw new e.InvalidOperationError("Payload must be ArrayBuffer");
      switch (this.privMessageType = a, this.privBody = i, this.privHeaders = c || {}, this.privId = u || n.createNoDashGuid(), this.messageType) {
        case r.Binary:
          this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
          break;
        case r.Text:
          this.privSize = this.textBody.length;
      }
    }
    get messageType() {
      return this.privMessageType;
    }
    get headers() {
      return this.privHeaders;
    }
    get body() {
      return this.privBody;
    }
    get textBody() {
      if (this.privMessageType === r.Binary)
        throw new e.InvalidOperationError("Not supported for binary message");
      return this.privBody;
    }
    get binaryBody() {
      if (this.privMessageType === r.Text)
        throw new e.InvalidOperationError("Not supported for text message");
      return this.privBody;
    }
    get id() {
      return this.privId;
    }
  }
  t.ConnectionMessage = s;
})(mu);
var zo = {};
Object.defineProperty(zo, "__esModule", { value: !0 });
zo.ConnectionOpenResponse = void 0;
class CC {
  constructor(e, n) {
    this.privStatusCode = e, this.privReason = n;
  }
  get statusCode() {
    return this.privStatusCode;
  }
  get reason() {
    return this.privReason;
  }
}
zo.ConnectionOpenResponse = CC;
var jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.DeferralMap = void 0;
class _C {
  constructor() {
    this.privMap = {};
  }
  add(e, n) {
    this.privMap[e] = n;
  }
  getId(e) {
    return this.privMap[e];
  }
  complete(e, n) {
    try {
      this.privMap[e].resolve(n);
    } catch (r) {
      this.privMap[e].reject(r);
    } finally {
      this.privMap[e] = void 0;
    }
  }
}
jo.DeferralMap = _C;
var yn = {};
Object.defineProperty(yn, "__esModule", { value: !0 });
yn.SendingAgentContextMessageEvent = yn.DialogEvent = void 0;
const Tp = Zn;
class Fv extends Tp.PlatformEvent {
  constructor(e, n = Tp.EventType.Info) {
    super(e, n);
  }
}
yn.DialogEvent = Fv;
class RC extends Fv {
  constructor(e) {
    super("SendingAgentContextMessageEvent"), this.privAgentConfig = e;
  }
  get agentConfig() {
    return this.privAgentConfig;
  }
}
yn.SendingAgentContextMessageEvent = RC;
var xo = {}, hs = {};
Object.defineProperty(hs, "__esModule", { value: !0 });
hs.EventSource = void 0;
const PC = Ee, EC = Ze;
class TC {
  constructor(e) {
    this.privEventListeners = {}, this.privIsDisposed = !1, this.privConsoleListener = void 0, this.privMetadata = e;
  }
  onEvent(e) {
    if (this.isDisposed())
      throw new PC.ObjectDisposedError("EventSource");
    if (this.metadata)
      for (const n in this.metadata)
        n && e.metadata && (e.metadata[n] || (e.metadata[n] = this.metadata[n]));
    for (const n in this.privEventListeners)
      n && this.privEventListeners[n] && this.privEventListeners[n](e);
  }
  attach(e) {
    const n = EC.createNoDashGuid();
    return this.privEventListeners[n] = e, {
      detach: () => (delete this.privEventListeners[n], Promise.resolve())
    };
  }
  attachListener(e) {
    return this.attach((n) => e.onEvent(n));
  }
  attachConsoleListener(e) {
    return this.privConsoleListener && this.privConsoleListener.detach(), this.privConsoleListener = this.attach((n) => e.onEvent(n)), this.privConsoleListener;
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  dispose() {
    this.privEventListeners = null, this.privIsDisposed = !0;
  }
  get metadata() {
    return this.privMetadata;
  }
}
hs.EventSource = TC;
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.Events = void 0;
const wC = Ee, IC = hs;
class rs {
  static setEventSource(e) {
    if (!e)
      throw new wC.ArgumentNullError("eventSource");
    rs.privInstance = e;
  }
  static get instance() {
    return rs.privInstance;
  }
}
xo.Events = rs;
rs.privInstance = new IC.EventSource();
var $v = {};
Object.defineProperty($v, "__esModule", { value: !0 });
var Uv = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ConnectionState = void 0, function(e) {
    e[e.None = 0] = "None", e[e.Connected = 1] = "Connected", e[e.Connecting = 2] = "Connecting", e[e.Disconnected = 3] = "Disconnected";
  }(t.ConnectionState || (t.ConnectionState = {}));
})(Uv);
var Hv = {};
Object.defineProperty(Hv, "__esModule", { value: !0 });
var Wv = {};
Object.defineProperty(Wv, "__esModule", { value: !0 });
var Vv = {};
Object.defineProperty(Vv, "__esModule", { value: !0 });
var Kv = {};
Object.defineProperty(Kv, "__esModule", { value: !0 });
var Jv = {};
Object.defineProperty(Jv, "__esModule", { value: !0 });
var Gv = {};
Object.defineProperty(Gv, "__esModule", { value: !0 });
var Qv = {};
Object.defineProperty(Qv, "__esModule", { value: !0 });
var Yv = {};
Object.defineProperty(Yv, "__esModule", { value: !0 });
var vs = {};
Object.defineProperty(vs, "__esModule", { value: !0 });
vs.List = void 0;
const bC = Ee;
class At {
  constructor(e) {
    if (this.privSubscriptionIdCounter = 0, this.privAddSubscriptions = {}, this.privRemoveSubscriptions = {}, this.privDisposedSubscriptions = {}, this.privDisposeReason = null, this.privList = [], e)
      for (const n of e)
        this.privList.push(n);
  }
  get(e) {
    return this.throwIfDisposed(), this.privList[e];
  }
  first() {
    return this.get(0);
  }
  last() {
    return this.get(this.length() - 1);
  }
  add(e) {
    this.throwIfDisposed(), this.insertAt(this.privList.length, e);
  }
  insertAt(e, n) {
    this.throwIfDisposed(), e === 0 ? this.privList.unshift(n) : e === this.privList.length ? this.privList.push(n) : this.privList.splice(e, 0, n), this.triggerSubscriptions(this.privAddSubscriptions);
  }
  removeFirst() {
    return this.throwIfDisposed(), this.removeAt(0);
  }
  removeLast() {
    return this.throwIfDisposed(), this.removeAt(this.length() - 1);
  }
  removeAt(e) {
    return this.throwIfDisposed(), this.remove(e, 1)[0];
  }
  remove(e, n) {
    this.throwIfDisposed();
    const r = this.privList.splice(e, n);
    return this.triggerSubscriptions(this.privRemoveSubscriptions), r;
  }
  clear() {
    this.throwIfDisposed(), this.remove(0, this.length());
  }
  length() {
    return this.throwIfDisposed(), this.privList.length;
  }
  onAdded(e) {
    this.throwIfDisposed();
    const n = this.privSubscriptionIdCounter++;
    return this.privAddSubscriptions[n] = e, {
      detach: () => (delete this.privAddSubscriptions[n], Promise.resolve())
    };
  }
  onRemoved(e) {
    this.throwIfDisposed();
    const n = this.privSubscriptionIdCounter++;
    return this.privRemoveSubscriptions[n] = e, {
      detach: () => (delete this.privRemoveSubscriptions[n], Promise.resolve())
    };
  }
  onDisposed(e) {
    this.throwIfDisposed();
    const n = this.privSubscriptionIdCounter++;
    return this.privDisposedSubscriptions[n] = e, {
      detach: () => (delete this.privDisposedSubscriptions[n], Promise.resolve())
    };
  }
  join(e) {
    return this.throwIfDisposed(), this.privList.join(e);
  }
  toArray() {
    const e = Array();
    return this.privList.forEach((n) => {
      e.push(n);
    }), e;
  }
  any(e) {
    return this.throwIfDisposed(), e ? this.where(e).length() > 0 : this.length() > 0;
  }
  all(e) {
    return this.throwIfDisposed(), this.where(e).length() === this.length();
  }
  forEach(e) {
    this.throwIfDisposed();
    for (let n = 0; n < this.length(); n++)
      e(this.privList[n], n);
  }
  select(e) {
    this.throwIfDisposed();
    const n = [];
    for (let r = 0; r < this.privList.length; r++)
      n.push(e(this.privList[r], r));
    return new At(n);
  }
  where(e) {
    this.throwIfDisposed();
    const n = new At();
    for (let r = 0; r < this.privList.length; r++)
      e(this.privList[r], r) && n.add(this.privList[r]);
    return n;
  }
  orderBy(e) {
    this.throwIfDisposed();
    const r = this.toArray().sort(e);
    return new At(r);
  }
  orderByDesc(e) {
    return this.throwIfDisposed(), this.orderBy((n, r) => e(r, n));
  }
  clone() {
    return this.throwIfDisposed(), new At(this.toArray());
  }
  concat(e) {
    return this.throwIfDisposed(), new At(this.privList.concat(e.toArray()));
  }
  concatArray(e) {
    return this.throwIfDisposed(), new At(this.privList.concat(e));
  }
  isDisposed() {
    return this.privList == null;
  }
  dispose(e) {
    this.isDisposed() || (this.privDisposeReason = e, this.privList = null, this.privAddSubscriptions = null, this.privRemoveSubscriptions = null, this.triggerSubscriptions(this.privDisposedSubscriptions));
  }
  throwIfDisposed() {
    if (this.isDisposed())
      throw new bC.ObjectDisposedError("List", this.privDisposeReason);
  }
  triggerSubscriptions(e) {
    if (e)
      for (const n in e)
        n && e[n]();
  }
}
vs.List = At;
var Su = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.marshalPromiseToCallbacks = t.Sink = t.Deferred = t.PromiseResultEventSource = t.PromiseResult = t.PromiseState = void 0;
  var e;
  (function(i) {
    i[i.None = 0] = "None", i[i.Resolved = 1] = "Resolved", i[i.Rejected = 2] = "Rejected";
  })(e = t.PromiseState || (t.PromiseState = {}));
  class n {
    constructor(c) {
      this.throwIfError = () => {
        if (this.isError)
          throw this.error;
      }, c.on((u) => {
        this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !1, this.privResult = u);
      }, (u) => {
        this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !0, this.privError = u);
      });
    }
    get isCompleted() {
      return this.privIsCompleted;
    }
    get isError() {
      return this.privIsError;
    }
    get error() {
      return this.privError;
    }
    get result() {
      return this.privResult;
    }
  }
  t.PromiseResult = n;
  class r {
    constructor() {
      this.setResult = (c) => {
        this.privOnSetResult(c);
      }, this.setError = (c) => {
        this.privOnSetError(c);
      }, this.on = (c, u) => {
        this.privOnSetResult = c, this.privOnSetError = u;
      };
    }
  }
  t.PromiseResultEventSource = r;
  class s {
    constructor() {
      this.resolve = (c) => (this.privResolve(c), this), this.reject = (c) => (this.privReject(c), this), this.privPromise = new Promise((c, u) => {
        this.privResolve = c, this.privReject = u;
      });
    }
    get promise() {
      return this.privPromise;
    }
  }
  t.Deferred = s;
  class o {
    constructor() {
      this.privState = e.None, this.privPromiseResult = null, this.privPromiseResultEvents = null, this.privSuccessHandlers = [], this.privErrorHandlers = [], this.privPromiseResultEvents = new r(), this.privPromiseResult = new n(this.privPromiseResultEvents);
    }
    get state() {
      return this.privState;
    }
    get result() {
      return this.privPromiseResult;
    }
    resolve(c) {
      if (this.privState !== e.None)
        throw new Error("'Cannot resolve a completed promise'");
      this.privState = e.Resolved, this.privPromiseResultEvents.setResult(c);
      for (let u = 0; u < this.privSuccessHandlers.length; u++)
        this.executeSuccessCallback(c, this.privSuccessHandlers[u], this.privErrorHandlers[u]);
      this.detachHandlers();
    }
    reject(c) {
      if (this.privState !== e.None)
        throw new Error("'Cannot reject a completed promise'");
      this.privState = e.Rejected, this.privPromiseResultEvents.setError(c);
      for (const u of this.privErrorHandlers)
        this.executeErrorCallback(c, u);
      this.detachHandlers();
    }
    on(c, u) {
      c == null && (c = () => {
      }), this.privState === e.None ? (this.privSuccessHandlers.push(c), this.privErrorHandlers.push(u)) : (this.privState === e.Resolved ? this.executeSuccessCallback(this.privPromiseResult.result, c, u) : this.privState === e.Rejected && this.executeErrorCallback(this.privPromiseResult.error, u), this.detachHandlers());
    }
    executeSuccessCallback(c, u, p) {
      try {
        u(c);
      } catch (d) {
        this.executeErrorCallback(`'Unhandled callback error: ${d}'`, p);
      }
    }
    executeErrorCallback(c, u) {
      if (u)
        try {
          u(c);
        } catch (p) {
          throw new Error(`'Unhandled callback error: ${p}. InnerError: ${c}'`);
        }
      else
        throw new Error(`'Unhandled error: ${c}'`);
    }
    detachHandlers() {
      this.privErrorHandlers = [], this.privSuccessHandlers = [];
    }
  }
  t.Sink = o;
  function a(i, c, u) {
    i.then((p) => {
      try {
        c && c(p);
      } catch (d) {
        if (u)
          try {
            if (d instanceof Error) {
              const l = d;
              u(l.name + ": " + l.message);
            } else
              u(d);
          } catch {
          }
      }
    }, (p) => {
      if (u)
        try {
          if (p instanceof Error) {
            const d = p;
            u(d.name + ": " + d.message);
          } else
            u(p);
        } catch {
        }
    });
  }
  t.marshalPromiseToCallbacks = a;
})(Su);
var fs = {};
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.Queue = void 0;
const sc = Ee, oc = vs, wp = Su;
var Yi;
(function(t) {
  t[t.Dequeue = 0] = "Dequeue", t[t.Peek = 1] = "Peek";
})(Yi || (Yi = {}));
class AC {
  constructor(e) {
    this.privPromiseStore = new oc.List(), this.privIsDrainInProgress = !1, this.privIsDisposing = !1, this.privDisposeReason = null, this.privList = e || new oc.List(), this.privDetachables = [], this.privSubscribers = new oc.List(), this.privDetachables.push(this.privList.onAdded(() => this.drain()));
  }
  enqueue(e) {
    this.throwIfDispose(), this.enqueueFromPromise(new Promise((n) => n(e)));
  }
  enqueueFromPromise(e) {
    this.throwIfDispose(), e.then((n) => {
      this.privList.add(n);
    }, () => {
    });
  }
  dequeue() {
    this.throwIfDispose();
    const e = new wp.Deferred();
    return this.privSubscribers && (this.privSubscribers.add({ deferral: e, type: Yi.Dequeue }), this.drain()), e.promise;
  }
  peek() {
    this.throwIfDispose();
    const e = new wp.Deferred();
    return this.privSubscribers && (this.privSubscribers.add({ deferral: e, type: Yi.Peek }), this.drain()), e.promise;
  }
  length() {
    return this.throwIfDispose(), this.privList.length();
  }
  isDisposed() {
    return this.privSubscribers == null;
  }
  async drainAndDispose(e, n) {
    if (!this.isDisposed() && !this.privIsDisposing) {
      this.privDisposeReason = n, this.privIsDisposing = !0;
      const r = this.privSubscribers;
      if (r) {
        for (; r.length() > 0; )
          r.removeFirst().deferral.resolve(void 0);
        this.privSubscribers === r && (this.privSubscribers = r);
      }
      for (const s of this.privDetachables)
        await s.detach();
      if (this.privPromiseStore.length() > 0 && e) {
        const s = [];
        return this.privPromiseStore.toArray().forEach((o) => {
          s.push(o);
        }), Promise.all(s).finally(() => {
          this.privSubscribers = null, this.privList.forEach((o) => {
            e(o);
          }), this.privList = null;
        }).then();
      } else
        this.privSubscribers = null, this.privList = null;
    }
  }
  async dispose(e) {
    await this.drainAndDispose(null, e);
  }
  drain() {
    if (!this.privIsDrainInProgress && !this.privIsDisposing) {
      this.privIsDrainInProgress = !0;
      const e = this.privSubscribers, n = this.privList;
      if (e && n) {
        for (; n.length() > 0 && e.length() > 0 && !this.privIsDisposing; ) {
          const r = e.removeFirst();
          if (r.type === Yi.Peek)
            r.deferral.resolve(n.first());
          else {
            const s = n.removeFirst();
            r.deferral.resolve(s);
          }
        }
        this.privSubscribers === e && (this.privSubscribers = e), this.privList === n && (this.privList = n);
      }
      this.privIsDrainInProgress = !1;
    }
  }
  throwIfDispose() {
    if (this.isDisposed())
      throw this.privDisposeReason ? new sc.InvalidOperationError(this.privDisposeReason) : new sc.ObjectDisposedError("Queue");
    if (this.privIsDisposing)
      throw new sc.InvalidOperationError("Queue disposing");
  }
}
fs.Queue = AC;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.RawWebsocketMessage = void 0;
const Fs = mu, dr = Ee, MC = Ze;
class OC {
  constructor(e, n, r) {
    if (this.privPayload = null, !n)
      throw new dr.ArgumentNullError("payload");
    if (e === Fs.MessageType.Binary && Object.getPrototypeOf(n).constructor.name !== "ArrayBuffer")
      throw new dr.InvalidOperationError("Payload must be ArrayBuffer");
    if (e === Fs.MessageType.Text && typeof n != "string")
      throw new dr.InvalidOperationError("Payload must be a string");
    this.privMessageType = e, this.privPayload = n, this.privId = r || MC.createNoDashGuid();
  }
  get messageType() {
    return this.privMessageType;
  }
  get payload() {
    return this.privPayload;
  }
  get textContent() {
    if (this.privMessageType === Fs.MessageType.Binary)
      throw new dr.InvalidOperationError("Not supported for binary message");
    return this.privPayload;
  }
  get binaryContent() {
    if (this.privMessageType === Fs.MessageType.Text)
      throw new dr.InvalidOperationError("Not supported for text message");
    return this.privPayload;
  }
  get id() {
    return this.privId;
  }
}
Bo.RawWebsocketMessage = OC;
var qo = {};
Object.defineProperty(qo, "__esModule", { value: !0 });
qo.RiffPcmEncoder = void 0;
class kC {
  constructor(e, n) {
    this.privActualSampleRate = e, this.privDesiredSampleRate = n;
  }
  encode(e) {
    const n = this.downSampleAudioFrame(e, this.privActualSampleRate, this.privDesiredSampleRate);
    if (!n)
      return null;
    const r = n.length * 2, s = new ArrayBuffer(r), o = new DataView(s);
    return this.floatTo16BitPCM(o, 0, n), s;
  }
  setString(e, n, r) {
    for (let s = 0; s < r.length; s++)
      e.setUint8(n + s, r.charCodeAt(s));
  }
  floatTo16BitPCM(e, n, r) {
    for (let s = 0; s < r.length; s++, n += 2) {
      const o = Math.max(-1, Math.min(1, r[s]));
      e.setInt16(n, o < 0 ? o * 32768 : o * 32767, !0);
    }
  }
  downSampleAudioFrame(e, n, r) {
    if (!e)
      return null;
    if (r === n || r > n)
      return e;
    const s = n / r, o = Math.round(e.length / s), a = new Float32Array(o);
    let i = 0, c = 0;
    for (; c < o; ) {
      const u = Math.round((c + 1) * s);
      let p = 0, d = 0;
      for (; i < u && i < e.length; )
        p += e[i++], d++;
      a[c++] = p / d;
    }
    return a;
  }
}
qo.RiffPcmEncoder = kC;
var Fo = {};
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.Stream = void 0;
const Ip = Ee, DC = Ze, bp = fs;
class NC {
  constructor(e) {
    this.privIsWriteEnded = !1, this.privIsReadEnded = !1, this.privId = e || DC.createNoDashGuid(), this.privReaderQueue = new bp.Queue();
  }
  get isClosed() {
    return this.privIsWriteEnded;
  }
  get isReadEnded() {
    return this.privIsReadEnded;
  }
  get id() {
    return this.privId;
  }
  close() {
    this.privIsWriteEnded || (this.writeStreamChunk({
      buffer: null,
      isEnd: !0,
      timeReceived: Date.now()
    }), this.privIsWriteEnded = !0);
  }
  writeStreamChunk(e) {
    if (this.throwIfClosed(), !this.privReaderQueue.isDisposed())
      try {
        this.privReaderQueue.enqueue(e);
      } catch {
      }
  }
  read() {
    if (this.privIsReadEnded)
      throw new Ip.InvalidOperationError("Stream read has already finished");
    return this.privReaderQueue.dequeue().then(async (e) => ((e === void 0 || e.isEnd) && await this.privReaderQueue.dispose("End of stream reached"), e));
  }
  readEnded() {
    this.privIsReadEnded || (this.privIsReadEnded = !0, this.privReaderQueue = new bp.Queue());
  }
  throwIfClosed() {
    if (this.privIsWriteEnded)
      throw new Ip.InvalidOperationError("Stream closed");
  }
}
Fo.Stream = NC;
var $o = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.TranslationStatus = void 0, function(e) {
    e[e.Success = 0] = "Success", e[e.Error = 1] = "Error";
  }(t.TranslationStatus || (t.TranslationStatus = {}));
})($o);
var lr = {}, Ap;
function LC() {
  if (Ap)
    return lr;
  Ap = 1, Object.defineProperty(lr, "__esModule", { value: !0 }), lr.ChunkedArrayBufferStream = void 0;
  const t = O();
  let e = class extends t.Stream {
    constructor(r, s) {
      super(s), this.privTargetChunkSize = Math.round(r), this.privNextBufferReadyBytes = 0;
    }
    writeStreamChunk(r) {
      if (r.isEnd || this.privNextBufferReadyBytes === 0 && r.buffer.byteLength === this.privTargetChunkSize) {
        super.writeStreamChunk(r);
        return;
      }
      let s = 0;
      for (; s < r.buffer.byteLength; ) {
        this.privNextBufferToWrite === void 0 && (this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize), this.privNextBufferStartTime = r.timeReceived);
        const o = Math.min(r.buffer.byteLength - s, this.privTargetChunkSize - this.privNextBufferReadyBytes), a = new Uint8Array(this.privNextBufferToWrite), i = new Uint8Array(r.buffer.slice(s, o + s));
        a.set(i, this.privNextBufferReadyBytes), this.privNextBufferReadyBytes += o, s += o, this.privNextBufferReadyBytes === this.privTargetChunkSize && (super.writeStreamChunk({
          buffer: this.privNextBufferToWrite,
          isEnd: !1,
          timeReceived: this.privNextBufferStartTime
        }), this.privNextBufferReadyBytes = 0, this.privNextBufferToWrite = void 0);
      }
    }
    close() {
      this.privNextBufferReadyBytes !== 0 && !this.isClosed && super.writeStreamChunk({
        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
        isEnd: !1,
        timeReceived: this.privNextBufferStartTime
      }), super.close();
    }
  };
  return lr.ChunkedArrayBufferStream = e, lr;
}
var Zv = {};
Object.defineProperty(Zv, "__esModule", { value: !0 });
var Uo = {};
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.Timeout = void 0;
class ke {
  static load() {
    const e = /* @__PURE__ */ new Map([[0, () => {
    }]]), n = /* @__PURE__ */ new Map(), s = "data:text/javascript;base64," + btoa(`!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`), o = new Worker(s);
    return o.addEventListener("message", ({ data: c }) => {
      if (ke.isCallNotification(c)) {
        const { params: { timerId: u } } = c, p = e.get(u);
        if (typeof p == "number") {
          const d = n.get(p);
          if (d === void 0 || d !== u)
            throw new Error("The timer is in an undefined state.");
        } else if (typeof p < "u")
          p(), e.delete(u);
        else
          throw new Error("The timer is in an undefined state.");
      } else if (ke.isClearResponse(c)) {
        const { id: u } = c, p = n.get(u);
        if (p === void 0)
          throw new Error("The timer is in an undefined state.");
        n.delete(u), e.delete(p);
      } else {
        const { error: { message: u } } = c;
        throw new Error(u);
      }
    }), {
      clearTimeout: (c) => {
        const u = Math.random();
        n.set(u, c), e.set(c, u), o.postMessage({
          id: u,
          method: "clear",
          params: { timerId: c }
        });
      },
      setTimeout: (c, u) => {
        const p = Math.random();
        return e.set(p, c), o.postMessage({
          id: null,
          method: "set",
          params: {
            delay: u,
            now: performance.now(),
            timerId: p
          }
        }), p;
      }
    };
  }
  static loadWorkerTimers() {
    return () => (ke.workerTimers !== null || (ke.workerTimers = ke.load()), ke.workerTimers);
  }
  static isCallNotification(e) {
    return e.method !== void 0 && e.method === "call";
  }
  static isClearResponse(e) {
    return e.error === null && typeof e.id == "number";
  }
}
Uo.Timeout = ke;
ke.workerTimers = null;
ke.clearTimeout = (t) => ke.timers().clearTimeout(t);
ke.setTimeout = (t, e) => ke.timers().setTimeout(t, e);
ke.timers = ke.loadWorkerTimers();
var H = {};
Object.defineProperty(H, "__esModule", { value: !0 });
H.OCSPCacheUpdateErrorEvent = H.OCSPResponseRetrievedEvent = H.OCSPCacheFetchErrorEvent = H.OCSPVerificationFailedEvent = H.OCSPCacheHitEvent = H.OCSPCacheEntryNeedsRefreshEvent = H.OCSPCacheEntryExpiredEvent = H.OCSPWSUpgradeStartedEvent = H.OCSPStapleReceivedEvent = H.OCSPCacheUpdateCompleteEvent = H.OCSPDiskCacheStoreEvent = H.OCSPMemoryCacheStoreEvent = H.OCSPCacheUpdateNeededEvent = H.OCSPDiskCacheHitEvent = H.OCSPCacheMissEvent = H.OCSPMemoryCacheHitEvent = H.OCSPEvent = void 0;
const Te = Zn;
class we extends Te.PlatformEvent {
  constructor(e, n, r) {
    super(e, n), this.privSignature = r;
  }
}
H.OCSPEvent = we;
class zC extends we {
  constructor(e) {
    super("OCSPMemoryCacheHitEvent", Te.EventType.Debug, e);
  }
}
H.OCSPMemoryCacheHitEvent = zC;
class jC extends we {
  constructor(e) {
    super("OCSPCacheMissEvent", Te.EventType.Debug, e);
  }
}
H.OCSPCacheMissEvent = jC;
class xC extends we {
  constructor(e) {
    super("OCSPDiskCacheHitEvent", Te.EventType.Debug, e);
  }
}
H.OCSPDiskCacheHitEvent = xC;
class BC extends we {
  constructor(e) {
    super("OCSPCacheUpdateNeededEvent", Te.EventType.Debug, e);
  }
}
H.OCSPCacheUpdateNeededEvent = BC;
class qC extends we {
  constructor(e) {
    super("OCSPMemoryCacheStoreEvent", Te.EventType.Debug, e);
  }
}
H.OCSPMemoryCacheStoreEvent = qC;
class FC extends we {
  constructor(e) {
    super("OCSPDiskCacheStoreEvent", Te.EventType.Debug, e);
  }
}
H.OCSPDiskCacheStoreEvent = FC;
class $C extends we {
  constructor(e) {
    super("OCSPCacheUpdateCompleteEvent", Te.EventType.Debug, e);
  }
}
H.OCSPCacheUpdateCompleteEvent = $C;
class UC extends we {
  constructor() {
    super("OCSPStapleReceivedEvent", Te.EventType.Debug, "");
  }
}
H.OCSPStapleReceivedEvent = UC;
class HC extends we {
  constructor(e) {
    super("OCSPWSUpgradeStartedEvent", Te.EventType.Debug, e);
  }
}
H.OCSPWSUpgradeStartedEvent = HC;
class WC extends we {
  constructor(e, n) {
    super("OCSPCacheEntryExpiredEvent", Te.EventType.Debug, e), this.privExpireTime = n;
  }
}
H.OCSPCacheEntryExpiredEvent = WC;
class VC extends we {
  constructor(e, n, r) {
    super("OCSPCacheEntryNeedsRefreshEvent", Te.EventType.Debug, e), this.privExpireTime = r, this.privStartTime = n;
  }
}
H.OCSPCacheEntryNeedsRefreshEvent = VC;
class KC extends we {
  constructor(e, n, r) {
    super("OCSPCacheHitEvent", Te.EventType.Debug, e), this.privExpireTime = r, this.privExpireTimeString = new Date(r).toLocaleDateString(), this.privStartTime = n, this.privStartTimeString = new Date(n).toLocaleTimeString();
  }
}
H.OCSPCacheHitEvent = KC;
class JC extends we {
  constructor(e, n) {
    super("OCSPVerificationFailedEvent", Te.EventType.Debug, e), this.privError = n;
  }
}
H.OCSPVerificationFailedEvent = JC;
class GC extends we {
  constructor(e, n) {
    super("OCSPCacheFetchErrorEvent", Te.EventType.Debug, e), this.privError = n;
  }
}
H.OCSPCacheFetchErrorEvent = GC;
class QC extends we {
  constructor(e) {
    super("OCSPResponseRetrievedEvent", Te.EventType.Debug, e);
  }
}
H.OCSPResponseRetrievedEvent = QC;
class YC extends we {
  constructor(e, n) {
    super("OCSPCacheUpdateErrorEvent", Te.EventType.Debug, e), this.privError = n;
  }
}
H.OCSPCacheUpdateErrorEvent = YC;
var hr = {}, Mp;
function ZC() {
  if (Mp)
    return hr;
  Mp = 1, Object.defineProperty(hr, "__esModule", { value: !0 }), hr.BackgroundEvent = void 0;
  const t = O();
  class e extends t.PlatformEvent {
    constructor(r) {
      super("BackgroundEvent", t.EventType.Error), this.privError = r;
    }
    get error() {
      return this.privError;
    }
  }
  return hr.BackgroundEvent = e, hr;
}
var Op;
function O() {
  return Op || (Op = 1, function(t) {
    var e = $ && $.__createBinding || (Object.create ? function(s, o, a, i) {
      i === void 0 && (i = a), Object.defineProperty(s, i, { enumerable: !0, get: function() {
        return o[a];
      } });
    } : function(s, o, a, i) {
      i === void 0 && (i = a), s[i] = o[a];
    }), n = $ && $.__exportStar || function(s, o) {
      for (var a in s)
        a !== "default" && !o.hasOwnProperty(a) && e(o, s, a);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(ue, t), n(le, t), n(mu, t), n(zo, t), n(jo, t), n(yn, t), n(Ee, t), n(xo, t), n(hs, t), n(Ze, t), n($v, t), n(Uv, t), n(Hv, t), n(Wv, t), n(Vv, t), n(Kv, t), n(Jv, t), n(Gv, t), n(Qv, t), n(Yv, t), n(vs, t), n(Zn, t), n(Su, t), n(fs, t), n(Bo, t), n(qo, t), n(Fo, t);
    var r = $o;
    Object.defineProperty(t, "TranslationStatus", { enumerable: !0, get: function() {
      return r.TranslationStatus;
    } }), n(LC(), t), n(Zv, t), n(Uo, t), n(H, t), n(ZC(), t);
  }(ec)), ec;
}
var me = {};
Object.defineProperty(me, "__esModule", { value: !0 });
me.HeaderNames = void 0;
class it {
}
me.HeaderNames = it;
it.AuthKey = "Ocp-Apim-Subscription-Key";
it.Authorization = "Authorization";
it.SpIDAuthKey = "Apim-Subscription-Id";
it.ConnectionId = "X-ConnectionId";
it.ContentType = "Content-Type";
it.CustomCommandsAppId = "X-CommandsAppId";
it.Path = "Path";
it.RequestId = "X-RequestId";
it.RequestStreamId = "X-StreamId";
it.RequestTimestamp = "X-Timestamp";
var er = {};
Object.defineProperty(er, "__esModule", { value: !0 });
er.AuthInfo = void 0;
class XC {
  constructor(e, n) {
    this.privHeaderName = e, this.privToken = n;
  }
  get headerName() {
    return this.privHeaderName;
  }
  get token() {
    return this.privToken;
  }
}
er.AuthInfo = XC;
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.CognitiveSubscriptionKeyAuthentication = void 0;
const e_ = O(), t_ = me, n_ = er;
class r_ {
  /**
   * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
   * @constructor
   * @param {string} subscriptionKey - The subscription key
   */
  constructor(e) {
    if (!e)
      throw new e_.ArgumentNullError("subscriptionKey");
    this.privAuthInfo = new n_.AuthInfo(t_.HeaderNames.AuthKey, e);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetch(e) {
    return Promise.resolve(this.privAuthInfo);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetchOnExpiry(e) {
    return Promise.resolve(this.privAuthInfo);
  }
}
Po.CognitiveSubscriptionKeyAuthentication = r_;
var Ho = {};
Object.defineProperty(Ho, "__esModule", { value: !0 });
Ho.CognitiveTokenAuthentication = void 0;
const kp = O(), Dp = er, Np = me;
class is {
  constructor(e, n) {
    if (!e)
      throw new kp.ArgumentNullError("fetchCallback");
    if (!n)
      throw new kp.ArgumentNullError("fetchOnExpiryCallback");
    this.privFetchCallback = e, this.privFetchOnExpiryCallback = n;
  }
  fetch(e) {
    return this.privFetchCallback(e).then((n) => new Dp.AuthInfo(Np.HeaderNames.Authorization, n === void 0 ? void 0 : is.privTokenPrefix + n));
  }
  fetchOnExpiry(e) {
    return this.privFetchOnExpiryCallback(e).then((n) => new Dp.AuthInfo(Np.HeaderNames.Authorization, n === void 0 ? void 0 : is.privTokenPrefix + n));
  }
}
Ho.CognitiveTokenAuthentication = is;
is.privTokenPrefix = "Bearer ";
var Xv = {};
Object.defineProperty(Xv, "__esModule", { value: !0 });
var ef = {};
Object.defineProperty(ef, "__esModule", { value: !0 });
var vr = {}, ac = {}, Wo = {};
const i_ = {}, s_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: i_
}, Symbol.toStringTag, { value: "Module" })), En = /* @__PURE__ */ XS(s_);
var yu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LogLevel = void 0;
  const e = O();
  Object.defineProperty(t, "LogLevel", { enumerable: !0, get: function() {
    return e.EventType;
  } });
})(yu);
var D = {};
Object.defineProperty(D, "__esModule", { value: !0 });
D.Contracts = void 0;
class Mt {
  static throwIfNullOrUndefined(e, n) {
    if (e == null)
      throw new Error("throwIfNullOrUndefined:" + n);
  }
  static throwIfNull(e, n) {
    if (e === null)
      throw new Error("throwIfNull:" + n);
  }
  static throwIfNullOrWhitespace(e, n) {
    if (Mt.throwIfNullOrUndefined(e, n), ("" + e).trim().length < 1)
      throw new Error("throwIfNullOrWhitespace:" + n);
  }
  static throwIfNullOrTooLong(e, n, r) {
    if (Mt.throwIfNullOrUndefined(e, n), ("" + e).length > r)
      throw new Error("throwIfNullOrTooLong:" + n + " (more than " + r.toString() + " characters)");
  }
  static throwIfNullOrTooShort(e, n, r) {
    if (Mt.throwIfNullOrUndefined(e, n), ("" + e).length < r)
      throw new Error("throwIfNullOrTooShort:" + n + " (less than " + r.toString() + " characters)");
  }
  static throwIfDisposed(e) {
    if (e)
      throw new Error("the object is already disposed");
  }
  static throwIfArrayEmptyOrWhitespace(e, n) {
    if (Mt.throwIfNullOrUndefined(e, n), e.length === 0)
      throw new Error("throwIfArrayEmptyOrWhitespace:" + n);
    for (const r of e)
      Mt.throwIfNullOrWhitespace(r, n);
  }
  static throwIfFileDoesNotExist(e, n) {
    Mt.throwIfNullOrWhitespace(e, n);
  }
  static throwIfNotUndefined(e, n) {
    if (e !== void 0)
      throw new Error("throwIfNotUndefined:" + n);
  }
}
D.Contracts = Mt;
var o_ = $ && $.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function() {
    return e[n];
  } });
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), a_ = $ && $.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), c_ = $ && $.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      n !== "default" && Object.hasOwnProperty.call(t, n) && o_(e, t, n);
  return a_(e, t), e;
};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.ConsoleLoggingListener = void 0;
const Lp = c_(En), fr = yu, u_ = D;
class p_ {
  constructor(e = fr.LogLevel.None) {
    this.privLogPath = void 0, this.privEnableConsoleOutput = !0, this.privLogLevelFilter = e;
  }
  set logPath(e) {
    u_.Contracts.throwIfNullOrUndefined(Lp.openSync, `
File System access not available`), this.privLogPath = e;
  }
  set enableConsoleOutput(e) {
    this.privEnableConsoleOutput = e;
  }
  onEvent(e) {
    if (e.eventType >= this.privLogLevelFilter) {
      const n = this.toString(e);
      if (this.logCallback && this.logCallback(n), this.privLogPath && Lp.writeFileSync(this.privLogPath, n + `
`, { flag: "a+" }), this.privEnableConsoleOutput)
        switch (e.eventType) {
          case fr.LogLevel.Debug:
            console.debug(n);
            break;
          case fr.LogLevel.Info:
            console.info(n);
            break;
          case fr.LogLevel.Warning:
            console.warn(n);
            break;
          case fr.LogLevel.Error:
            console.error(n);
            break;
          default:
            console.log(n);
            break;
        }
    }
  }
  toString(e) {
    const n = [
      `${e.eventTime}`,
      `${e.name}`
    ], r = e;
    for (const s in r)
      if (s && e.hasOwnProperty(s) && s !== "eventTime" && s !== "eventType" && s !== "eventId" && s !== "name" && s !== "constructor") {
        const o = r[s];
        let a = "<NULL>";
        o != null && (typeof o == "number" || typeof o == "string" ? a = o.toString() : a = JSON.stringify(o)), n.push(`${s}: ${a}`);
      }
    return n.join(" | ");
  }
}
Wo.ConsoleLoggingListener = p_;
var tf = {};
Object.defineProperty(tf, "__esModule", { value: !0 });
var cc = {}, Wt = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AudioStreamFormatImpl = t.AudioStreamFormat = t.AudioFormatTag = void 0;
  var e;
  (function(s) {
    s[s.PCM = 1] = "PCM", s[s.MuLaw = 2] = "MuLaw", s[s.Siren = 3] = "Siren", s[s.MP3 = 4] = "MP3", s[s.SILKSkype = 5] = "SILKSkype", s[s.OGG_OPUS = 6] = "OGG_OPUS", s[s.WEBM_OPUS = 7] = "WEBM_OPUS", s[s.ALaw = 8] = "ALaw", s[s.FLAC = 9] = "FLAC", s[s.OPUS = 10] = "OPUS", s[s.AMR_WB = 11] = "AMR_WB", s[s.G722 = 12] = "G722";
  })(e = t.AudioFormatTag || (t.AudioFormatTag = {}));
  class n {
    /**
     * Creates an audio stream format object representing the default audio stream
     * format (16KHz 16bit mono PCM).
     * @member AudioStreamFormat.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getDefaultInputFormat() {
      return r.getDefaultInputFormat();
    }
    /**
     * Creates an audio stream format object with the specified format characteristics.
     * @member AudioStreamFormat.getWaveFormat
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getWaveFormat(o, a, i, c) {
      return new r(o, a, i, c);
    }
    /**
     * Creates an audio stream format object with the specified pcm waveformat characteristics.
     * @member AudioStreamFormat.getWaveFormatPCM
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getWaveFormatPCM(o, a, i) {
      return new r(o, a, i);
    }
  }
  t.AudioStreamFormat = n;
  class r extends n {
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {number} channels - Number of channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     */
    constructor(o = 16e3, a = 16, i = 1, c = e.PCM) {
      super();
      let u = !0;
      switch (c) {
        case e.PCM:
          this.formatTag = 1;
          break;
        case e.ALaw:
          this.formatTag = 6;
          break;
        case e.MuLaw:
          this.formatTag = 7;
          break;
        default:
          u = !1;
      }
      if (this.bitsPerSample = a, this.samplesPerSec = o, this.channels = i, this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8), this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8), u) {
        this.privHeader = new ArrayBuffer(44);
        const p = new DataView(this.privHeader);
        this.setString(p, 0, "RIFF"), p.setUint32(4, 0, !0), this.setString(p, 8, "WAVEfmt "), p.setUint32(16, 16, !0), p.setUint16(20, this.formatTag, !0), p.setUint16(22, this.channels, !0), p.setUint32(24, this.samplesPerSec, !0), p.setUint32(28, this.avgBytesPerSec, !0), p.setUint16(32, this.channels * (this.bitsPerSample / 8), !0), p.setUint16(34, this.bitsPerSample, !0), this.setString(p, 36, "data"), p.setUint32(40, 0, !0);
      }
    }
    /**
     * Retrieves the default input format.
     * @member AudioStreamFormatImpl.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormatImpl} The default input format.
     */
    static getDefaultInputFormat() {
      return new r();
    }
    /**
     * Creates an audio context appropriate to current browser
     * @member AudioStreamFormatImpl.getAudioContext
     * @function
     * @public
     * @returns {AudioContext} An audio context instance
     */
    /* eslint-disable */
    static getAudioContext(o) {
      const a = window.AudioContext || window.webkitAudioContext || !1;
      if (a)
        return o !== void 0 && navigator.mediaDevices.getSupportedConstraints().sampleRate ? new a({ sampleRate: o }) : new a();
      throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
    }
    /* eslint-enable */
    /**
     * Closes the configuration object.
     * @member AudioStreamFormatImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    get header() {
      return this.privHeader;
    }
    setString(o, a, i) {
      for (let c = 0; c < i.length; c++)
        o.setUint8(a + c, i.charCodeAt(c));
    }
  }
  t.AudioStreamFormatImpl = r;
})(Wt);
var zp;
function d_() {
  return zp || (zp = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MicAudioSource = t.AudioWorkletSourceURLPropertyName = void 0;
    const e = b(), n = O(), r = Wt;
    t.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
    class s {
      constructor(a, i, c, u) {
        this.privRecorder = a, this.deviceId = i, this.privStreams = {}, this.privOutputChunkSize = s.AUDIOFORMAT.avgBytesPerSec / 10, this.privId = c || n.createNoDashGuid(), this.privEvents = new n.EventSource(), this.privMediaStream = u || null, this.privIsClosing = !1;
      }
      get format() {
        return Promise.resolve(s.AUDIOFORMAT);
      }
      turnOn() {
        if (this.privInitializeDeferral)
          return this.privInitializeDeferral.promise;
        this.privInitializeDeferral = new n.Deferred();
        try {
          this.createAudioContext();
        } catch (c) {
          if (c instanceof Error) {
            const u = c;
            this.privInitializeDeferral.reject(u.name + ": " + u.message);
          } else
            this.privInitializeDeferral.reject(c);
          return this.privInitializeDeferral.promise;
        }
        const a = window.navigator;
        let i = (
          // eslint-disable-next-line
          a.getUserMedia || a.webkitGetUserMedia || a.mozGetUserMedia || a.msGetUserMedia
        );
        if (a.mediaDevices && (i = (c, u, p) => {
          a.mediaDevices.getUserMedia(c).then(u).catch(p);
        }), i) {
          const c = () => {
            this.onEvent(new n.AudioSourceInitializingEvent(this.privId)), this.privMediaStream && this.privMediaStream.active ? (this.onEvent(new n.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve()) : i({ audio: this.deviceId ? { deviceId: this.deviceId } : !0, video: !1 }, (u) => {
              this.privMediaStream = u, this.onEvent(new n.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve();
            }, (u) => {
              const p = `Error occurred during microphone initialization: ${u}`;
              this.privInitializeDeferral.reject(p), this.onEvent(new n.AudioSourceErrorEvent(this.privId, p));
            });
          };
          this.privContext.state === "suspended" ? this.privContext.resume().then(c).catch((u) => {
            this.privInitializeDeferral.reject(`Failed to initialize audio context: ${u}`);
          }) : c();
        } else {
          const c = "Browser does not support getUserMedia.";
          this.privInitializeDeferral.reject(c), this.onEvent(new n.AudioSourceErrorEvent(c, ""));
        }
        return this.privInitializeDeferral.promise;
      }
      id() {
        return this.privId;
      }
      attach(a) {
        return this.onEvent(new n.AudioStreamNodeAttachingEvent(this.privId, a)), this.listen(a).then((i) => (this.onEvent(new n.AudioStreamNodeAttachedEvent(this.privId, a)), {
          detach: async () => (i.readEnded(), delete this.privStreams[a], this.onEvent(new n.AudioStreamNodeDetachedEvent(this.privId, a)), this.turnOff()),
          id: () => a,
          read: () => i.read()
        }));
      }
      detach(a) {
        a && this.privStreams[a] && (this.privStreams[a].close(), delete this.privStreams[a], this.onEvent(new n.AudioStreamNodeDetachedEvent(this.privId, a)));
      }
      async turnOff() {
        for (const a in this.privStreams)
          if (a) {
            const i = this.privStreams[a];
            i && i.close();
          }
        this.onEvent(new n.AudioSourceOffEvent(this.privId)), this.privInitializeDeferral && (await this.privInitializeDeferral, this.privInitializeDeferral = null), await this.destroyAudioContext();
      }
      get events() {
        return this.privEvents;
      }
      get deviceInfo() {
        return this.getMicrophoneLabel().then((a) => ({
          bitspersample: s.AUDIOFORMAT.bitsPerSample,
          channelcount: s.AUDIOFORMAT.channels,
          connectivity: e.connectivity.Unknown,
          manufacturer: "Speech SDK",
          model: a,
          samplerate: s.AUDIOFORMAT.samplesPerSec,
          type: e.type.Microphones
        }));
      }
      setProperty(a, i) {
        if (a === t.AudioWorkletSourceURLPropertyName)
          this.privRecorder.setWorkletUrl(i);
        else
          throw new Error("Property '" + a + "' is not supported on Microphone.");
      }
      getMicrophoneLabel() {
        const a = "microphone";
        if (this.privMicrophoneLabel !== void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        if (this.privMediaStream === void 0 || !this.privMediaStream.active)
          return Promise.resolve(a);
        this.privMicrophoneLabel = a;
        const i = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        if (i === void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        const c = new n.Deferred();
        return navigator.mediaDevices.enumerateDevices().then((u) => {
          for (const p of u)
            if (p.deviceId === i) {
              this.privMicrophoneLabel = p.label;
              break;
            }
          c.resolve(this.privMicrophoneLabel);
        }, () => c.resolve(this.privMicrophoneLabel)), c.promise;
      }
      async listen(a) {
        await this.turnOn();
        const i = new n.ChunkedArrayBufferStream(this.privOutputChunkSize, a);
        this.privStreams[a] = i;
        try {
          this.privRecorder.record(this.privContext, this.privMediaStream, i);
        } catch (u) {
          throw this.onEvent(new n.AudioStreamNodeErrorEvent(this.privId, a, u)), u;
        }
        return i;
      }
      onEvent(a) {
        this.privEvents.onEvent(a), n.Events.instance.onEvent(a);
      }
      createAudioContext() {
        this.privContext || (this.privContext = r.AudioStreamFormatImpl.getAudioContext(s.AUDIOFORMAT.samplesPerSec));
      }
      async destroyAudioContext() {
        if (!this.privContext)
          return;
        this.privRecorder.releaseMediaResources(this.privContext);
        let a = !1;
        "close" in this.privContext && (a = !0), a ? this.privIsClosing || (this.privIsClosing = !0, await this.privContext.close(), this.privContext = null, this.privIsClosing = !1) : this.privContext !== null && this.privContext.state === "running" && await this.privContext.suspend();
      }
    }
    t.MicAudioSource = s, s.AUDIOFORMAT = r.AudioStreamFormat.getDefaultInputFormat();
  }(cc)), cc;
}
var gr = {}, jp;
function l_() {
  if (jp)
    return gr;
  jp = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.FileAudioSource = void 0;
  const t = b(), e = O(), n = Wt;
  let r = class {
    constructor(o, a, i) {
      this.privStreams = {}, this.privHeaderEnd = 44, this.privId = i || e.createNoDashGuid(), this.privEvents = new e.EventSource(), this.privSource = o, typeof window < "u" && typeof Blob < "u" && this.privSource instanceof Blob ? this.privFilename = o.name : this.privFilename = a || "unknown.wav", this.privAudioFormatPromise = this.readHeader();
    }
    get format() {
      return this.privAudioFormatPromise;
    }
    turnOn() {
      if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
        const o = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
        return this.onEvent(new e.AudioSourceErrorEvent(o, "")), Promise.reject(o);
      }
      this.onEvent(new e.AudioSourceInitializingEvent(this.privId)), this.onEvent(new e.AudioSourceReadyEvent(this.privId));
    }
    id() {
      return this.privId;
    }
    async attach(o) {
      this.onEvent(new e.AudioStreamNodeAttachingEvent(this.privId, o));
      const a = await this.upload(o);
      return this.onEvent(new e.AudioStreamNodeAttachedEvent(this.privId, o)), Promise.resolve({
        detach: async () => {
          a.readEnded(), delete this.privStreams[o], this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, o)), await this.turnOff();
        },
        id: () => o,
        read: () => a.read()
      });
    }
    detach(o) {
      o && this.privStreams[o] && (this.privStreams[o].close(), delete this.privStreams[o], this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, o)));
    }
    turnOff() {
      for (const o in this.privStreams)
        if (o) {
          const a = this.privStreams[o];
          a && !a.isClosed && a.close();
        }
      return this.onEvent(new e.AudioSourceOffEvent(this.privId)), Promise.resolve();
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return this.privAudioFormatPromise.then((o) => Promise.resolve({
        bitspersample: o.bitsPerSample,
        channelcount: o.channels,
        connectivity: t.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "File",
        samplerate: o.samplesPerSec,
        type: t.type.File
      }));
    }
    readHeader() {
      const a = this.privSource.slice(0, 4296), i = new e.Deferred(), c = (u) => {
        const p = new DataView(u), d = (m) => String.fromCharCode(p.getUint8(m), p.getUint8(m + 1), p.getUint8(m + 2), p.getUint8(m + 3));
        if (d(0) !== "RIFF") {
          i.reject("Invalid WAV header in file, RIFF was not found");
          return;
        }
        if (d(8) !== "WAVE" || d(12) !== "fmt ") {
          i.reject("Invalid WAV header in file, WAVEfmt was not found");
          return;
        }
        const l = p.getInt32(16, !0), h = p.getUint16(22, !0), v = p.getUint32(24, !0), g = p.getUint16(34, !0);
        let f = 36 + Math.max(l - 16, 0);
        for (; d(f) !== "data"; f += 2)
          if (f > 4288) {
            i.reject("Invalid WAV header in file, data block was not found");
            return;
          }
        this.privHeaderEnd = f + 8, i.resolve(n.AudioStreamFormat.getWaveFormatPCM(v, g, h));
      };
      if (typeof window < "u" && typeof Blob < "u" && a instanceof Blob) {
        const u = new FileReader();
        u.onload = (p) => {
          const d = p.target.result;
          c(d);
        }, u.readAsArrayBuffer(a);
      } else {
        const u = a;
        c(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      }
      return i.promise;
    }
    async upload(o) {
      const a = (i) => {
        const c = `Error occurred while processing '${this.privFilename}'. ${i}`;
        throw this.onEvent(new e.AudioStreamNodeErrorEvent(this.privId, o, c)), new Error(c);
      };
      try {
        await this.turnOn();
        const i = await this.privAudioFormatPromise, c = new e.ChunkedArrayBufferStream(i.avgBytesPerSec / 10, o);
        this.privStreams[o] = c;
        const u = this.privSource.slice(this.privHeaderEnd), p = (d) => {
          c.isClosed || (c.writeStreamChunk({
            buffer: d,
            isEnd: !1,
            timeReceived: Date.now()
          }), c.close());
        };
        if (typeof window < "u" && typeof Blob < "u" && u instanceof Blob) {
          const d = new FileReader();
          d.onerror = (l) => a(l.toString()), d.onload = (l) => {
            const h = l.target.result;
            p(h);
          }, d.readAsArrayBuffer(u);
        } else {
          const d = u;
          p(d.buffer.slice(d.byteOffset, d.byteOffset + d.byteLength));
        }
        return c;
      } catch (i) {
        a(i);
      }
    }
    onEvent(o) {
      this.privEvents.onEvent(o), e.Events.instance.onEvent(o);
    }
  };
  return gr.FileAudioSource = r, gr;
}
var Vo = {};
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.PcmRecorder = void 0;
const h_ = O();
class v_ {
  constructor(e) {
    this.privStopInputOnRelease = e;
  }
  record(e, n, r) {
    const o = new h_.RiffPcmEncoder(e.sampleRate, 16e3), a = e.createMediaStreamSource(n), i = () => {
      const u = (() => {
        let p = 0;
        try {
          return e.createScriptProcessor(p, 1, 1);
        } catch {
          p = 2048;
          let l = e.sampleRate;
          for (; p < 16384 && l >= 32e3; )
            p <<= 1, l >>= 1;
          return e.createScriptProcessor(p, 1, 1);
        }
      })();
      u.onaudioprocess = (p) => {
        const d = p.inputBuffer.getChannelData(0);
        if (r && !r.isClosed) {
          const l = o.encode(d);
          l && r.writeStreamChunk({
            buffer: l,
            isEnd: !1,
            timeReceived: Date.now()
          });
        }
      }, a.connect(u), u.connect(e.destination), this.privMediaResources = {
        scriptProcessorNode: u,
        source: a,
        stream: n
      };
    }, c = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
    if (e.audioWorklet && !c) {
      if (!this.privSpeechProcessorScript) {
        const u = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`, p = new Blob([u], { type: "application/javascript; charset=utf-8" });
        this.privSpeechProcessorScript = URL.createObjectURL(p);
      }
      e.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
        const u = new AudioWorkletNode(e, "speech-processor");
        u.port.onmessage = (p) => {
          const d = p.data;
          if (r && !r.isClosed) {
            const l = o.encode(d);
            l && r.writeStreamChunk({
              buffer: l,
              isEnd: !1,
              timeReceived: Date.now()
            });
          }
        }, a.connect(u), u.connect(e.destination), this.privMediaResources = {
          scriptProcessorNode: u,
          source: a,
          stream: n
        };
      }).catch(() => {
        i();
      });
    } else
      try {
        i();
      } catch (u) {
        throw new Error(`Unable to start audio worklet node for PCMRecorder: ${u}`);
      }
  }
  releaseMediaResources(e) {
    this.privMediaResources && (this.privMediaResources.scriptProcessorNode && (this.privMediaResources.scriptProcessorNode.disconnect(e.destination), this.privMediaResources.scriptProcessorNode = null), this.privMediaResources.source && (this.privMediaResources.source.disconnect(), this.privStopInputOnRelease && this.privMediaResources.stream.getTracks().forEach((n) => n.stop()), this.privMediaResources.source = null));
  }
  setWorkletUrl(e) {
    this.privSpeechProcessorScript = e;
  }
}
Vo.PcmRecorder = v_;
var Ko = {}, gs = {}, f_ = $ && $.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function() {
    return e[n];
  } });
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), g_ = $ && $.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), nf = $ && $.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      n !== "default" && Object.hasOwnProperty.call(t, n) && f_(e, t, n);
  return g_(e, t), e;
}, Cu = $ && $.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.WebsocketMessageAdapter = void 0;
const m_ = nf(En), S_ = nf(En), y_ = Cu(En), C_ = Cu(En), __ = Cu(En), R_ = me, z = O();
class ss {
  constructor(e, n, r, s, o, a) {
    if (!e)
      throw new z.ArgumentNullError("uri");
    if (!r)
      throw new z.ArgumentNullError("messageFormatter");
    this.proxyInfo = s, this.privConnectionEvents = new z.EventSource(), this.privConnectionId = n, this.privMessageFormatter = r, this.privConnectionState = z.ConnectionState.None, this.privUri = e, this.privHeaders = o, this.privEnableCompression = a, this.privHeaders[R_.HeaderNames.ConnectionId] = this.privConnectionId, this.privLastErrorReceived = "";
  }
  get state() {
    return this.privConnectionState;
  }
  open() {
    if (this.privConnectionState === z.ConnectionState.Disconnected)
      return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
    if (this.privConnectionEstablishDeferral)
      return this.privConnectionEstablishDeferral.promise;
    this.privConnectionEstablishDeferral = new z.Deferred(), this.privCertificateValidatedDeferral = new z.Deferred(), this.privConnectionState = z.ConnectionState.Connecting;
    try {
      if (typeof WebSocket < "u" && !ss.forceNpmWebSocket)
        this.privCertificateValidatedDeferral.resolve(), this.privWebsocketClient = new WebSocket(this.privUri);
      else {
        const e = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression };
        this.privCertificateValidatedDeferral.resolve(), e.agent = this.getAgent();
        let r = new URL(this.privUri).protocol;
        (r == null ? void 0 : r.toLocaleLowerCase()) === "wss:" ? r = "https:" : (r == null ? void 0 : r.toLocaleLowerCase()) === "ws:" && (r = "http:"), e.agent.protocol = r, this.privWebsocketClient = new __.default(this.privUri, e);
      }
      this.privWebsocketClient.binaryType = "arraybuffer", this.privReceivingMessageQueue = new z.Queue(), this.privDisconnectDeferral = new z.Deferred(), this.privSendMessageQueue = new z.Queue(), this.processSendQueue().catch((e) => {
        z.Events.instance.onEvent(new z.BackgroundEvent(e));
      });
    } catch (e) {
      return this.privConnectionEstablishDeferral.resolve(new z.ConnectionOpenResponse(500, e)), this.privConnectionEstablishDeferral.promise;
    }
    return this.onEvent(new z.ConnectionStartEvent(this.privConnectionId, this.privUri)), this.privWebsocketClient.onopen = () => {
      this.privCertificateValidatedDeferral.promise.then(() => {
        this.privConnectionState = z.ConnectionState.Connected, this.onEvent(new z.ConnectionEstablishedEvent(this.privConnectionId)), this.privConnectionEstablishDeferral.resolve(new z.ConnectionOpenResponse(200, ""));
      }, (e) => {
        this.privConnectionEstablishDeferral.reject(e);
      });
    }, this.privWebsocketClient.onerror = (e) => {
      this.onEvent(new z.ConnectionErrorEvent(this.privConnectionId, e.message, e.type)), this.privLastErrorReceived = e.message;
    }, this.privWebsocketClient.onclose = (e) => {
      this.privConnectionState === z.ConnectionState.Connecting ? (this.privConnectionState = z.ConnectionState.Disconnected, this.privConnectionEstablishDeferral.resolve(new z.ConnectionOpenResponse(e.code, e.reason + " " + this.privLastErrorReceived))) : (this.privConnectionState = z.ConnectionState.Disconnected, this.privWebsocketClient = null, this.onEvent(new z.ConnectionClosedEvent(this.privConnectionId, e.code, e.reason))), this.onClose(e.code, e.reason).catch((n) => {
        z.Events.instance.onEvent(new z.BackgroundEvent(n));
      });
    }, this.privWebsocketClient.onmessage = (e) => {
      const n = (/* @__PURE__ */ new Date()).toISOString();
      if (this.privConnectionState === z.ConnectionState.Connected) {
        const r = new z.Deferred();
        if (this.privReceivingMessageQueue.enqueueFromPromise(r.promise), e.data instanceof ArrayBuffer) {
          const s = new z.RawWebsocketMessage(z.MessageType.Binary, e.data);
          this.privMessageFormatter.toConnectionMessage(s).then((o) => {
            this.onEvent(new z.ConnectionMessageReceivedEvent(this.privConnectionId, n, o)), r.resolve(o);
          }, (o) => {
            r.reject(`Invalid binary message format. Error: ${o}`);
          });
        } else {
          const s = new z.RawWebsocketMessage(z.MessageType.Text, e.data);
          this.privMessageFormatter.toConnectionMessage(s).then((o) => {
            this.onEvent(new z.ConnectionMessageReceivedEvent(this.privConnectionId, n, o)), r.resolve(o);
          }, (o) => {
            r.reject(`Invalid text message format. Error: ${o}`);
          });
        }
      }
    }, this.privConnectionEstablishDeferral.promise;
  }
  send(e) {
    if (this.privConnectionState !== z.ConnectionState.Connected)
      return Promise.reject(`Cannot send on connection that is in ${z.ConnectionState[this.privConnectionState]} state`);
    const n = new z.Deferred(), r = new z.Deferred();
    return this.privSendMessageQueue.enqueueFromPromise(r.promise), this.privMessageFormatter.fromConnectionMessage(e).then((s) => {
      r.resolve({
        Message: e,
        RawWebsocketMessage: s,
        sendStatusDeferral: n
      });
    }, (s) => {
      r.reject(`Error formatting the message. ${s}`);
    }), n.promise;
  }
  read() {
    return this.privConnectionState !== z.ConnectionState.Connected ? Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`) : this.privReceivingMessageQueue.dequeue();
  }
  close(e) {
    if (this.privWebsocketClient)
      this.privConnectionState !== z.ConnectionState.Disconnected && this.privWebsocketClient.close(1e3, e || "Normal closure by client");
    else
      return Promise.resolve();
    return this.privDisconnectDeferral.promise;
  }
  get events() {
    return this.privConnectionEvents;
  }
  sendRawMessage(e) {
    try {
      if (!e)
        return Promise.resolve();
      if (this.onEvent(new z.ConnectionMessageSentEvent(this.privConnectionId, (/* @__PURE__ */ new Date()).toISOString(), e.Message)), this.isWebsocketOpen)
        this.privWebsocketClient.send(e.RawWebsocketMessage.payload);
      else
        return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + e.Message.id + " " + new Error().stack);
      return Promise.resolve();
    } catch (n) {
      return Promise.reject(`websocket send error: ${n}`);
    }
  }
  async onClose(e, n) {
    const r = `Connection closed. ${e}: ${n}`;
    this.privConnectionState = z.ConnectionState.Disconnected, this.privDisconnectDeferral.resolve(), await this.privReceivingMessageQueue.drainAndDispose(() => {
    }, r), await this.privSendMessageQueue.drainAndDispose((s) => {
      s.sendStatusDeferral.reject(r);
    }, r);
  }
  async processSendQueue() {
    for (; ; ) {
      const n = await this.privSendMessageQueue.dequeue();
      if (!n)
        return;
      try {
        await this.sendRawMessage(n), n.sendStatusDeferral.resolve();
      } catch (r) {
        n.sendStatusDeferral.reject(r);
      }
    }
  }
  onEvent(e) {
    this.privConnectionEvents.onEvent(e), z.Events.instance.onEvent(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getAgent() {
    const e = new y_.default.Agent(this.createConnection);
    return this.proxyInfo !== void 0 && this.proxyInfo.HostName !== void 0 && this.proxyInfo.Port > 0 && (e.proxyInfo = this.proxyInfo), e;
  }
  static GetProxyAgent(e) {
    const n = {
      host: e.HostName,
      port: e.Port
    };
    return e.UserName ? n.headers = {
      "Proxy-Authentication": "Basic " + new Buffer(`${e.UserName}:${e.Password === void 0 ? "" : e.Password}`).toString("base64")
    } : n.headers = {}, n.headers.requestOCSP = "true", new C_.default(n);
  }
  createConnection(e, n) {
    let r;
    if (n = {
      ...n,
      requestOCSP: !0,
      servername: n.host
    }, this.proxyInfo) {
      const o = ss.GetProxyAgent(this.proxyInfo);
      r = new Promise((a, i) => {
        o.callback(e, n, (c, u) => {
          c ? i(c) : a(u);
        });
      });
    } else
      n.secureEndpoint ? r = Promise.resolve(S_.connect(n)) : r = Promise.resolve(m_.connect(n));
    return r;
  }
  get isWebsocketOpen() {
    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
  }
}
gs.WebsocketMessageAdapter = ss;
ss.forceNpmWebSocket = !1;
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.WebsocketConnection = void 0;
const uc = O(), P_ = gs;
class E_ {
  constructor(e, n, r, s, o, a = !1, i) {
    if (this.privIsDisposed = !1, !e)
      throw new uc.ArgumentNullError("uri");
    if (!s)
      throw new uc.ArgumentNullError("messageFormatter");
    this.privMessageFormatter = s;
    let c = "", u = 0;
    if (n) {
      for (const p in n)
        if (p) {
          c += u === 0 && e.indexOf("?") === -1 ? "?" : "&";
          const d = encodeURIComponent(p);
          c += d;
          let l = n[p];
          l && (l = encodeURIComponent(l), c += `=${l}`), u++;
        }
    }
    if (r) {
      for (const p in r)
        if (p) {
          c += u === 0 && e.indexOf("?") === -1 ? "?" : "&";
          const d = encodeURIComponent(r[p]);
          c += `${p}=${d}`, u++;
        }
    }
    this.privUri = e + c, this.privId = i || uc.createNoDashGuid(), this.privConnectionMessageAdapter = new P_.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, o, r, a);
  }
  async dispose() {
    this.privIsDisposed = !0, this.privConnectionMessageAdapter && await this.privConnectionMessageAdapter.close();
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  get id() {
    return this.privId;
  }
  get uri() {
    return this.privUri;
  }
  state() {
    return this.privConnectionMessageAdapter.state;
  }
  open() {
    return this.privConnectionMessageAdapter.open();
  }
  send(e) {
    return this.privConnectionMessageAdapter.send(e);
  }
  read() {
    return this.privConnectionMessageAdapter.read();
  }
  get events() {
    return this.privConnectionMessageAdapter.events;
  }
}
Ko.WebsocketConnection = E_;
var Jo = {};
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.ReplayableAudioNode = void 0;
class T_ {
  constructor(e, n) {
    this.privBuffers = [], this.privReplayOffset = 0, this.privLastShrinkOffset = 0, this.privBufferStartOffset = 0, this.privBufferSerial = 0, this.privBufferedBytes = 0, this.privReplay = !1, this.privLastChunkAcquiredTime = 0, this.privAudioNode = e, this.privBytesPerSecond = n;
  }
  id() {
    return this.privAudioNode.id();
  }
  // Reads and returns the next chunk of audio buffer.
  // If replay of existing buffers are needed, read() will first seek and replay
  // existing content, and upoin completion it will read new content from the underlying
  // audio node, saving that content into the replayable buffers.
  read() {
    if (this.privReplay && this.privBuffers.length !== 0) {
      const e = this.privReplayOffset - this.privBufferStartOffset;
      let n = Math.round(e * this.privBytesPerSecond * 1e-7);
      n % 2 !== 0 && n++;
      let r = 0;
      for (; r < this.privBuffers.length && n >= this.privBuffers[r].chunk.buffer.byteLength; )
        n -= this.privBuffers[r++].chunk.buffer.byteLength;
      if (r < this.privBuffers.length) {
        const s = this.privBuffers[r].chunk.buffer.slice(n);
        return this.privReplayOffset += s.byteLength / this.privBytesPerSecond * 1e7, r === this.privBuffers.length - 1 && (this.privReplay = !1), Promise.resolve({
          buffer: s,
          isEnd: !1,
          timeReceived: this.privBuffers[r].chunk.timeReceived
        });
      }
    }
    return this.privAudioNode.read().then((e) => (e && e.buffer && (this.privBuffers.push(new w_(e, this.privBufferSerial++, this.privBufferedBytes)), this.privBufferedBytes += e.buffer.byteLength), e));
  }
  detach() {
    return this.privBuffers = void 0, this.privAudioNode.detach();
  }
  replay() {
    this.privBuffers && this.privBuffers.length !== 0 && (this.privReplay = !0, this.privReplayOffset = this.privLastShrinkOffset);
  }
  // Shrinks the existing audio buffers to start at the new offset, or at the
  // beginning of the buffer closest to the requested offset.
  // A replay request will start from the last shrink point.
  shrinkBuffers(e) {
    if (this.privBuffers === void 0 || this.privBuffers.length === 0)
      return;
    this.privLastShrinkOffset = e;
    const n = e - this.privBufferStartOffset;
    let r = Math.round(n * this.privBytesPerSecond * 1e-7), s = 0;
    for (; s < this.privBuffers.length && r >= this.privBuffers[s].chunk.buffer.byteLength; )
      r -= this.privBuffers[s++].chunk.buffer.byteLength;
    this.privBufferStartOffset = Math.round(e - r / this.privBytesPerSecond * 1e7), this.privBuffers = this.privBuffers.slice(s);
  }
  // Finds the time a buffer of audio was first seen by offset.
  findTimeAtOffset(e) {
    if (e < this.privBufferStartOffset || this.privBuffers === void 0)
      return 0;
    for (const n of this.privBuffers) {
      const r = n.byteOffset / this.privBytesPerSecond * 1e7, s = r + n.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
      if (e >= r && e <= s)
        return n.chunk.timeReceived;
    }
    return 0;
  }
}
Jo.ReplayableAudioNode = T_;
class w_ {
  constructor(e, n, r) {
    this.chunk = e, this.serial = n, this.byteOffset = r;
  }
}
var mr = {}, pc = {}, vt = {}, ms = {}, I_ = $ && $.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function() {
    return e[n];
  } });
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), b_ = $ && $.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), A_ = $ && $.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      n !== "default" && Object.hasOwnProperty.call(t, n) && I_(e, t, n);
  return b_(e, t), e;
};
Object.defineProperty(ms, "__esModule", { value: !0 });
ms.AudioFileWriter = void 0;
const Sr = A_(En), dc = D;
class M_ {
  constructor(e) {
    dc.Contracts.throwIfNullOrUndefined(Sr.openSync, `
File System access not available, please use Push or PullAudioOutputStream`), this.privFd = Sr.openSync(e, "w");
  }
  set format(e) {
    dc.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set"), this.privAudioFormat = e;
    let n = 0;
    this.privAudioFormat.hasHeader && (n = this.privAudioFormat.header.byteLength), this.privFd !== void 0 && (this.privWriteStream = Sr.createWriteStream("", { fd: this.privFd, start: n, autoClose: !1 }));
  }
  write(e) {
    dc.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing."), this.privWriteStream !== void 0 && this.privWriteStream.write(new Uint8Array(e.slice(0)));
  }
  close() {
    this.privFd !== void 0 && (this.privWriteStream.on("finish", () => {
      this.privAudioFormat.hasHeader && (this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten), Sr.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0)), Sr.closeSync(this.privFd), this.privFd = void 0;
    }), this.privWriteStream.end());
  }
  id() {
    return this.privId;
  }
}
ms.AudioFileWriter = M_;
var Ke = {}, xp;
function rf() {
  if (xp)
    return Ke;
  xp = 1, Object.defineProperty(Ke, "__esModule", { value: !0 }), Ke.PullAudioInputStreamImpl = Ke.PullAudioInputStream = Ke.PushAudioInputStreamImpl = Ke.PushAudioInputStream = Ke.AudioInputStream = void 0;
  const t = b(), e = O(), n = Ze, r = P(), s = Wt;
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */
    static createPushStream(d) {
      return a.create(d);
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */
    static createPullStream(d, l) {
      return c.create(d, l);
    }
  };
  Ke.AudioInputStream = o;
  class a extends o {
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */
    static create(d) {
      return new i(d);
    }
  }
  Ke.PushAudioInputStream = a;
  class i extends a {
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */
    constructor(d) {
      super(), d === void 0 ? this.privFormat = s.AudioStreamFormatImpl.getDefaultInputFormat() : this.privFormat = d, this.privEvents = new e.EventSource(), this.privId = n.createNoDashGuid(), this.privStream = new e.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(d) {
      this.privStream.writeStreamChunk({
        buffer: d,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new e.AudioSourceInitializingEvent(this.privId)), this.onEvent(new e.AudioSourceReadyEvent(this.privId));
    }
    async attach(d) {
      this.onEvent(new e.AudioStreamNodeAttachingEvent(this.privId, d)), await this.turnOn();
      const l = this.privStream;
      return this.onEvent(new e.AudioStreamNodeAttachedEvent(this.privId, d)), {
        detach: async () => (this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d)), this.turnOff()),
        id: () => d,
        read: () => l.read()
      };
    }
    detach(d) {
      this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: t.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PushStream",
        samplerate: this.privFormat.samplesPerSec,
        type: t.type.Stream
      });
    }
    onEvent(d) {
      this.privEvents.onEvent(d), e.Events.instance.onEvent(d);
    }
    toBuffer(d) {
      const l = Buffer.alloc(d.byteLength), h = new Uint8Array(d);
      for (let v = 0; v < l.length; ++v)
        l[v] = h[v];
      return l;
    }
  }
  Ke.PushAudioInputStreamImpl = i;
  class c extends o {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */
    static create(d, l) {
      return new u(d, l);
    }
  }
  Ke.PullAudioInputStream = c;
  class u extends c {
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */
    constructor(d, l) {
      super(), l === void 0 ? this.privFormat = r.AudioStreamFormat.getDefaultInputFormat() : this.privFormat = l, this.privEvents = new e.EventSource(), this.privId = n.createNoDashGuid(), this.privCallback = d, this.privIsClosed = !1, this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privIsClosed = !0, this.privCallback.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new e.AudioSourceInitializingEvent(this.privId)), this.onEvent(new e.AudioSourceReadyEvent(this.privId));
    }
    async attach(d) {
      return this.onEvent(new e.AudioStreamNodeAttachingEvent(this.privId, d)), await this.turnOn(), this.onEvent(new e.AudioStreamNodeAttachedEvent(this.privId, d)), {
        detach: () => (this.privCallback.close(), this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d)), this.turnOff()),
        id: () => d,
        read: () => {
          let l = 0, h;
          for (; l < this.privBufferSize; ) {
            const v = new ArrayBuffer(this.privBufferSize - l), g = this.privCallback.read(v);
            if (h === void 0 ? h = v : new Int8Array(h).set(new Int8Array(v), l), g === 0)
              break;
            l += g;
          }
          return Promise.resolve({
            buffer: h.slice(0, l),
            isEnd: this.privIsClosed || l === 0,
            timeReceived: Date.now()
          });
        }
      };
    }
    detach(d) {
      this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: t.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PullStream",
        samplerate: this.privFormat.samplesPerSec,
        type: t.type.Stream
      });
    }
    onEvent(d) {
      this.privEvents.onEvent(d), e.Events.instance.onEvent(d);
    }
  }
  return Ke.PullAudioInputStreamImpl = u, Ke;
}
var Re = {}, Vt = {}, _u = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.SpeechSynthesisOutputFormat = void 0, function(e) {
    e[e.Raw8Khz8BitMonoMULaw = 0] = "Raw8Khz8BitMonoMULaw", e[e.Riff16Khz16KbpsMonoSiren = 1] = "Riff16Khz16KbpsMonoSiren", e[e.Audio16Khz16KbpsMonoSiren = 2] = "Audio16Khz16KbpsMonoSiren", e[e.Audio16Khz32KBitRateMonoMp3 = 3] = "Audio16Khz32KBitRateMonoMp3", e[e.Audio16Khz128KBitRateMonoMp3 = 4] = "Audio16Khz128KBitRateMonoMp3", e[e.Audio16Khz64KBitRateMonoMp3 = 5] = "Audio16Khz64KBitRateMonoMp3", e[e.Audio24Khz48KBitRateMonoMp3 = 6] = "Audio24Khz48KBitRateMonoMp3", e[e.Audio24Khz96KBitRateMonoMp3 = 7] = "Audio24Khz96KBitRateMonoMp3", e[e.Audio24Khz160KBitRateMonoMp3 = 8] = "Audio24Khz160KBitRateMonoMp3", e[e.Raw16Khz16BitMonoTrueSilk = 9] = "Raw16Khz16BitMonoTrueSilk", e[e.Riff16Khz16BitMonoPcm = 10] = "Riff16Khz16BitMonoPcm", e[e.Riff8Khz16BitMonoPcm = 11] = "Riff8Khz16BitMonoPcm", e[e.Riff24Khz16BitMonoPcm = 12] = "Riff24Khz16BitMonoPcm", e[e.Riff8Khz8BitMonoMULaw = 13] = "Riff8Khz8BitMonoMULaw", e[e.Raw16Khz16BitMonoPcm = 14] = "Raw16Khz16BitMonoPcm", e[e.Raw24Khz16BitMonoPcm = 15] = "Raw24Khz16BitMonoPcm", e[e.Raw8Khz16BitMonoPcm = 16] = "Raw8Khz16BitMonoPcm", e[e.Ogg16Khz16BitMonoOpus = 17] = "Ogg16Khz16BitMonoOpus", e[e.Ogg24Khz16BitMonoOpus = 18] = "Ogg24Khz16BitMonoOpus", e[e.Raw48Khz16BitMonoPcm = 19] = "Raw48Khz16BitMonoPcm", e[e.Riff48Khz16BitMonoPcm = 20] = "Riff48Khz16BitMonoPcm", e[e.Audio48Khz96KBitRateMonoMp3 = 21] = "Audio48Khz96KBitRateMonoMp3", e[e.Audio48Khz192KBitRateMonoMp3 = 22] = "Audio48Khz192KBitRateMonoMp3", e[e.Ogg48Khz16BitMonoOpus = 23] = "Ogg48Khz16BitMonoOpus", e[e.Webm16Khz16BitMonoOpus = 24] = "Webm16Khz16BitMonoOpus", e[e.Webm24Khz16BitMonoOpus = 25] = "Webm24Khz16BitMonoOpus", e[e.Raw24Khz16BitMonoTrueSilk = 26] = "Raw24Khz16BitMonoTrueSilk", e[e.Raw8Khz8BitMonoALaw = 27] = "Raw8Khz8BitMonoALaw", e[e.Riff8Khz8BitMonoALaw = 28] = "Riff8Khz8BitMonoALaw", e[e.Webm24Khz16Bit24KbpsMonoOpus = 29] = "Webm24Khz16Bit24KbpsMonoOpus", e[e.Audio16Khz16Bit32KbpsMonoOpus = 30] = "Audio16Khz16Bit32KbpsMonoOpus", e[e.Audio24Khz16Bit48KbpsMonoOpus = 31] = "Audio24Khz16Bit48KbpsMonoOpus", e[e.Audio24Khz16Bit24KbpsMonoOpus = 32] = "Audio24Khz16Bit24KbpsMonoOpus", e[e.Raw22050Hz16BitMonoPcm = 33] = "Raw22050Hz16BitMonoPcm", e[e.Riff22050Hz16BitMonoPcm = 34] = "Riff22050Hz16BitMonoPcm", e[e.Raw44100Hz16BitMonoPcm = 35] = "Raw44100Hz16BitMonoPcm", e[e.Riff44100Hz16BitMonoPcm = 36] = "Riff44100Hz16BitMonoPcm", e[e.AmrWb16000Hz = 37] = "AmrWb16000Hz", e[e.G72216Khz64Kbps = 38] = "G72216Khz64Kbps";
  }(t.SpeechSynthesisOutputFormat || (t.SpeechSynthesisOutputFormat = {}));
})(_u);
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.AudioOutputFormatImpl = void 0;
const x = _u, j = Wt;
class k extends j.AudioStreamFormatImpl {
  /**
   * Creates an instance with the given values.
   * @constructor
   * @param formatTag
   * @param {number} channels - Number of channels.
   * @param {number} samplesPerSec - Samples per second.
   * @param {number} avgBytesPerSec - Average bytes per second.
   * @param {number} blockAlign - Block alignment.
   * @param {number} bitsPerSample - Bits per sample.
   * @param {string} audioFormatString - Audio format string
   * @param {string} requestAudioFormatString - Audio format string sent to service.
   * @param {boolean} hasHeader - If the format has header or not.
   */
  constructor(e, n, r, s, o, a, i, c, u) {
    super(r, a, n, e), this.formatTag = e, this.avgBytesPerSec = s, this.blockAlign = o, this.priAudioFormatString = i, this.priRequestAudioFormatString = c, this.priHasHeader = u;
  }
  static fromSpeechSynthesisOutputFormat(e) {
    return e === void 0 ? k.getDefaultOutputFormat() : k.fromSpeechSynthesisOutputFormatString(k.SpeechSynthesisOutputFormatToString[e]);
  }
  static fromSpeechSynthesisOutputFormatString(e) {
    switch (e) {
      case "raw-8khz-8bit-mono-mulaw":
        return new k(j.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, e, e, !1);
      case "riff-16khz-16kbps-mono-siren":
        return new k(j.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, e, "audio-16khz-16kbps-mono-siren", !0);
      case "audio-16khz-16kbps-mono-siren":
        return new k(j.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, e, e, !1);
      case "audio-16khz-32kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 16e3, 4096, 2, 16, e, e, !1);
      case "audio-16khz-128kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 16e3, 16384, 2, 16, e, e, !1);
      case "audio-16khz-64kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 16e3, 8192, 2, 16, e, e, !1);
      case "audio-24khz-48kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 24e3, 6144, 2, 16, e, e, !1);
      case "audio-24khz-96kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 24e3, 12288, 2, 16, e, e, !1);
      case "audio-24khz-160kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 24e3, 20480, 2, 16, e, e, !1);
      case "raw-16khz-16bit-mono-truesilk":
        return new k(j.AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, e, e, !1);
      case "riff-8khz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, e, "raw-8khz-16bit-mono-pcm", !0);
      case "riff-24khz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, e, "raw-24khz-16bit-mono-pcm", !0);
      case "riff-8khz-8bit-mono-mulaw":
        return new k(j.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, e, "raw-8khz-8bit-mono-mulaw", !0);
      case "raw-16khz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, e, "raw-16khz-16bit-mono-pcm", !1);
      case "raw-24khz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, e, "raw-24khz-16bit-mono-pcm", !1);
      case "raw-8khz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, e, "raw-8khz-16bit-mono-pcm", !1);
      case "ogg-16khz-16bit-mono-opus":
        return new k(j.AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, e, e, !1);
      case "ogg-24khz-16bit-mono-opus":
        return new k(j.AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, e, e, !1);
      case "raw-48khz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, e, "raw-48khz-16bit-mono-pcm", !1);
      case "riff-48khz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, e, "raw-48khz-16bit-mono-pcm", !0);
      case "audio-48khz-96kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 48e3, 12288, 2, 16, e, e, !1);
      case "audio-48khz-192kbitrate-mono-mp3":
        return new k(j.AudioFormatTag.MP3, 1, 48e3, 24576, 2, 16, e, e, !1);
      case "ogg-48khz-16bit-mono-opus":
        return new k(j.AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, e, e, !1);
      case "webm-16khz-16bit-mono-opus":
        return new k(j.AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, e, e, !1);
      case "webm-24khz-16bit-mono-opus":
        return new k(j.AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, e, e, !1);
      case "webm-24khz-16bit-24kbps-mono-opus":
        return new k(j.AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, e, e, !1);
      case "audio-16khz-16bit-32kbps-mono-opus":
        return new k(j.AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, e, e, !1);
      case "audio-24khz-16bit-48kbps-mono-opus":
        return new k(j.AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, e, e, !1);
      case "audio-24khz-16bit-24kbps-mono-opus":
        return new k(j.AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, e, e, !1);
      case "audio-24khz-16bit-mono-flac":
        return new k(j.AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, e, e, !1);
      case "audio-48khz-16bit-mono-flac":
        return new k(j.AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, e, e, !1);
      case "raw-24khz-16bit-mono-truesilk":
        return new k(j.AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, e, e, !1);
      case "raw-8khz-8bit-mono-alaw":
        return new k(j.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, e, e, !1);
      case "riff-8khz-8bit-mono-alaw":
        return new k(j.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, e, "raw-8khz-8bit-mono-alaw", !0);
      case "raw-22050hz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, e, e, !1);
      case "riff-22050hz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, e, "raw-22050hz-16bit-mono-pcm", !0);
      case "raw-44100hz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, e, e, !1);
      case "riff-44100hz-16bit-mono-pcm":
        return new k(j.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, e, "raw-44100hz-16bit-mono-pcm", !0);
      case "amr-wb-16000h":
        return new k(j.AudioFormatTag.AMR_WB, 1, 16e3, 3052, 2, 16, e, e, !1);
      case "g722-16khz-64kbps":
        return new k(j.AudioFormatTag.G722, 1, 16e3, 8e3, 2, 16, e, e, !1);
      case "riff-16khz-16bit-mono-pcm":
      default:
        return new k(j.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", !0);
    }
  }
  static getDefaultOutputFormat() {
    return k.fromSpeechSynthesisOutputFormatString(typeof window < "u" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
  }
  /**
   * Specifies if this audio output format has a header
   * @boolean AudioOutputFormatImpl.prototype.hasHeader
   * @function
   * @public
   */
  get hasHeader() {
    return this.priHasHeader;
  }
  /**
   * Specifies the header of this format
   * @ArrayBuffer AudioOutputFormatImpl.prototype.header
   * @function
   * @public
   */
  get header() {
    if (this.hasHeader)
      return this.privHeader;
  }
  /**
   * Updates the header based on the audio length
   * @member AudioOutputFormatImpl.updateHeader
   * @function
   * @public
   * @param {number} audioLength - the audio length
   */
  updateHeader(e) {
    if (this.priHasHeader) {
      const n = new DataView(this.privHeader);
      n.setUint32(4, e + this.privHeader.byteLength - 8, !0), n.setUint32(40, e, !0);
    }
  }
  /**
   * Specifies the audio format string to be sent to the service
   * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
   * @function
   * @public
   */
  get requestAudioFormatString() {
    return this.priRequestAudioFormatString;
  }
  /**
   * Adds audio header
   * @param audio the raw audio without header
   * @returns the audio with header if applicable
   */
  addHeader(e) {
    if (!this.hasHeader)
      return e;
    this.updateHeader(e.byteLength);
    const n = new Uint8Array(e.byteLength + this.header.byteLength);
    return n.set(new Uint8Array(this.header), 0), n.set(new Uint8Array(e), this.header.byteLength), n.buffer;
  }
}
Vt.AudioOutputFormatImpl = k;
k.SpeechSynthesisOutputFormatToString = {
  [x.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
  [x.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
  [x.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
  [x.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
  [x.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
  [x.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
  [x.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
  [x.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
  [x.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
  [x.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
  [x.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
  [x.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
  [x.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
  [x.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
  [x.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
  [x.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
  [x.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
  [x.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
  [x.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
  [x.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
  [x.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
};
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.PushAudioOutputStreamImpl = Re.PushAudioOutputStream = Re.PullAudioOutputStreamImpl = Re.PullAudioOutputStream = Re.AudioOutputStream = void 0;
const jc = O(), O_ = D, k_ = Vt;
class Ru {
  /**
   * Creates and initializes an instance.
   * @constructor
   */
  constructor() {
  }
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member AudioOutputStream.createPullStream
   * @function
   * @public
   * @returns {PullAudioOutputStream} The audio output stream being created.
   */
  static createPullStream() {
    return Pu.create();
  }
}
Re.AudioOutputStream = Ru;
class Pu extends Ru {
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member PullAudioOutputStream.create
   * @function
   * @public
   * @returns {PullAudioOutputStream} The push audio output stream being created.
   */
  static create() {
    return new sf();
  }
}
Re.PullAudioOutputStream = Pu;
class sf extends Pu {
  /**
   * Creates and initializes an instance with the given values.
   * @constructor
   */
  constructor() {
    super(), this.privId = jc.createNoDashGuid(), this.privStream = new jc.Stream();
  }
  /**
   * Sets the format information to the stream. For internal use only.
   * @param {AudioStreamFormat} format - the format to be set.
   */
  set format(e) {
    e == null && (this.privFormat = k_.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privFormat = e;
  }
  /**
   * Format information for the audio
   */
  get format() {
    return this.privFormat;
  }
  /**
   * Checks if the stream is closed
   * @member PullAudioOutputStreamImpl.prototype.isClosed
   * @property
   * @public
   */
  get isClosed() {
    return this.privStream.isClosed;
  }
  /**
   * Gets the id of the stream
   * @member PullAudioOutputStreamImpl.prototype.id
   * @property
   * @public
   */
  id() {
    return this.privId;
  }
  /**
   * Reads audio data from the internal buffer.
   * @member PullAudioOutputStreamImpl.prototype.read
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
   * @returns {Promise<number>} - Audio buffer length has been read.
   */
  async read(e) {
    const n = new Int8Array(e);
    let r = 0;
    if (this.privLastChunkView !== void 0) {
      if (this.privLastChunkView.length > e.byteLength)
        return n.set(this.privLastChunkView.slice(0, e.byteLength)), this.privLastChunkView = this.privLastChunkView.slice(e.byteLength), Promise.resolve(e.byteLength);
      n.set(this.privLastChunkView), r = this.privLastChunkView.length, this.privLastChunkView = void 0;
    }
    for (; r < e.byteLength && !this.privStream.isReadEnded; ) {
      const s = await this.privStream.read();
      if (s !== void 0 && !s.isEnd) {
        let o;
        s.buffer.byteLength > e.byteLength - r ? (o = s.buffer.slice(0, e.byteLength - r), this.privLastChunkView = new Int8Array(s.buffer.slice(e.byteLength - r))) : o = s.buffer, n.set(new Int8Array(o), r), r += o.byteLength;
      } else
        this.privStream.readEnded();
    }
    return r;
  }
  /**
   * Writes the audio data specified by making an internal copy of the data.
   * @member PullAudioOutputStreamImpl.prototype.write
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
   */
  write(e) {
    O_.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing"), this.privStream.writeStreamChunk({
      buffer: e,
      isEnd: !1,
      timeReceived: Date.now()
    });
  }
  /**
   * Closes the stream.
   * @member PullAudioOutputStreamImpl.prototype.close
   * @function
   * @public
   */
  close() {
    this.privStream.close();
  }
}
Re.PullAudioOutputStreamImpl = sf;
class of extends Ru {
  /**
   * Creates and initializes and instance.
   * @constructor
   */
  constructor() {
    super();
  }
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * write() and close() methods.
   * @member PushAudioOutputStream.create
   * @function
   * @public
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   * @returns {PushAudioOutputStream} The push audio output stream being created.
   */
  static create(e) {
    return new af(e);
  }
}
Re.PushAudioOutputStream = of;
class af extends of {
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * read() and close() methods.
   * @constructor
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   */
  constructor(e) {
    super(), this.privId = jc.createNoDashGuid(), this.privCallback = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  set format(e) {
  }
  write(e) {
    this.privCallback.write && this.privCallback.write(e);
  }
  close() {
    this.privCallback.close && this.privCallback.close();
  }
  id() {
    return this.privId;
  }
}
Re.PushAudioOutputStreamImpl = af;
var Bp;
function uf() {
  if (Bp)
    return vt;
  Bp = 1, Object.defineProperty(vt, "__esModule", { value: !0 }), vt.AudioOutputConfigImpl = vt.AudioConfigImpl = vt.AudioConfig = void 0;
  const t = Se(), e = D, n = P(), r = ms, s = rf(), o = Re;
  let a = class cf {
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromDefaultMicrophoneInput() {
      const p = new t.PcmRecorder(!0);
      return new i(new t.MicAudioSource(p));
    }
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromMicrophoneInput(p) {
      const d = new t.PcmRecorder(!0);
      return new i(new t.MicAudioSource(d, p));
    }
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromWavFileInput(p, d = "unnamedBuffer.wav") {
      return new i(new t.FileAudioSource(p, d));
    }
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromStreamInput(p) {
      if (p instanceof n.PullAudioInputStreamCallback)
        return new i(new s.PullAudioInputStreamImpl(p));
      if (p instanceof n.AudioInputStream)
        return new i(p);
      if (typeof MediaStream < "u" && p instanceof MediaStream) {
        const d = new t.PcmRecorder(!1);
        return new i(new t.MicAudioSource(d, null, null, p));
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromDefaultSpeakerOutput() {
      return new c(new n.SpeakerAudioDestination());
    }
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */
    static fromSpeakerOutput(p) {
      if (p === void 0)
        return cf.fromDefaultSpeakerOutput();
      if (p instanceof n.SpeakerAudioDestination)
        return new c(p);
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromAudioFileOutput(p) {
      return new c(new r.AudioFileWriter(p));
    }
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromStreamOutput(p) {
      if (p instanceof n.PushAudioOutputStreamCallback)
        return new c(new o.PushAudioOutputStreamImpl(p));
      if (p instanceof n.PushAudioOutputStream)
        return new c(p);
      if (p instanceof n.PullAudioOutputStream)
        return new c(p);
      throw new Error("Not Supported Type");
    }
  };
  vt.AudioConfig = a;
  class i extends a {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */
    constructor(p) {
      super(), this.privSource = p;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privSource.format;
    }
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */
    close(p, d) {
      this.privSource.turnOff().then(() => {
        p && p();
      }, (l) => {
        d && d(l);
      });
    }
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */
    id() {
      return this.privSource.id();
    }
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOn() {
      return this.privSource.turnOn();
    }
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */
    attach(p) {
      return this.privSource.attach(p);
    }
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */
    detach(p) {
      return this.privSource.detach(p);
    }
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOff() {
      return this.privSource.turnOff();
    }
    /**
     * @member AudioConfigImpl.prototype.events
     * @function
     * @public
     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
     */
    get events() {
      return this.privSource.events;
    }
    setProperty(p, d) {
      if (e.Contracts.throwIfNull(d, "value"), this.privSource.setProperty !== void 0)
        this.privSource.setProperty(p, d);
      else
        throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty(p, d) {
      if (this.privSource.getProperty !== void 0)
        return this.privSource.getProperty(p, d);
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
    get deviceInfo() {
      return this.privSource.deviceInfo;
    }
  }
  vt.AudioConfigImpl = i;
  class c extends a {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */
    constructor(p) {
      super(), this.privDestination = p;
    }
    set format(p) {
      this.privDestination.format = p;
    }
    write(p) {
      this.privDestination.write(p);
    }
    close() {
      this.privDestination.close();
    }
    id() {
      return this.privDestination.id();
    }
    setProperty() {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty() {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
  }
  return vt.AudioOutputConfigImpl = c, vt;
}
var pf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CancellationReason = void 0, function(e) {
    e[e.Error = 0] = "Error", e[e.EndOfStream = 1] = "EndOfStream";
  }(t.CancellationReason || (t.CancellationReason = {}));
})(pf);
var Go = {};
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.PullAudioInputStreamCallback = void 0;
class D_ {
}
Go.PullAudioInputStreamCallback = D_;
var Qo = {};
Object.defineProperty(Qo, "__esModule", { value: !0 });
Qo.PushAudioOutputStreamCallback = void 0;
class N_ {
}
Qo.PushAudioOutputStreamCallback = N_;
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.KeywordRecognitionModel = void 0;
const qp = D;
class L_ {
  /**
   * Create and initializes a new instance.
   * @constructor
   */
  constructor() {
    this.privDisposed = !1;
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromFile
   * @function
   * @public
   * @param {string} fileName - A string that represents file name for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model
   * will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromFile(e) {
    throw qp.Contracts.throwIfFileDoesNotExist(e, "fileName"), new Error("Not yet implemented.");
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromStream
   * @function
   * @public
   * @param {string} file - A File that represents file for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromStream(e) {
    throw qp.Contracts.throwIfNull(e, "file"), new Error("Not yet implemented.");
  }
  /**
   * Dispose of associated resources.
   * @member KeywordRecognitionModel.prototype.close
   * @function
   * @public
   */
  close() {
    this.privDisposed || (this.privDisposed = !0);
  }
}
Yo.KeywordRecognitionModel = L_;
var Zo = {};
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.SessionEventArgs = void 0;
class z_ {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionId - The session id.
   */
  constructor(e) {
    this.privSessionId = e;
  }
  /**
   * Represents the session identifier.
   * @member SessionEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} Represents the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
}
Zo.SessionEventArgs = z_;
var yr = {}, Fp;
function j_() {
  if (Fp)
    return yr;
  Fp = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.RecognitionEventArgs = void 0;
  const t = P();
  let e = class extends t.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s) {
      super(s), this.privOffset = r;
    }
    /**
     * Represents the message offset
     * @member RecognitionEventArgs.prototype.offset
     * @function
     * @public
     */
    get offset() {
      return this.privOffset;
    }
  };
  return yr.RecognitionEventArgs = e, yr;
}
var df = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.OutputFormat = void 0, function(e) {
    e[e.Simple = 0] = "Simple", e[e.Detailed = 1] = "Detailed";
  }(t.OutputFormat || (t.OutputFormat = {}));
})(df);
var Cr = {}, $p;
function x_() {
  if ($p)
    return Cr;
  $p = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.IntentRecognitionEventArgs = void 0;
  const t = P();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */
    constructor(r, s, o) {
      super(s, o), this.privResult = r;
    }
    /**
     * Represents the intent recognition result.
     * @member IntentRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {IntentRecognitionResult} Represents the intent recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Cr.IntentRecognitionEventArgs = e, Cr;
}
var Xo = {};
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.RecognitionResult = void 0;
class B_ {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} text - The recognized text.
   * @param {number} duration - The duration.
   * @param {number} offset - The offset into the stream.
   * @param {string} language - Primary Language detected, if provided.
   * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param {string} errorDetails - Error details, if provided.
   * @param {string} json - Additional Json, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(e, n, r, s, o, a, i, c, u, p) {
    this.privResultId = e, this.privReason = n, this.privText = r, this.privDuration = s, this.privOffset = o, this.privLanguage = a, this.privLanguageDetectionConfidence = i, this.privErrorDetails = c, this.privJson = u, this.privProperties = p;
  }
  /**
   * Specifies the result identifier.
   * @member RecognitionResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member RecognitionResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * Presents the recognized text in the result.
   * @member RecognitionResult.prototype.text
   * @function
   * @public
   * @returns {string} Presents the recognized text in the result.
   */
  get text() {
    return this.privText;
  }
  /**
   * Duration of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.duration
   * @function
   * @public
   * @returns {number} Duration of recognized speech in 100 nano second increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Offset of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.offset
   * @function
   * @public
   * @returns {number} Offset of recognized speech in 100 nano second increments.
   */
  get offset() {
    return this.privOffset;
  }
  /**
   * Primary Language detected.
   * @member RecognitionResult.prototype.language
   * @function
   * @public
   * @returns {string} language detected.
   */
  get language() {
    return this.privLanguage;
  }
  /**
   * Primary Language detection confidence (Unknown, Low, Medium, High).
   * @member RecognitionResult.prototype.languageDetectionConfidence
   * @function
   * @public
   * @returns {string} detection confidence strength.
   */
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member RecognitionResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * A string containing Json serialized recognition result as it was received from the service.
   * @member RecognitionResult.prototype.json
   * @function
   * @private
   * @returns {string} Json serialized representation of the result.
   */
  get json() {
    return this.privJson;
  }
  /**
   * The set of properties exposed in the result.
   * @member RecognitionResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
Xo.RecognitionResult = B_;
var _r = {}, Up;
function q_() {
  if (Up)
    return _r;
  Up = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.SpeechRecognitionResult = void 0;
  const t = P();
  let e = class extends t.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(r, s, o, a, i, c, u, d, l, h), this.privSpeakerId = p;
    }
    /**
     * speaker id from conversation transcription/id scenarios
     * @member SpeechRecognitionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return _r.SpeechRecognitionResult = e, _r;
}
var Rr = {}, Hp;
function F_() {
  if (Hp)
    return Rr;
  Hp = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.IntentRecognitionResult = void 0;
  const t = P();
  let e = class extends t.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(s, o, a, i, c, u, p, void 0, d, l, h), this.privIntentId = r;
    }
    /**
     * A String that represents the intent identifier being recognized.
     * @member IntentRecognitionResult.prototype.intentId
     * @function
     * @public
     * @returns {string} A String that represents the intent identifier being recognized.
     */
    get intentId() {
      return this.privIntentId;
    }
  };
  return Rr.IntentRecognitionResult = e, Rr;
}
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.LanguageUnderstandingModelImpl = qn.LanguageUnderstandingModel = void 0;
const Dn = D;
class lf {
  /**
   * Creates and initializes a new instance
   * @constructor
   */
  constructor() {
  }
  /**
   * Creates an language understanding model using the specified endpoint.
   * @member LanguageUnderstandingModel.fromEndpoint
   * @function
   * @public
   * @param {URL} uri - A String that represents the endpoint of the language understanding model.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromEndpoint(e) {
    Dn.Contracts.throwIfNull(e, "uri"), Dn.Contracts.throwIfNullOrWhitespace(e.hostname, "uri");
    const n = new eo(), r = e.host.indexOf(".");
    if (r === -1)
      throw new Error("Could not determine region from endpoint");
    n.region = e.host.substr(0, r);
    const s = e.pathname.lastIndexOf("/") + 1;
    if (s === -1)
      throw new Error("Could not determine appId from endpoint");
    if (n.appId = e.pathname.substr(s), n.subscriptionKey = e.searchParams.get("subscription-key"), n.subscriptionKey === void 0)
      throw new Error("Could not determine subscription key from endpoint");
    return n;
  }
  /**
   * Creates an language understanding model using the application id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromAppId
   * @function
   * @public
   * @param {string} appId - A String that represents the application id of Language Understanding service.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromAppId(e) {
    Dn.Contracts.throwIfNullOrWhitespace(e, "appId");
    const n = new eo();
    return n.appId = e, n;
  }
  /**
   * Creates a language understanding model using hostname, subscription key and application
   * id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromSubscription
   * @function
   * @public
   * @param {string} subscriptionKey - A String that represents the subscription key of
   * Language Understanding service.
   * @param {string} appId - A String that represents the application id of Language
   * Understanding service.
   * @param {LanguageUnderstandingModel} region - A String that represents the region
   * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromSubscription(e, n, r) {
    Dn.Contracts.throwIfNullOrWhitespace(e, "subscriptionKey"), Dn.Contracts.throwIfNullOrWhitespace(n, "appId"), Dn.Contracts.throwIfNullOrWhitespace(r, "region");
    const s = new eo();
    return s.appId = n, s.region = r, s.subscriptionKey = e, s;
  }
}
qn.LanguageUnderstandingModel = lf;
class eo extends lf {
}
qn.LanguageUnderstandingModelImpl = eo;
var ft = {}, Wp;
function $_() {
  if (Wp)
    return ft;
  Wp = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.MeetingTranscriptionEventArgs = ft.ConversationTranscriptionEventArgs = ft.SpeechRecognitionEventArgs = void 0;
  const t = P();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, a, i) {
      super(a, i), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @member SpeechRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  ft.SpeechRecognitionEventArgs = e;
  class n extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, a, i) {
      super(a, i), this.privResult = o;
    }
    /**
     * Specifies the transcription result.
     * @member ConversationTranscription1EventArgs.prototype.result
     * @function
     * @public
     * @returns {ConversationTranscriptionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  }
  ft.ConversationTranscriptionEventArgs = n;
  class r extends e {
  }
  return ft.MeetingTranscriptionEventArgs = r, ft;
}
var Pr = {}, Er = {}, Vp;
function Ss() {
  if (Vp)
    return Er;
  Vp = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.CancellationEventArgsBase = void 0;
  const t = P();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s, o, a, i) {
      super(a, i), this.privReason = r, this.privErrorDetails = s, this.privErrorCode = o;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationEventArgsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful operation.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful operation, provides details of the occurred error.
     * @member CancellationEventArgsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return Er.CancellationEventArgsBase = e, Er;
}
var Kp;
function U_() {
  if (Kp)
    return Pr;
  Kp = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.SpeechRecognitionCanceledEventArgs = void 0;
  const t = Ss();
  let e = class extends t.CancellationEventArgsBase {
  };
  return Pr.SpeechRecognitionCanceledEventArgs = e, Pr;
}
var Tr = {}, Jp;
function H_() {
  if (Jp)
    return Tr;
  Jp = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.TranslationRecognitionEventArgs = void 0;
  const t = P();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s, o) {
      super(s, o), this.privResult = r;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Tr.TranslationRecognitionEventArgs = e, Tr;
}
var wr = {}, Gp;
function W_() {
  if (Gp)
    return wr;
  Gp = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.TranslationSynthesisEventArgs = void 0;
  const t = P();
  let e = class extends t.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s) {
      super(s), this.privResult = r;
    }
    /**
     * Specifies the translation synthesis result.
     * @member TranslationSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return wr.TranslationSynthesisEventArgs = e, wr;
}
var Ir = {}, Qp;
function vf() {
  if (Qp)
    return Ir;
  Qp = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.TranslationRecognitionResult = void 0;
  const t = P();
  let e = class hf extends t.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(s, o, a, i, c, u, p, void 0, d, l, h), this.privTranslations = r;
    }
    static fromSpeechRecognitionResult(r) {
      return new hf(void 0, r.resultId, r.reason, r.text, r.duration, r.offset, r.language, r.languageDetectionConfidence, r.errorDetails, r.json, r.properties);
    }
    /**
     * Presents the translation results. Each item in the dictionary represents
     * a translation result in one of target languages, where the key is the name
     * of the target language, in BCP-47 format, and the value is the translation
     * text in the specified language.
     * @member TranslationRecognitionResult.prototype.translations
     * @function
     * @public
     * @returns {Translations} the current translation map that holds all translations requested.
     */
    get translations() {
      return this.privTranslations;
    }
  };
  return Ir.TranslationRecognitionResult = e, Ir;
}
var ea = {};
Object.defineProperty(ea, "__esModule", { value: !0 });
ea.TranslationSynthesisResult = void 0;
class V_ {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {ResultReason} reason - The synthesis reason.
   * @param {ArrayBuffer} audio - The audio data.
   */
  constructor(e, n) {
    this.privReason = e, this.privAudio = n;
  }
  /**
   * Translated text in the target language.
   * @member TranslationSynthesisResult.prototype.audio
   * @function
   * @public
   * @returns {ArrayBuffer} Translated audio in the target language.
   */
  get audio() {
    return this.privAudio;
  }
  /**
   * The synthesis status.
   * @member TranslationSynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} The synthesis status.
   */
  get reason() {
    return this.privReason;
  }
}
ea.TranslationSynthesisResult = V_;
var ff = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ResultReason = void 0, function(e) {
    e[e.NoMatch = 0] = "NoMatch", e[e.Canceled = 1] = "Canceled", e[e.RecognizingSpeech = 2] = "RecognizingSpeech", e[e.RecognizedSpeech = 3] = "RecognizedSpeech", e[e.RecognizedKeyword = 4] = "RecognizedKeyword", e[e.RecognizingIntent = 5] = "RecognizingIntent", e[e.RecognizedIntent = 6] = "RecognizedIntent", e[e.TranslatingSpeech = 7] = "TranslatingSpeech", e[e.TranslatedSpeech = 8] = "TranslatedSpeech", e[e.SynthesizingAudio = 9] = "SynthesizingAudio", e[e.SynthesizingAudioCompleted = 10] = "SynthesizingAudioCompleted", e[e.SynthesizingAudioStarted = 11] = "SynthesizingAudioStarted", e[e.EnrollingVoiceProfile = 12] = "EnrollingVoiceProfile", e[e.EnrolledVoiceProfile = 13] = "EnrolledVoiceProfile", e[e.RecognizedSpeakers = 14] = "RecognizedSpeakers", e[e.RecognizedSpeaker = 15] = "RecognizedSpeaker", e[e.ResetVoiceProfile = 16] = "ResetVoiceProfile", e[e.DeletedVoiceProfile = 17] = "DeletedVoiceProfile", e[e.VoicesListRetrieved = 18] = "VoicesListRetrieved", e[e.TranslatingParticipantSpeech = 19] = "TranslatingParticipantSpeech", e[e.TranslatedParticipantSpeech = 20] = "TranslatedParticipantSpeech", e[e.TranslatedInstantMessage = 21] = "TranslatedInstantMessage", e[e.TranslatedParticipantInstantMessage = 22] = "TranslatedParticipantInstantMessage";
  }(t.ResultReason || (t.ResultReason = {}));
})(ff);
var Kt = {}, Yp;
function K_() {
  if (Yp)
    return Kt;
  Yp = 1, Object.defineProperty(Kt, "__esModule", { value: !0 }), Kt.SpeechConfigImpl = Kt.SpeechConfig = void 0;
  const t = b(), e = D, n = P();
  let r = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */
    static fromSubscription(a, i) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c.setProperty(n.PropertyId.SpeechServiceConnection_IntentRegion, i), c.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), c;
    }
    /**
     * Creates an instance of the speech config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * For example, if language is defined in the uri as query parameter "language=de-DE", and also set by
     * SpeechConfig.speechRecognitionLanguage = "en-US", the language setting in uri takes precedence,
     * and the effective language is "de-DE". Only the parameters that are not specified in the
     * endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromEndpoint(a, i) {
      e.Contracts.throwIfNull(a, "endpoint");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Endpoint, a.href), i !== void 0 && c.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(a, i) {
      e.Contracts.throwIfNull(a, "hostName");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Host, a.protocol + "//" + a.hostname + (a.port === "" ? "" : ":" + a.port)), i !== void 0 && c.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromAuthorizationToken(a, i) {
      e.Contracts.throwIfNull(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c.setProperty(n.PropertyId.SpeechServiceConnection_IntentRegion, i), c.authorizationToken = a, c;
    }
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    close() {
    }
  };
  Kt.SpeechConfig = r;
  class s extends r {
    constructor() {
      super(), this.privProperties = new n.PropertyCollection(), this.speechRecognitionLanguage = "en-US", this.outputFormat = n.OutputFormat.Simple;
    }
    get properties() {
      return this.privProperties;
    }
    get endPoint() {
      return new URL(this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint));
    }
    get subscriptionKey() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_Key);
    }
    get region() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_Region);
    }
    get authorizationToken() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    get speechRecognitionLanguage() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    set speechRecognitionLanguage(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, a);
    }
    get autoDetectSourceLanguages() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
    }
    set autoDetectSourceLanguages(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, a);
    }
    get outputFormat() {
      return n.OutputFormat[this.privProperties.getProperty(t.OutputFormatPropertyName, void 0)];
    }
    set outputFormat(a) {
      this.privProperties.setProperty(t.OutputFormatPropertyName, n.OutputFormat[a]);
    }
    get endpointId() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_EndpointId);
    }
    set endpointId(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_EndpointId, a);
    }
    setProperty(a, i) {
      e.Contracts.throwIfNull(i, "value"), this.privProperties.setProperty(a, i);
    }
    getProperty(a, i) {
      return this.privProperties.getProperty(a, i);
    }
    setProxy(a, i, c, u) {
      this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyHostName], a), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPort], i), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    setServiceProperty(a, i) {
      const c = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
      c[a] = i, this.privProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceResponse_ProfanityOption, n.ProfanityOption[a]);
    }
    enableAudioLogging() {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true"), this.privProperties.setProperty(t.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Detailed]);
    }
    enableDictation() {
      this.privProperties.setProperty(t.ForceDictationPropertyName, "true");
    }
    clone() {
      const a = new s();
      return a.privProperties = this.privProperties.clone(), a;
    }
    get speechSynthesisLanguage() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage, a);
    }
    get speechSynthesisVoiceName() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthVoice, a);
    }
    get speechSynthesisOutputFormat() {
      return n.SpeechSynthesisOutputFormat[this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, n.SpeechSynthesisOutputFormat[a]);
    }
  }
  return Kt.SpeechConfigImpl = s, Kt;
}
var Jt = {}, Zp;
function J_() {
  if (Zp)
    return Jt;
  Zp = 1, Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.SpeechTranslationConfigImpl = Jt.SpeechTranslationConfig = void 0;
  const t = b(), e = D, n = P();
  let r = class extends n.SpeechConfig {
    /**
     * Creates an instance of recognizer config.
     */
    constructor() {
      super();
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromSubscription(a, i) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromAuthorizationToken(a, i) {
      e.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.properties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a), c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(a, i) {
      e.Contracts.throwIfNull(a, "hostName");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Host, a.protocol + "//" + a.hostname + (a.port === "" ? "" : ":" + a.port)), i !== void 0 && c.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
    /**
     * Creates an instance of the speech translation config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or paramters.
     * Note: The query properties specified in the endpoint URL are not changed, even if they are
     * set by any other APIs. For example, if language is defined in the uri as query parameter
     * "language=de-DE", and also set by the speechRecognitionLanguage property, the language
     * setting in uri takes precedence, and the effective language is "de-DE".
     * Only the properties that are not specified in the endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechTranslationConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key.
     * @returns {SpeechTranslationConfig} A speech config instance.
     */
    static fromEndpoint(a, i) {
      e.Contracts.throwIfNull(a, "endpoint"), e.Contracts.throwIfNull(i, "subscriptionKey");
      const c = new s();
      return c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Endpoint, a.href), c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
  };
  Jt.SpeechTranslationConfig = r;
  class s extends r {
    constructor() {
      super(), this.privSpeechProperties = new n.PropertyCollection(), this.outputFormat = n.OutputFormat.Simple;
    }
    /**
     * Gets/Sets the authorization token.
     * If this is set, subscription key is ignored.
     * User needs to make sure the provided authorization token is valid and not expired.
     * @member SpeechTranslationConfigImpl.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set authorizationToken(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Sets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set speechRecognitionLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, a);
    }
    /**
     * Gets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @return {string} The speechRecognitionLanguage.
     */
    get speechRecognitionLanguage() {
      return this.privSpeechProperties.getProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
     * @function
     * @public
     */
    get subscriptionKey() {
      return this.privSpeechProperties.getProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_Key]);
    }
    /**
     * Gets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    get outputFormat() {
      return n.OutputFormat[this.privSpeechProperties.getProperty(t.OutputFormatPropertyName, void 0)];
    }
    /**
     * Gets/Sets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    set outputFormat(a) {
      this.privSpeechProperties.setProperty(t.OutputFormatPropertyName, n.OutputFormat[a]);
    }
    /**
     * Gets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    get endpointId() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_EndpointId);
    }
    /**
     * Gets/Sets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    set endpointId(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_EndpointId, a);
    }
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    addTargetLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value");
      const i = this.targetLanguages;
      i.includes(a) || (i.push(a), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, i.join(",")));
    }
    /**
     * Gets the (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.targetLanguages
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    get targetLanguages() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",") : [];
    }
    /**
     * Gets the voice name.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     */
    get voiceName() {
      return this.getProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    /**
     * Gets/Sets the voice of the translated language, enable voice synthesis output.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     * @param {string} value - The name of the voice.
     */
    set voiceName(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_TranslationVoice, a);
    }
    /**
     * Provides the region.
     * @member SpeechTranslationConfigImpl.prototype.region
     * @function
     * @public
     * @returns {string} The region.
     */
    get region() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_Region);
    }
    setProxy(a, i, c, u) {
      this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyHostName], a), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPort], i), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */
    getProperty(a, i) {
      return this.privSpeechProperties.getProperty(a, i);
    }
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */
    setProperty(a, i) {
      this.privSpeechProperties.setProperty(a, i);
    }
    /**
     * Provides access to custom properties.
     * @member SpeechTranslationConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechProperties;
    }
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    setServiceProperty(a, i) {
      const c = JSON.parse(this.privSpeechProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
      c[a] = i, this.privSpeechProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceResponse_ProfanityOption, n.ProfanityOption[a]);
    }
    enableAudioLogging() {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privSpeechProperties.setProperty(t.ForceDictationPropertyName, "true");
    }
    get speechSynthesisLanguage() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage, a);
    }
    get speechSynthesisVoiceName() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthVoice, a);
    }
    get speechSynthesisOutputFormat() {
      return n.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, n.SpeechSynthesisOutputFormat[a]);
    }
  }
  return Jt.SpeechTranslationConfigImpl = s, Jt;
}
var br = {}, Xp;
function mf() {
  if (Xp)
    return br;
  Xp = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.PropertyCollection = void 0;
  const t = P();
  let e = class gf {
    constructor() {
      this.privKeys = [], this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */
    getProperty(r, s) {
      let o;
      typeof r == "string" ? o = r : o = t.PropertyId[r];
      for (let a = 0; a < this.privKeys.length; a++)
        if (this.privKeys[a] === o)
          return this.privValues[a];
      if (s !== void 0)
        return String(s);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    setProperty(r, s) {
      let o;
      typeof r == "string" ? o = r : o = t.PropertyId[r];
      for (let a = 0; a < this.privKeys.length; a++)
        if (this.privKeys[a] === o) {
          this.privValues[a] = s;
          return;
        }
      this.privKeys.push(o), this.privValues.push(s);
    }
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */
    clone() {
      const r = new gf();
      for (let s = 0; s < this.privKeys.length; s++)
        r.privKeys.push(this.privKeys[s]), r.privValues.push(this.privValues[s]);
      return r;
    }
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */
    mergeTo(r) {
      this.privKeys.forEach((s) => {
        if (r.getProperty(s, void 0) === void 0) {
          const o = this.getProperty(s);
          r.setProperty(s, o);
        }
      });
    }
    /**
     * Get the keys in Property Collection.
     * @member PropertyCollection.prototype.keys
     * @function
     * @public
     * @returns {string []} Keys in the collection.
     */
    get keys() {
      return this.privKeys;
    }
  };
  return br.PropertyCollection = e, br;
}
var ta = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PropertyId = void 0, function(e) {
    e[e.SpeechServiceConnection_Key = 0] = "SpeechServiceConnection_Key", e[e.SpeechServiceConnection_Endpoint = 1] = "SpeechServiceConnection_Endpoint", e[e.SpeechServiceConnection_Region = 2] = "SpeechServiceConnection_Region", e[e.SpeechServiceAuthorization_Token = 3] = "SpeechServiceAuthorization_Token", e[e.SpeechServiceAuthorization_Type = 4] = "SpeechServiceAuthorization_Type", e[e.SpeechServiceConnection_EndpointId = 5] = "SpeechServiceConnection_EndpointId", e[e.SpeechServiceConnection_TranslationToLanguages = 6] = "SpeechServiceConnection_TranslationToLanguages", e[e.SpeechServiceConnection_TranslationVoice = 7] = "SpeechServiceConnection_TranslationVoice", e[e.SpeechServiceConnection_TranslationFeatures = 8] = "SpeechServiceConnection_TranslationFeatures", e[e.SpeechServiceConnection_IntentRegion = 9] = "SpeechServiceConnection_IntentRegion", e[e.SpeechServiceConnection_ProxyHostName = 10] = "SpeechServiceConnection_ProxyHostName", e[e.SpeechServiceConnection_ProxyPort = 11] = "SpeechServiceConnection_ProxyPort", e[e.SpeechServiceConnection_ProxyUserName = 12] = "SpeechServiceConnection_ProxyUserName", e[e.SpeechServiceConnection_ProxyPassword = 13] = "SpeechServiceConnection_ProxyPassword", e[e.SpeechServiceConnection_RecoMode = 14] = "SpeechServiceConnection_RecoMode", e[e.SpeechServiceConnection_RecoLanguage = 15] = "SpeechServiceConnection_RecoLanguage", e[e.Speech_SessionId = 16] = "Speech_SessionId", e[e.SpeechServiceConnection_SynthLanguage = 17] = "SpeechServiceConnection_SynthLanguage", e[e.SpeechServiceConnection_SynthVoice = 18] = "SpeechServiceConnection_SynthVoice", e[e.SpeechServiceConnection_SynthOutputFormat = 19] = "SpeechServiceConnection_SynthOutputFormat", e[e.SpeechServiceConnection_AutoDetectSourceLanguages = 20] = "SpeechServiceConnection_AutoDetectSourceLanguages", e[e.SpeechServiceResponse_RequestDetailedResultTrueFalse = 21] = "SpeechServiceResponse_RequestDetailedResultTrueFalse", e[e.SpeechServiceResponse_RequestProfanityFilterTrueFalse = 22] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse", e[e.SpeechServiceResponse_JsonResult = 23] = "SpeechServiceResponse_JsonResult", e[e.SpeechServiceResponse_JsonErrorDetails = 24] = "SpeechServiceResponse_JsonErrorDetails", e[e.CancellationDetails_Reason = 25] = "CancellationDetails_Reason", e[e.CancellationDetails_ReasonText = 26] = "CancellationDetails_ReasonText", e[e.CancellationDetails_ReasonDetailedText = 27] = "CancellationDetails_ReasonDetailedText", e[e.LanguageUnderstandingServiceResponse_JsonResult = 28] = "LanguageUnderstandingServiceResponse_JsonResult", e[e.SpeechServiceConnection_Url = 29] = "SpeechServiceConnection_Url", e[e.SpeechServiceConnection_InitialSilenceTimeoutMs = 30] = "SpeechServiceConnection_InitialSilenceTimeoutMs", e[e.SpeechServiceConnection_EndSilenceTimeoutMs = 31] = "SpeechServiceConnection_EndSilenceTimeoutMs", e[e.Speech_SegmentationSilenceTimeoutMs = 32] = "Speech_SegmentationSilenceTimeoutMs", e[e.Speech_SegmentationMaximumTimeMs = 33] = "Speech_SegmentationMaximumTimeMs", e[e.Speech_SegmentationStrategy = 34] = "Speech_SegmentationStrategy", e[e.SpeechServiceConnection_EnableAudioLogging = 35] = "SpeechServiceConnection_EnableAudioLogging", e[e.SpeechServiceConnection_LanguageIdMode = 36] = "SpeechServiceConnection_LanguageIdMode", e[e.SpeechServiceConnection_RecognitionEndpointVersion = 37] = "SpeechServiceConnection_RecognitionEndpointVersion", e[e.SpeechServiceConnection_SpeakerIdMode = 38] = "SpeechServiceConnection_SpeakerIdMode", e[e.SpeechServiceResponse_ProfanityOption = 39] = "SpeechServiceResponse_ProfanityOption", e[e.SpeechServiceResponse_PostProcessingOption = 40] = "SpeechServiceResponse_PostProcessingOption", e[e.SpeechServiceResponse_RequestWordLevelTimestamps = 41] = "SpeechServiceResponse_RequestWordLevelTimestamps", e[e.SpeechServiceResponse_StablePartialResultThreshold = 42] = "SpeechServiceResponse_StablePartialResultThreshold", e[e.SpeechServiceResponse_OutputFormatOption = 43] = "SpeechServiceResponse_OutputFormatOption", e[e.SpeechServiceResponse_TranslationRequestStablePartialResult = 44] = "SpeechServiceResponse_TranslationRequestStablePartialResult", e[e.SpeechServiceResponse_RequestWordBoundary = 45] = "SpeechServiceResponse_RequestWordBoundary", e[e.SpeechServiceResponse_RequestPunctuationBoundary = 46] = "SpeechServiceResponse_RequestPunctuationBoundary", e[e.SpeechServiceResponse_RequestSentenceBoundary = 47] = "SpeechServiceResponse_RequestSentenceBoundary", e[e.SpeechServiceResponse_DiarizeIntermediateResults = 48] = "SpeechServiceResponse_DiarizeIntermediateResults", e[e.Conversation_ApplicationId = 49] = "Conversation_ApplicationId", e[e.Conversation_DialogType = 50] = "Conversation_DialogType", e[e.Conversation_Initial_Silence_Timeout = 51] = "Conversation_Initial_Silence_Timeout", e[e.Conversation_From_Id = 52] = "Conversation_From_Id", e[e.Conversation_Conversation_Id = 53] = "Conversation_Conversation_Id", e[e.Conversation_Custom_Voice_Deployment_Ids = 54] = "Conversation_Custom_Voice_Deployment_Ids", e[e.Conversation_Speech_Activity_Template = 55] = "Conversation_Speech_Activity_Template", e[e.Conversation_Request_Bot_Status_Messages = 56] = "Conversation_Request_Bot_Status_Messages", e[e.Conversation_Agent_Connection_Id = 57] = "Conversation_Agent_Connection_Id", e[e.SpeechServiceConnection_Host = 58] = "SpeechServiceConnection_Host", e[e.ConversationTranslator_Host = 59] = "ConversationTranslator_Host", e[e.ConversationTranslator_Name = 60] = "ConversationTranslator_Name", e[e.ConversationTranslator_CorrelationId = 61] = "ConversationTranslator_CorrelationId", e[e.ConversationTranslator_Token = 62] = "ConversationTranslator_Token", e[e.PronunciationAssessment_ReferenceText = 63] = "PronunciationAssessment_ReferenceText", e[e.PronunciationAssessment_GradingSystem = 64] = "PronunciationAssessment_GradingSystem", e[e.PronunciationAssessment_Granularity = 65] = "PronunciationAssessment_Granularity", e[e.PronunciationAssessment_EnableMiscue = 66] = "PronunciationAssessment_EnableMiscue", e[e.PronunciationAssessment_Json = 67] = "PronunciationAssessment_Json", e[e.PronunciationAssessment_Params = 68] = "PronunciationAssessment_Params", e[e.SpeakerRecognition_Api_Version = 69] = "SpeakerRecognition_Api_Version", e[e.WebWorkerLoadType = 70] = "WebWorkerLoadType", e[e.TalkingAvatarService_WebRTC_SDP = 71] = "TalkingAvatarService_WebRTC_SDP";
  }(t.PropertyId || (t.PropertyId = {}));
})(ta);
var Ar = {}, ed;
function G_() {
  if (ed)
    return Ar;
  ed = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.Recognizer = void 0;
  const t = b(), e = O(), n = D, r = P();
  let s = class Sf {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     * @param {PropertyCollection} properties - A set of properties to set on the recognizer
     * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
     */
    constructor(a, i, c) {
      this.audioConfig = a !== void 0 ? a : r.AudioConfig.fromDefaultMicrophoneInput(), this.privDisposed = !1, this.privProperties = i.clone(), this.privConnectionFactory = c, this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposed), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(a) {
      this.privDisposed || (this.privDisposed = !0, a && this.privReco && (await this.privReco.audioSource.turnOff(), await this.privReco.dispose()));
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
      return t.ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    static enableTelemetry(a) {
      t.ServiceRecognizerBase.telemetryDataEnabled = a;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
      let a = typeof window < "u" ? "Browser" : "Node", i = "unknown", c = "unknown";
      typeof navigator < "u" && (a = a + "/" + navigator.platform, i = navigator.userAgent, c = navigator.appVersion);
      const u = this.createRecognizerConfig(new t.SpeechServiceConfig(new t.Context(new t.OS(a, i, c))));
      this.privReco = this.createServiceRecognizer(Sf.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, u);
    }
    async recognizeOnceAsyncImpl(a) {
      n.Contracts.throwIfDisposed(this.privDisposed);
      const i = new e.Deferred();
      await this.implRecognizerStop(), await this.privReco.recognize(a, i.resolve, i.reject);
      const c = await i.promise;
      return await this.implRecognizerStop(), c;
    }
    async startContinuousRecognitionAsyncImpl(a) {
      n.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop(), await this.privReco.recognize(a, void 0, void 0);
    }
    async stopContinuousRecognitionAsyncImpl() {
      n.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop();
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    static getAuthFromProperties(a) {
      const i = a.getProperty(r.PropertyId.SpeechServiceConnection_Key, void 0);
      return i && i !== "" ? new t.CognitiveSubscriptionKeyAuthentication(i) : new t.CognitiveTokenAuthentication(() => {
        const u = a.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      }, () => {
        const u = a.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      });
    }
  };
  return Ar.Recognizer = s, Ar;
}
var Mr = {}, td;
function Q_() {
  if (td)
    return Mr;
  td = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.SpeechRecognizer = void 0;
  const t = b(), e = O(), n = D, r = P();
  class s extends r.Recognizer {
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(a, i) {
      const c = a;
      n.Contracts.throwIfNull(c, "speechConfig"), n.Contracts.throwIfNullOrWhitespace(c.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(i, c.properties, new t.SpeechConnectionFactory()), this.privDisposedRecognizer = !1;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(a, i, c) {
      const u = a;
      return i.properties.mergeTo(u.properties), new s(a, c);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for speech recognition.
     * @member SpeechRecognizer.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      n.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Gets the spoken language of recognition.
     * @member SpeechRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of recognition.
     * @member SpeechRecognizer.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of recognition.
     */
    get outputFormat() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]) === r.OutputFormat[r.OutputFormat.Simple] ? r.OutputFormat.Simple : r.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this SpeechRecognizer.
     * @member SpeechRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(a, i) {
      e.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), a, i);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(a, i) {
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), a, i);
    }
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(a, i) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(a, i, c) {
      n.Contracts.throwIfNull(a, "model"), c && c("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(a) {
      a && a();
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(a) {
      this.privDisposedRecognizer || (a && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new t.SpeechServiceRecognizer(a, i, p, u, this);
    }
  }
  return Mr.SpeechRecognizer = s, Mr;
}
var Or = {}, nd;
function Y_() {
  if (nd)
    return Or;
  nd = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.IntentRecognizer = void 0;
  const t = b(), e = O(), n = D, r = P();
  let s = class extends r.Recognizer {
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(a, i) {
      n.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const c = a;
      n.Contracts.throwIfNullOrUndefined(c, "speechConfig"), super(i, c.properties, new t.IntentConnectionFactory()), this.privAddedIntents = [], this.privAddedLmIntents = {}, this.privDisposedIntentRecognizer = !1, this.privProperties = c.properties, n.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * Gets the spoken language of recognition.
     * @member IntentRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} the spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(a) {
      this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * The collection of properties and their values defined for this IntentRecognizer.
     * @member IntentRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their
     * values defined for this IntentRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(a, i) {
      if (n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const c = this.buildSpeechContext();
        this.privReco.speechContext.setSection("intent", c.Intent), this.privReco.dynamicGrammar.addReferenceGrammar(c.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      e.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), a, i);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(a, i) {
      if (Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const c = this.buildSpeechContext();
        this.privReco.speechContext.setSection("intent", c.Intent), this.privReco.dynamicGrammar.addReferenceGrammar(c.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), a, i);
    }
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(a, i) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(a, i, c) {
      n.Contracts.throwIfNull(a, "model"), c && c("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(a, i) {
      if (a)
        try {
          a();
        } catch (c) {
          i && i(c);
        }
    }
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */
    addIntent(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), n.Contracts.throwIfNullOrWhitespace(i, "intentId"), n.Contracts.throwIfNullOrWhitespace(a, "simplePhrase"), this.privAddedIntents.push([i, a]);
    }
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */
    addIntentWithLanguageModel(a, i, c) {
      n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), n.Contracts.throwIfNullOrWhitespace(a, "intentId"), n.Contracts.throwIfNull(i, "model");
      const u = i;
      n.Contracts.throwIfNullOrWhitespace(u.appId, "model.appId"), this.privAddedLmIntents[a] = new t.AddedLmIntent(u, c);
    }
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */
    addAllIntents(a, i) {
      n.Contracts.throwIfNull(a, "model");
      const c = a;
      n.Contracts.throwIfNullOrWhitespace(c.appId, "model.appId"), this.privUmbrellaIntent = new t.AddedLmIntent(c, i);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new t.IntentServiceRecognizer(a, i, p, u, this);
    }
    async dispose(a) {
      this.privDisposedIntentRecognizer || a && (this.privDisposedIntentRecognizer = !0, await super.dispose(a));
    }
    buildSpeechContext() {
      let a, i, c;
      const u = [];
      this.privUmbrellaIntent !== void 0 && (a = this.privUmbrellaIntent.modelImpl.appId, i = this.privUmbrellaIntent.modelImpl.region, c = this.privUmbrellaIntent.modelImpl.subscriptionKey);
      for (const p of Object.keys(this.privAddedLmIntents)) {
        const d = this.privAddedLmIntents[p];
        if (a === void 0)
          a = d.modelImpl.appId;
        else if (a !== d.modelImpl.appId)
          throw new Error("Intents must all be from the same LUIS model");
        if (i === void 0)
          i = d.modelImpl.region;
        else if (i !== d.modelImpl.region)
          throw new Error("Intents must all be from the same LUIS model in a single region");
        if (c === void 0)
          c = d.modelImpl.subscriptionKey;
        else if (c !== d.modelImpl.subscriptionKey)
          throw new Error("Intents must all use the same subscription key");
        const l = "luis/" + a + "-PRODUCTION#" + p;
        u.push(l);
      }
      return {
        Intent: {
          id: a,
          key: c === void 0 ? this.privProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_Key]) : c,
          provider: "LUIS"
        },
        ReferenceGrammars: this.privUmbrellaIntent === void 0 ? u : ["luis/" + a + "-PRODUCTION"]
      };
    }
  };
  return Or.IntentRecognizer = s, Or;
}
var yf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.VoiceProfileType = void 0, function(e) {
    e[e.TextIndependentIdentification = 0] = "TextIndependentIdentification", e[e.TextDependentVerification = 1] = "TextDependentVerification", e[e.TextIndependentVerification = 2] = "TextIndependentVerification";
  }(t.VoiceProfileType || (t.VoiceProfileType = {}));
})(yf);
var kr = {}, Dr = {}, Gt = {}, rd;
function Cf() {
  if (rd)
    return Gt;
  rd = 1, Object.defineProperty(Gt, "__esModule", { value: !0 }), Gt.ConnectionMessageImpl = Gt.ConnectionMessage = void 0;
  const t = me, e = O(), n = mf(), r = ta;
  let s = class {
  };
  Gt.ConnectionMessage = s;
  class o {
    constructor(i) {
      this.privConnectionMessage = i, this.privProperties = new n.PropertyCollection(), this.privConnectionMessage.headers[t.HeaderNames.ConnectionId] && this.privProperties.setProperty(r.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[t.HeaderNames.ConnectionId]), Object.keys(this.privConnectionMessage.headers).forEach((c) => {
        this.privProperties.setProperty(c, this.privConnectionMessage.headers[c]);
      });
    }
    /**
     * The message path.
     */
    get path() {
      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((i) => i.toLowerCase() === "path".toLowerCase())];
    }
    /**
     * Checks to see if the ConnectionMessage is a text message.
     * See also IsBinaryMessage().
     */
    get isTextMessage() {
      return this.privConnectionMessage.messageType === e.MessageType.Text;
    }
    /**
     * Checks to see if the ConnectionMessage is a binary message.
     * See also GetBinaryMessage().
     */
    get isBinaryMessage() {
      return this.privConnectionMessage.messageType === e.MessageType.Binary;
    }
    /**
     * Gets the text message payload. Typically the text message content-type is
     * application/json. To determine other content-types use
     * Properties.GetProperty("Content-Type").
     */
    get TextMessage() {
      return this.privConnectionMessage.textBody;
    }
    /**
     * Gets the binary message payload.
     */
    get binaryMessage() {
      return this.privConnectionMessage.binaryBody;
    }
    /**
     * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
     * Message headers can be accessed via this collection (e.g. "Content-Type").
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Returns a string that represents the connection message.
     */
    toString() {
      return "";
    }
  }
  return Gt.ConnectionMessageImpl = o, Gt;
}
var id;
function _f() {
  if (id)
    return Dr;
  id = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.Connection = void 0;
  const t = b(), e = O(), n = Cf(), r = D, s = P();
  let o = class xc {
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */
    static fromRecognizer(i) {
      const c = i.internalData, u = new xc();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */
    static fromSynthesizer(i) {
      const c = i.internalData, u = new xc();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */
    openConnection(i, c) {
      e.marshalPromiseToCallbacks(this.privInternalData.connect(), i, c);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */
    closeConnection(i, c) {
      if (this.privInternalData instanceof t.SynthesisAdapterBase)
        throw new Error("Disconnecting a synthesizer's connection is currently not supported");
      e.marshalPromiseToCallbacks(this.privInternalData.disconnect(), i, c);
    }
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */
    setMessageProperty(i, c, u) {
      if (r.Contracts.throwIfNullOrWhitespace(c, "propertyName"), this.privInternalData instanceof t.ServiceRecognizerBase) {
        if (i.toLowerCase() !== "speech.context")
          throw new Error("Only speech.context message property sets are currently supported for recognizer");
        this.privInternalData.speechContext.setSection(c, u);
      } else if (this.privInternalData instanceof t.SynthesisAdapterBase) {
        if (i.toLowerCase() !== "synthesis.context")
          throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
        this.privInternalData.synthesisContext.setSection(c, u);
      }
    }
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */
    sendMessageAsync(i, c, u, p) {
      e.marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(i, c), u, p);
    }
    /**
     * Dispose of associated resources.
     */
    close() {
    }
    setupEvents() {
      this.privEventListener = this.privInternalData.connectionEvents.attach((i) => {
        i.name === "ConnectionEstablishedEvent" ? this.connected && this.connected(new s.ConnectionEventArgs(i.connectionId)) : i.name === "ConnectionClosedEvent" ? this.disconnected && this.disconnected(new s.ConnectionEventArgs(i.connectionId)) : i.name === "ConnectionMessageSentEvent" ? this.messageSent && this.messageSent(new s.ConnectionMessageEventArgs(new n.ConnectionMessageImpl(i.message))) : i.name === "ConnectionMessageReceivedEvent" && this.messageReceived && this.messageReceived(new s.ConnectionMessageEventArgs(new n.ConnectionMessageImpl(i.message)));
      }), this.privServiceEventListener = this.privInternalData.serviceEvents.attach((i) => {
        this.receivedServiceMessage && this.receivedServiceMessage(new s.ServiceEventArgs(i.jsonString, i.name));
      });
    }
  };
  return Dr.Connection = o, Dr;
}
var sd;
function Z_() {
  if (sd)
    return kr;
  sd = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.TranslationRecognizer = void 0;
  const t = b(), e = O(), n = _f(), r = D, s = P();
  let o = class Rf extends s.Recognizer {
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */
    constructor(i, c, u) {
      const p = i;
      r.Contracts.throwIfNull(p, "speechConfig"), super(c, p.properties, u || new t.TranslationConnectionFactory()), this.privDisposedTranslationRecognizer = !1, this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && r.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationVoice), s.PropertyId[s.PropertyId.SpeechServiceConnection_TranslationVoice]), r.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages), s.PropertyId[s.PropertyId.SpeechServiceConnection_TranslationToLanguages]), r.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage), s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(i, c, u) {
      const p = i;
      return c.properties.mergeTo(p.properties), new Rf(i, u);
    }
    /**
     * Gets the language name that was set when the recognizer was created.
     * @member TranslationRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} Gets the language name that was set when the recognizer was created.
     */
    get speechRecognitionLanguage() {
      return r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets target languages for translation that were set when the recognizer was created.
     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
     * @member TranslationRecognizer.prototype.targetLanguages
     * @function
     * @public
     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
     */
    get targetLanguages() {
      return r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    }
    /**
     * Gets the name of output voice.
     * @member TranslationRecognizer.prototype.voiceName
     * @function
     * @public
     * @returns {string} the name of output voice.
     */
    get voiceName() {
      return r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
    }
    /**
     * The collection of properties and their values defined for this TranslationRecognizer.
     * @member TranslationRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(i) {
      this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, i);
    }
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(i, c) {
      r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), e.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), i, c);
    }
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(i, c) {
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), i, c);
    }
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(i, c) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), i, c);
    }
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */
    removeTargetLanguage(i) {
      if (r.Contracts.throwIfNullOrUndefined(i, "language to be removed"), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        const c = this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), u = c.indexOf(i);
        u > -1 && (c.splice(u, 1), this.properties.setProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, c.join(",")), this.updateLanguages(c));
      }
    }
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */
    addTargetLanguage(i) {
      r.Contracts.throwIfNullOrUndefined(i, "language to be added");
      let c = [];
      this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? (c = this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), c.includes(i) || (c.push(i), this.properties.setProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, c.join(",")))) : (this.properties.setProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, i), c = [i]), this.updateLanguages(c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */
    close(i, c) {
      r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), i, c);
    }
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onConnection() {
    }
    async dispose(i) {
      this.privDisposedTranslationRecognizer || (this.privDisposedTranslationRecognizer = !0, i && (await this.implRecognizerStop(), await super.dispose(i)));
    }
    createRecognizerConfig(i) {
      return new t.RecognizerConfig(i, this.privProperties);
    }
    createServiceRecognizer(i, c, u, p) {
      const d = u;
      return new t.TranslationServiceRecognizer(i, c, d, p, this);
    }
    updateLanguages(i) {
      const c = n.Connection.fromRecognizer(this);
      c && (c.setMessageProperty("speech.context", "translationcontext", { to: i }), c.sendMessageAsync("event", JSON.stringify({
        id: "translation",
        name: "updateLanguage",
        to: i
      })));
    }
  };
  return kr.TranslationRecognizer = o, kr;
}
var Nr = {}, od;
function X_() {
  if (od)
    return Nr;
  od = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.Translations = void 0;
  const t = P();
  let e = class {
    constructor() {
      this.privMap = new t.PropertyCollection();
    }
    /**
     * Get the languages in the object in a String array.
     * @member Translations.prototype.languages
     * @function
     * @public
     * @returns {string[]} languages in translations object.
     */
    get languages() {
      return this.privMap.keys;
    }
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */
    get(r, s) {
      return this.privMap.getProperty(r, s);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    set(r, s) {
      this.privMap.setProperty(r, s);
    }
  };
  return Nr.Translations = e, Nr;
}
var Pf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.NoMatchReason = void 0, function(e) {
    e[e.NotRecognized = 0] = "NotRecognized", e[e.InitialSilenceTimeout = 1] = "InitialSilenceTimeout", e[e.InitialBabbleTimeout = 2] = "InitialBabbleTimeout";
  }(t.NoMatchReason || (t.NoMatchReason = {}));
})(Pf);
var Lr = {}, ad;
function e0() {
  if (ad)
    return Lr;
  ad = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.NoMatchDetails = void 0;
  const t = b(), e = P();
  let n = class Ef {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */
    constructor(s) {
      this.privReason = s;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */
    static fromResult(s) {
      const o = t.SimpleSpeechPhrase.fromJSON(s.json, 0);
      let a = e.NoMatchReason.NotRecognized;
      switch (o.RecognitionStatus) {
        case t.RecognitionStatus.BabbleTimeout:
          a = e.NoMatchReason.InitialBabbleTimeout;
          break;
        case t.RecognitionStatus.InitialSilenceTimeout:
          a = e.NoMatchReason.InitialSilenceTimeout;
          break;
        default:
          a = e.NoMatchReason.NotRecognized;
          break;
      }
      return new Ef(a);
    }
    /**
     * The reason the recognition was canceled.
     * @member NoMatchDetails.prototype.reason
     * @function
     * @public
     * @returns {NoMatchReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
  };
  return Lr.NoMatchDetails = n, Lr;
}
var na = {};
Object.defineProperty(na, "__esModule", { value: !0 });
na.TranslationRecognitionCanceledEventArgs = void 0;
class t0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionid - The session id.
   * @param {CancellationReason} cancellationReason - The cancellation reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {TranslationRecognitionResult} result - The result.
   */
  constructor(e, n, r, s, o) {
    this.privCancelReason = n, this.privErrorDetails = r, this.privResult = o, this.privSessionId = e, this.privErrorCode = s;
  }
  /**
   * Specifies the recognition result.
   * @member TranslationRecognitionCanceledEventArgs.prototype.result
   * @function
   * @public
   * @returns {TranslationRecognitionResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
  /**
   * Specifies the session identifier.
   * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
  /**
   * The reason the recognition was canceled.
   * @member TranslationRecognitionCanceledEventArgs.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privCancelReason;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get errorCode() {
    return this.privErrorCode;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
}
na.TranslationRecognitionCanceledEventArgs = t0;
var zr = {}, cd;
function n0() {
  if (cd)
    return zr;
  cd = 1, Object.defineProperty(zr, "__esModule", { value: !0 }), zr.IntentRecognitionCanceledEventArgs = void 0;
  const t = P();
  let e = class extends t.IntentRecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */
    constructor(r, s, o, a, i, c) {
      super(a, i, c), this.privReason = r, this.privErrorDetails = s, this.privErrorCode = o;
    }
    /**
     * The reason the recognition was canceled.
     * @member IntentRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return zr.IntentRecognitionCanceledEventArgs = e, zr;
}
var ys = {};
Object.defineProperty(ys, "__esModule", { value: !0 });
ys.CancellationDetailsBase = void 0;
class r0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {CancellationReason} reason - The cancellation reason.
   * @param {string} errorDetails - The error details, if provided.
   */
  constructor(e, n, r) {
    this.privReason = e, this.privErrorDetails = n, this.privErrorCode = r;
  }
  /**
   * The reason the recognition was canceled.
   * @member CancellationDetailsBase.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member CancellationDetailsBase.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get ErrorCode() {
    return this.privErrorCode;
  }
}
ys.CancellationDetailsBase = r0;
var jr = {}, ud;
function i0() {
  if (ud)
    return jr;
  ud = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.CancellationDetails = void 0;
  const t = b(), e = ys, n = P();
  let r = class Tf extends e.CancellationDetailsBase {
    constructor(o, a, i) {
      super(o, a, i);
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */
    static fromResult(o) {
      let a = n.CancellationReason.Error, i = n.CancellationErrorCode.NoError;
      if (o instanceof n.RecognitionResult && o.json) {
        const c = t.SimpleSpeechPhrase.fromJSON(o.json, 0);
        a = t.EnumTranslation.implTranslateCancelResult(c.RecognitionStatus);
      }
      return o.properties && (i = n.CancellationErrorCode[o.properties.getProperty(t.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.NoError])]), new Tf(a, o.errorDetails || t.EnumTranslation.implTranslateErrorDetails(i), i);
    }
  };
  return jr.CancellationDetails = r, jr;
}
var wf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CancellationErrorCode = void 0, function(e) {
    e[e.NoError = 0] = "NoError", e[e.AuthenticationFailure = 1] = "AuthenticationFailure", e[e.BadRequestParameters = 2] = "BadRequestParameters", e[e.TooManyRequests = 3] = "TooManyRequests", e[e.ConnectionFailure = 4] = "ConnectionFailure", e[e.ServiceTimeout = 5] = "ServiceTimeout", e[e.ServiceError = 6] = "ServiceError", e[e.RuntimeError = 7] = "RuntimeError", e[e.Forbidden = 8] = "Forbidden";
  }(t.CancellationErrorCode || (t.CancellationErrorCode = {}));
})(wf);
var xr = {}, pd;
function s0() {
  if (pd)
    return xr;
  pd = 1, Object.defineProperty(xr, "__esModule", { value: !0 }), xr.ConnectionEventArgs = void 0;
  const t = P();
  let e = class extends t.SessionEventArgs {
  };
  return xr.ConnectionEventArgs = e, xr;
}
var Br = {}, dd;
function o0() {
  if (dd)
    return Br;
  dd = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.ServiceEventArgs = void 0;
  const t = P();
  let e = class extends t.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */
    constructor(r, s, o) {
      super(o), this.privJsonResult = r, this.privEventName = s;
    }
    get jsonString() {
      return this.privJsonResult;
    }
    get eventName() {
      return this.privEventName;
    }
  };
  return Br.ServiceEventArgs = e, Br;
}
var ra = {};
Object.defineProperty(ra, "__esModule", { value: !0 });
ra.PhraseListGrammar = void 0;
class Eu {
  constructor(e) {
    this.privGrammerBuilder = e.dynamicGrammar;
  }
  /**
   * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
   * @param recognizer The recognizer to add phrase lists to.
   */
  static fromRecognizer(e) {
    const n = e.internalData;
    return new Eu(n);
  }
  /**
   * Adds a single phrase to the current recognizer.
   * @param phrase Phrase to add.
   */
  addPhrase(e) {
    this.privGrammerBuilder.addPhrase(e);
  }
  /**
   * Adds multiple phrases to the current recognizer.
   * @param phrases Array of phrases to add.
   */
  addPhrases(e) {
    this.privGrammerBuilder.addPhrase(e);
  }
  /**
   * Clears all phrases added to the current recognizer.
   */
  clear() {
    this.privGrammerBuilder.clearPhrases();
  }
}
ra.PhraseListGrammar = Eu;
var Qt = {}, ld;
function Tu() {
  if (ld)
    return Qt;
  ld = 1, Object.defineProperty(Qt, "__esModule", { value: !0 }), Qt.DialogServiceConfigImpl = Qt.DialogServiceConfig = void 0;
  const t = D, e = P();
  let n = class {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */
    constructor() {
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member DialogServiceConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set applicationId(o) {
    }
    static get DialogTypes() {
      return {
        BotFramework: "bot_framework",
        CustomCommands: "custom_commands"
      };
    }
  };
  Qt.DialogServiceConfig = n;
  class r extends n {
    /**
     * Creates an instance of dialogService config.
     */
    constructor() {
      super(), this.privSpeechConfig = new e.SpeechConfigImpl();
    }
    /**
     * Provides access to custom properties.
     * @member DialogServiceConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechConfig.properties;
    }
    /**
     * Gets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     */
    get speechRecognitionLanguage() {
      return this.privSpeechConfig.speechRecognitionLanguage;
    }
    /**
     * Sets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The language to set.
     */
    set speechRecognitionLanguage(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value"), this.privSpeechConfig.speechRecognitionLanguage = o;
    }
    get outputFormat() {
      return this.privSpeechConfig.outputFormat;
    }
    set outputFormat(o) {
      this.privSpeechConfig.outputFormat = o;
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */
    setProperty(o, a) {
      this.privSpeechConfig.setProperty(o, a);
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */
    getProperty(o, a) {
      return this.privSpeechConfig.getProperty(o);
    }
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */
    setProxy(o, a, i, c) {
      this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyHostName, o), this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyPort, `${a}`), i && this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyUserName, i), c && this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyPassword, c);
    }
    setServiceProperty(o, a, i) {
      this.privSpeechConfig.setServiceProperty(o, a);
    }
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
  }
  return Qt.DialogServiceConfigImpl = r, Qt;
}
var qr = {}, hd;
function a0() {
  if (hd)
    return qr;
  hd = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.BotFrameworkConfig = void 0;
  const t = D, e = Tu(), n = P();
  let r = class extends e.DialogServiceConfigImpl {
    /**
     * Creates an instance of BotFrameworkConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromSubscription(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "subscription"), t.Contracts.throwIfNullOrWhitespace(a, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(n.PropertyId.SpeechServiceConnection_Key, o), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, a), i && c.setProperty(n.PropertyId.Conversation_ApplicationId, i), c;
    }
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromAuthorizationToken(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(a, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, o), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, a), i && c.setProperty(n.PropertyId.Conversation_ApplicationId, i), c;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromHost(o, a, i) {
      t.Contracts.throwIfNullOrUndefined(o, "host");
      const c = o instanceof URL ? o : new URL(`wss://${o}.convai.speech.azure.us`);
      t.Contracts.throwIfNullOrUndefined(c, "resolvedHost");
      const u = new e.DialogServiceConfigImpl();
      return u.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), u.setProperty(n.PropertyId.SpeechServiceConnection_Host, c.toString()), a !== void 0 && u.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), u;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */
    static fromEndpoint(o, a) {
      t.Contracts.throwIfNull(o, "endpoint");
      const i = new e.DialogServiceConfigImpl();
      return i.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), i.setProperty(n.PropertyId.SpeechServiceConnection_Endpoint, o.toString()), a !== void 0 && i.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), i;
    }
  };
  return qr.BotFrameworkConfig = r, qr;
}
var Fr = {}, vd;
function c0() {
  if (vd)
    return Fr;
  vd = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.CustomCommandsConfig = void 0;
  const t = D, e = Tu(), n = P();
  let r = class extends e.DialogServiceConfigImpl {
    /**
     * Creates an instance of CustomCommandsConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */
    static fromSubscription(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "applicationId"), t.Contracts.throwIfNullOrWhitespace(a, "subscription"), t.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(n.PropertyId.Conversation_ApplicationId, o), c.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */
    static fromAuthorizationToken(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "applicationId"), t.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(n.PropertyId.Conversation_ApplicationId, o), c.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    set applicationId(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value"), this.setProperty(n.PropertyId.Conversation_ApplicationId, o);
    }
    /**
     * Gets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to get.
     */
    get applicationId() {
      return this.getProperty(n.PropertyId.Conversation_ApplicationId);
    }
  };
  return Fr.CustomCommandsConfig = r, Fr;
}
var $r = {}, Ur = {}, Hr = {}, st = {};
Object.defineProperty(st, "__esModule", { value: !0 });
st.QueryParameterNames = void 0;
class se {
}
st.QueryParameterNames = se;
se.BotId = "botid";
se.CustomSpeechDeploymentId = "cid";
se.CustomVoiceDeploymentId = "deploymentId";
se.EnableAudioLogging = "storeAudio";
se.EnableLanguageId = "lidEnabled";
se.EnableWordLevelTimestamps = "wordLevelTimestamps";
se.EndSilenceTimeoutMs = "endSilenceTimeoutMs";
se.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs";
se.SegmentationMaximumTimeMs = "segmentationMaximumTimeMs";
se.SegmentationStrategy = "segmentationStrategy";
se.Format = "format";
se.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs";
se.Language = "language";
se.Profanity = "profanity";
se.RequestBotStatusMessages = "enableBotMessageStatus";
se.StableIntermediateThreshold = "stableIntermediateThreshold";
se.StableTranslation = "stableTranslation";
se.TestHooks = "testhooks";
se.Postprocessing = "postprocessing";
se.CtsMeetingId = "meetingId";
se.CtsDeviceId = "deviceId";
se.CtsIsParticipant = "isParticipant";
se.EnableAvatar = "enableTalkingAvatar";
var fd;
function ot() {
  if (fd)
    return Hr;
  fd = 1, Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.ConnectionFactoryBase = void 0;
  const t = b(), e = P(), n = st;
  let r = class {
    static getHostSuffix(o) {
      if (o) {
        if (o.toLowerCase().startsWith("china"))
          return ".azure.cn";
        if (o.toLowerCase().startsWith("usgov"))
          return ".azure.us";
      }
      return ".microsoft.com";
    }
    setCommonUrlParams(o, a, i) {
      (/* @__PURE__ */ new Map([
        [e.PropertyId.Speech_SegmentationSilenceTimeoutMs, n.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_EnableAudioLogging, n.QueryParameterNames.EnableAudioLogging],
        [e.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, n.QueryParameterNames.EndSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, n.QueryParameterNames.InitialSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceResponse_PostProcessingOption, n.QueryParameterNames.Postprocessing],
        [e.PropertyId.SpeechServiceResponse_ProfanityOption, n.QueryParameterNames.Profanity],
        [e.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, n.QueryParameterNames.EnableWordLevelTimestamps],
        [e.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, n.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((p, d) => {
        this.setUrlParameter(d, p, o, a, i);
      });
      const u = JSON.parse(o.parameters.getProperty(t.ServicePropertiesPropertyName, "{}"));
      Object.keys(u).forEach((p) => {
        a[p] = u[p];
      });
    }
    setUrlParameter(o, a, i, c, u) {
      const p = i.parameters.getProperty(o, void 0);
      p && (!u || u.search(a) === -1) && (c[a] = p.toLocaleLowerCase());
    }
  };
  return Hr.ConnectionFactoryBase = r, Hr;
}
var gd;
function u0() {
  if (gd)
    return Ur;
  gd = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.DialogConnectionFactory = void 0;
  const t = Se(), e = b(), n = P(), r = ot(), s = b(), o = me, a = st;
  class i extends r.ConnectionFactoryBase {
    create(u, p, d) {
      const l = u.parameters.getProperty(n.PropertyId.Conversation_ApplicationId, ""), h = u.parameters.getProperty(n.PropertyId.Conversation_DialogType), v = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Region), g = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), f = u.parameters.getProperty(n.PropertyId.Conversation_Request_Bot_Status_Messages, "true"), m = {};
      m[o.HeaderNames.ConnectionId] = d, m[a.QueryParameterNames.Format] = u.parameters.getProperty(e.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Simple]).toLowerCase(), m[a.QueryParameterNames.Language] = g, m[a.QueryParameterNames.RequestBotStatusMessages] = f, l && (m[a.QueryParameterNames.BotId] = l, h === n.DialogServiceConfig.DialogTypes.CustomCommands && (m[o.HeaderNames.CustomCommandsAppId] = l));
      const S = h === n.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "", y = h === n.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : h === n.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0", E = {};
      p.token != null && p.token !== "" && (E[p.headerName] = p.token);
      let _ = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint, "");
      if (!_) {
        const R = r.ConnectionFactoryBase.getHostSuffix(v), T = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, `wss://${v}.${i.BaseUrl}${R}`);
        _ = `${T.endsWith("/") ? T : T + "/"}${S}${i.ApiKey}/${y}`;
      }
      this.setCommonUrlParams(u, m, _);
      const C = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(_, m, E, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), C, d);
    }
  }
  return Ur.DialogConnectionFactory = i, i.ApiKey = "api", i.BaseUrl = "convai.speech", Ur;
}
var md;
function p0() {
  if (md)
    return $r;
  md = 1, Object.defineProperty($r, "__esModule", { value: !0 }), $r.DialogServiceConnector = void 0;
  const t = u0(), e = b(), n = O(), r = D, s = P(), o = ta;
  let a = class extends s.Recognizer {
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */
    constructor(c, u) {
      const p = c;
      r.Contracts.throwIfNull(c, "dialogConfig"), super(u, p.properties, new t.DialogConnectionFactory()), this.isTurnComplete = !0, this.privIsDisposed = !1, this.privProperties = p.properties.clone();
      const d = this.buildAgentConfig();
      this.privReco.agentConfig.set(d);
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */
    connect(c, u) {
      n.marshalPromiseToCallbacks(this.privReco.connect(), c, u);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */
    disconnect(c, u) {
      n.marshalPromiseToCallbacks(this.privReco.disconnect(), c, u);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Sets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(c) {
      r.Contracts.throwIfNullOrWhitespace(c, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, c);
    }
    /**
     * The collection of properties and their values defined for this DialogServiceConnector.
     * @member DialogServiceConnector.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
     */
    get properties() {
      return this.privProperties;
    }
    /** Gets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be empty
     */
    get speechActivityTemplate() {
      return this.properties.getProperty(o.PropertyId.Conversation_Speech_Activity_Template);
    }
    /** Sets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be null or empty.
     * Note: it has to be a valid Json object.
     */
    set speechActivityTemplate(c) {
      this.properties.setProperty(o.PropertyId.Conversation_Speech_Activity_Template, c);
    }
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */
    listenOnceAsync(c, u) {
      if (this.isTurnComplete) {
        r.Contracts.throwIfDisposed(this.privIsDisposed);
        const d = (async () => {
          await this.privReco.connect(), await this.implRecognizerStop(), this.isTurnComplete = !1;
          const l = new n.Deferred();
          await this.privReco.recognize(e.RecognitionMode.Conversation, l.resolve, l.reject);
          const h = await l.promise;
          return await this.implRecognizerStop(), h;
        })();
        d.catch(() => {
          this.dispose(!0).catch(() => {
          });
        }), n.marshalPromiseToCallbacks(d.finally(() => {
          this.isTurnComplete = !0;
        }), c, u);
      }
    }
    sendActivityAsync(c, u, p) {
      n.marshalPromiseToCallbacks(this.privReco.sendMessage(c), u, p);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */
    close(c, u) {
      r.Contracts.throwIfDisposed(this.privIsDisposed), n.marshalPromiseToCallbacks(this.dispose(!0), c, u);
    }
    async dispose(c) {
      this.privIsDisposed || c && (this.privIsDisposed = !0, await this.implRecognizerStop(), await super.dispose(c));
    }
    createRecognizerConfig(c) {
      return new e.RecognizerConfig(c, this.privProperties);
    }
    createServiceRecognizer(c, u, p, d) {
      const l = p;
      return new e.DialogServiceAdapter(c, u, l, d, this);
    }
    buildAgentConfig() {
      return {
        botInfo: {
          commType: this.properties.getProperty("Conversation_Communication_Type", "Default"),
          commandsCulture: void 0,
          connectionId: this.properties.getProperty(o.PropertyId.Conversation_Agent_Connection_Id),
          conversationId: this.properties.getProperty(o.PropertyId.Conversation_Conversation_Id, void 0),
          fromId: this.properties.getProperty(o.PropertyId.Conversation_From_Id, void 0),
          ttsAudioFormat: this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)
        },
        version: 0.2
      };
    }
  };
  return $r.DialogServiceConnector = a, $r;
}
var ia = {};
Object.defineProperty(ia, "__esModule", { value: !0 });
ia.ActivityReceivedEventArgs = void 0;
class d0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {any} activity - The activity..
   */
  constructor(e, n) {
    this.privActivity = e, this.privAudioStream = n;
  }
  /**
   * Gets the received activity
   * @member ActivityReceivedEventArgs.prototype.activity
   * @function
   * @public
   * @returns {any} the received activity.
   */
  get activity() {
    return this.privActivity;
  }
  get audioStream() {
    return this.privAudioStream;
  }
}
ia.ActivityReceivedEventArgs = d0;
var sa = {}, oa = {};
Object.defineProperty(oa, "__esModule", { value: !0 });
oa.TurnStatusResponsePayload = void 0;
class wu {
  constructor(e) {
    this.privMessageStatusResponse = JSON.parse(e);
  }
  static fromJSON(e) {
    return new wu(e);
  }
  get interactionId() {
    return this.privMessageStatusResponse.interactionId;
  }
  get conversationId() {
    return this.privMessageStatusResponse.conversationId;
  }
  get statusCode() {
    switch (this.privMessageStatusResponse.statusCode) {
      case "Success":
        return 200;
      case "Failed":
        return 400;
      case "TimedOut":
        return 429;
      default:
        return this.privMessageStatusResponse.statusCode;
    }
  }
}
oa.TurnStatusResponsePayload = wu;
Object.defineProperty(sa, "__esModule", { value: !0 });
sa.TurnStatusReceivedEventArgs = void 0;
const l0 = oa;
class h0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} turnStatus - The JSON-encoded turn status message.
   */
  constructor(e) {
    this.privTurnStatus = l0.TurnStatusResponsePayload.fromJSON(e);
  }
  /**
   * Gets the interaction identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.interactionId
   * @function
   * @public
   * @returns {any} the received interaction id.
   */
  get interactionId() {
    return this.privTurnStatus.interactionId;
  }
  /**
   * Gets the conversation identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.conversationId
   * @function
   * @public
   * @returns {any} the received conversation id.
   */
  get conversationId() {
    return this.privTurnStatus.conversationId;
  }
  /**
   * Gets the received turn status code.
   * @member TurnStatusReceivedEventArgs.prototype.statusCode
   * @function
   * @public
   * @returns {number} the received turn status.
   */
  get statusCode() {
    return this.privTurnStatus.statusCode;
  }
}
sa.TurnStatusReceivedEventArgs = h0;
var If = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ServicePropertyChannel = void 0, function(e) {
    e[e.UriQueryParameter = 0] = "UriQueryParameter";
  }(t.ServicePropertyChannel || (t.ServicePropertyChannel = {}));
})(If);
var bf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ProfanityOption = void 0, function(e) {
    e[e.Masked = 0] = "Masked", e[e.Removed = 1] = "Removed", e[e.Raw = 2] = "Raw";
  }(t.ProfanityOption || (t.ProfanityOption = {}));
})(bf);
var Wr = {}, Sd;
function v0() {
  if (Sd)
    return Wr;
  Sd = 1, Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.BaseAudioPlayer = void 0;
  const t = Ee, e = P(), n = Wt;
  let r = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */
    constructor(o) {
      this.audioContext = null, this.gainNode = null, this.autoUpdateBufferTimer = 0, o === void 0 && (o = e.AudioStreamFormat.getDefaultInputFormat()), this.init(o);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */
    playAudioSample(o, a, i) {
      try {
        this.ensureInitializedContext();
        const c = this.formatAudioData(o), u = new Float32Array(this.samples.length + c.length);
        u.set(this.samples, 0), u.set(c, this.samples.length), this.samples = u, a && a();
      } catch (c) {
        i && i(c);
      }
    }
    /**
     * stops audio and clears the buffers
     */
    stopAudio(o, a) {
      this.audioContext !== null && (this.samples = new Float32Array(), clearInterval(this.autoUpdateBufferTimer), this.audioContext.close().then(() => {
        o && o();
      }, (i) => {
        a && a(i);
      }), this.audioContext = null);
    }
    init(o) {
      this.audioFormat = o, this.samples = new Float32Array();
    }
    ensureInitializedContext() {
      if (this.audioContext === null) {
        this.createAudioContext();
        const o = 200;
        this.autoUpdateBufferTimer = setInterval(() => {
          this.updateAudioBuffer();
        }, o);
      }
    }
    createAudioContext() {
      this.audioContext = n.AudioStreamFormatImpl.getAudioContext(), this.gainNode = this.audioContext.createGain(), this.gainNode.gain.value = 1, this.gainNode.connect(this.audioContext.destination), this.startTime = this.audioContext.currentTime;
    }
    formatAudioData(o) {
      switch (this.audioFormat.bitsPerSample) {
        case 8:
          return this.formatArrayBuffer(new Int8Array(o), 128);
        case 16:
          return this.formatArrayBuffer(new Int16Array(o), 32768);
        case 32:
          return this.formatArrayBuffer(new Int32Array(o), 2147483648);
        default:
          throw new t.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
      }
    }
    formatArrayBuffer(o, a) {
      const i = new Float32Array(o.length);
      for (let c = 0; c < o.length; c++)
        i[c] = o[c] / a;
      return i;
    }
    updateAudioBuffer() {
      if (this.samples.length === 0)
        return;
      const o = this.audioFormat.channels, a = this.audioContext.createBufferSource(), i = this.samples.length / o, c = this.audioContext.createBuffer(o, i, this.audioFormat.samplesPerSec);
      for (let u = 0; u < o; u++) {
        let p = u;
        const d = c.getChannelData(u);
        for (let l = 0; l < this.samples.length; l++, p += o)
          d[l] = this.samples[p];
      }
      this.startTime < this.audioContext.currentTime && (this.startTime = this.audioContext.currentTime), a.buffer = c, a.connect(this.gainNode), a.start(this.startTime), this.startTime += c.duration, this.samples = new Float32Array();
    }
    async playAudio(o) {
      this.audioContext === null && this.createAudioContext();
      const a = this.audioContext.createBufferSource(), i = this.audioContext.destination;
      await this.audioContext.decodeAudioData(o, (c) => {
        a.buffer = c, a.connect(i), a.start(0);
      });
    }
  };
  return Wr.BaseAudioPlayer = r, Wr;
}
var aa = {};
Object.defineProperty(aa, "__esModule", { value: !0 });
aa.ConnectionMessageEventArgs = void 0;
class f0 {
  constructor(e) {
    this.privConnectionMessage = e;
  }
  /**
   * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
   */
  get message() {
    return this.privConnectionMessage;
  }
  /**
   * Returns a string that represents the connection message event.
   */
  toString() {
    return "Message: " + this.privConnectionMessage.toString();
  }
}
aa.ConnectionMessageEventArgs = f0;
var ca = {};
Object.defineProperty(ca, "__esModule", { value: !0 });
ca.VoiceProfile = void 0;
class g0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} profileId - profileId of this Voice Profile.
   * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
   */
  constructor(e, n) {
    this.privId = e, this.privProfileType = n;
  }
  /**
   * profileId of this Voice Profile instance
   * @member VoiceProfile.prototype.profileId
   * @function
   * @public
   * @returns {string} profileId of this Voice Profile instance.
   */
  get profileId() {
    return this.privId;
  }
  /**
   * profileType of this Voice Profile instance
   * @member VoiceProfile.prototype.profileType
   * @function
   * @public
   * @returns {VoiceProfileType} profile type of this Voice Profile instance.
   */
  get profileType() {
    return this.privProfileType;
  }
}
ca.VoiceProfile = g0;
var Yt = {}, yd;
function m0() {
  if (yd)
    return Yt;
  yd = 1, Object.defineProperty(Yt, "__esModule", { value: !0 }), Yt.VoiceProfileEnrollmentCancellationDetails = Yt.VoiceProfileEnrollmentResult = void 0;
  const t = b(), e = P();
  let n = class Bc {
    constructor(o, a, i) {
      this.privReason = o, this.privProperties = new e.PropertyCollection(), this.privReason !== e.ResultReason.Canceled ? a && (this.privDetails = JSON.parse(a), this.privDetails.enrollmentStatus.toLowerCase() === "enrolling" && (this.privReason = e.ResultReason.EnrollingVoiceProfile)) : (this.privErrorDetails = i, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[e.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get enrollmentsCount() {
      return this.privDetails.enrollmentsCount;
    }
    get enrollmentsLength() {
      return this.privDetails.enrollmentsLength;
    }
    get properties() {
      return this.privProperties;
    }
    get enrollmentResultDetails() {
      return this.privDetails;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
    static FromIdentificationProfileList(o) {
      const a = [];
      for (const i of o.value) {
        const c = i.enrollmentStatus.toLowerCase() === "enrolling" ? e.ResultReason.EnrollingVoiceProfile : i.enrollmentStatus.toLowerCase() === "enrolled" ? e.ResultReason.EnrolledVoiceProfile : e.ResultReason.Canceled, u = new Bc(c, null, null);
        u.privDetails = this.getIdentificationDetails(i), a.push(u);
      }
      return a;
    }
    static FromVerificationProfileList(o) {
      const a = [];
      for (const i of o.value) {
        const c = i.enrollmentStatus.toLowerCase() === "enrolling" ? e.ResultReason.EnrollingVoiceProfile : i.enrollmentStatus.toLowerCase() === "enrolled" ? e.ResultReason.EnrolledVoiceProfile : e.ResultReason.Canceled, u = new Bc(c, null, null);
        u.privDetails = this.getVerificationDetails(i), a.push(u);
      }
      return a;
    }
    static getIdentificationDetails(o) {
      return {
        audioLength: o.audioLength ? parseFloat(o.audioLength) : 0,
        audioSpeechLength: o.audioSpeechLength ? parseFloat(o.audioSpeechLength) : 0,
        enrollmentStatus: o.enrollmentStatus,
        enrollmentsCount: o.enrollmentsCount || 0,
        enrollmentsLength: o.enrollmentsLength ? parseFloat(o.enrollmentsLength) : 0,
        enrollmentsSpeechLength: o.enrollmentsSpeechLength ? parseFloat(o.enrollmentsSpeechLength) : 0,
        profileId: o.profileId || o.identificationProfileId,
        remainingEnrollmentsSpeechLength: o.remainingEnrollmentsSpeechLength ? parseFloat(o.remainingEnrollmentsSpeechLength) : 0
      };
    }
    static getVerificationDetails(o) {
      return {
        audioLength: o.audioLength ? parseFloat(o.audioLength) : 0,
        audioSpeechLength: o.audioSpeechLength ? parseFloat(o.audioSpeechLength) : 0,
        enrollmentStatus: o.enrollmentStatus,
        enrollmentsCount: o.enrollmentsCount,
        enrollmentsLength: o.enrollmentsLength ? parseFloat(o.enrollmentsLength) : 0,
        enrollmentsSpeechLength: o.enrollmentsSpeechLength ? parseFloat(o.enrollmentsSpeechLength) : 0,
        profileId: o.profileId || o.verificationProfileId,
        remainingEnrollmentsCount: o.remainingEnrollments || o.remainingEnrollmentsCount,
        remainingEnrollmentsSpeechLength: o.remainingEnrollmentsSpeechLength ? parseFloat(o.remainingEnrollmentsSpeechLength) : 0
      };
    }
  };
  Yt.VoiceProfileEnrollmentResult = n;
  class r extends e.CancellationDetailsBase {
    constructor(o, a, i) {
      super(o, a, i);
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */
    static fromResult(o) {
      const a = e.CancellationReason.Error;
      let i = e.CancellationErrorCode.NoError;
      return o.properties && (i = e.CancellationErrorCode[o.properties.getProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[e.CancellationErrorCode.NoError])]), new r(a, o.errorDetails, i);
    }
  }
  return Yt.VoiceProfileEnrollmentCancellationDetails = r, Yt;
}
var Zt = {}, Cd;
function S0() {
  if (Cd)
    return Zt;
  Cd = 1, Object.defineProperty(Zt, "__esModule", { value: !0 }), Zt.VoiceProfileCancellationDetails = Zt.VoiceProfileResult = void 0;
  const t = b(), e = D, n = P();
  let r = class {
    constructor(a, i) {
      this.privReason = a, this.privProperties = new n.PropertyCollection(), a === n.ResultReason.Canceled && (e.Contracts.throwIfNullOrUndefined(i, "statusText"), this.privErrorDetails = i, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get properties() {
      return this.privProperties;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  Zt.VoiceProfileResult = r;
  class s extends n.CancellationDetailsBase {
    constructor(a, i, c) {
      super(a, i, c);
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      const i = n.CancellationReason.Error;
      let c = n.CancellationErrorCode.NoError;
      return a.properties && (c = n.CancellationErrorCode[a.properties.getProperty(t.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.NoError])]), new s(i, a.errorDetails, c);
    }
  }
  return Zt.VoiceProfileCancellationDetails = s, Zt;
}
var Vr = {}, _d;
function y0() {
  if (_d)
    return Vr;
  _d = 1, Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.VoiceProfilePhraseResult = void 0;
  const t = D, e = P();
  let n = class extends e.VoiceProfileResult {
    constructor(s, o, a, i) {
      super(s, o), this.privPhrases = [], t.Contracts.throwIfNullOrUndefined(i, "phrase array"), this.privType = a, i && i[0] && (this.privPhrases = i);
    }
    get phrases() {
      return this.privPhrases;
    }
    get type() {
      return this.privType;
    }
  };
  return Vr.VoiceProfilePhraseResult = n, Vr;
}
var Kr = {}, Rd;
function C0() {
  if (Rd)
    return Kr;
  Rd = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.VoiceProfileClient = void 0;
  const t = b(), e = uf(), n = D, r = P();
  let s = class extends r.Recognizer {
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */
    constructor(a) {
      n.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const i = a;
      n.Contracts.throwIfNull(i, "speechConfig"), super(e.AudioConfig.fromStreamInput(r.AudioInputStream.createPushStream()), i.properties, new t.VoiceProfileConnectionFactory()), this.privProperties = i.properties.clone(), this.privVoiceAdapter = this.privReco, this.privDisposedVoiceAdapter = !1;
    }
    /**
     * The collection of properties and their values defined for this VoiceProfileClient.
     * @member VoiceProfileClient.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      n.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */
    async createProfileAsync(a, i) {
      const c = await this.privVoiceAdapter.createProfile(a, i);
      return new r.VoiceProfile(c[0], a);
    }
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async retrieveEnrollmentResultAsync(a) {
      return this.privVoiceAdapter.retrieveEnrollmentResult(a);
    }
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */
    async getAllProfilesAsync(a) {
      return this.privVoiceAdapter.getAllProfiles(a);
    }
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */
    async getActivationPhrasesAsync(a, i) {
      return this.privVoiceAdapter.getActivationPhrases(a, i);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async enrollProfileAsync(a, i) {
      const c = i;
      return n.Contracts.throwIfNullOrUndefined(c, "audioConfig"), this.audioConfig = i, this.privVoiceAdapter.SpeakerAudioSource = c, this.privVoiceAdapter.enrollProfile(a);
    }
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async deleteProfileAsync(a) {
      return this.privVoiceAdapter.deleteProfile(a);
    }
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async resetProfileAsync(a) {
      return this.privVoiceAdapter.resetProfile(a);
    }
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */
    async close() {
      await this.dispose(!0);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new t.VoiceServiceRecognizer(a, i, p, u, this);
    }
    async dispose(a) {
      this.privDisposedVoiceAdapter || (this.privDisposedVoiceAdapter = !0, a && await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.properties);
    }
    getResult(a, i) {
      return new r.VoiceProfileResult(a.ok ? i : r.ResultReason.Canceled, a.statusText);
    }
  };
  return Kr.VoiceProfileClient = s, Kr;
}
var Jr = {}, Pd;
function _0() {
  if (Pd)
    return Jr;
  Pd = 1, Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.SpeakerRecognizer = void 0;
  const t = b(), e = D, n = P();
  let r = class extends n.Recognizer {
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(o, a) {
      e.Contracts.throwIfNullOrUndefined(o, "speechConfig");
      const i = o;
      e.Contracts.throwIfNullOrUndefined(i, "speechConfig"), super(a, i.properties, new t.SpeakerRecognitionConnectionFactory()), this.privAudioConfigImpl = a, e.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig"), this.privDisposedSpeakerRecognizer = !1, this.privProperties = i.properties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(o) {
      e.Contracts.throwIfNullOrWhitespace(o, "token"), this.properties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, o);
    }
    /**
     * The collection of properties and their values defined for this SpeakerRecognizer.
     * @member SpeakerRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */
    async recognizeOnceAsync(o) {
      return e.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), this.recognizeSpeakerOnceAsyncImpl(o);
    }
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */
    async close() {
      e.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.dispose(!0);
    }
    async recognizeSpeakerOnceAsyncImpl(o) {
      e.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.implRecognizerStop();
      const a = await this.privReco.recognizeSpeaker(o);
      return await this.implRecognizerStop(), a;
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    createRecognizerConfig(o) {
      return new t.RecognizerConfig(o, this.privProperties);
    }
    createServiceRecognizer(o, a, i, c) {
      const u = i;
      return new t.SpeakerServiceRecognizer(o, a, u, c, this);
    }
    async dispose(o) {
      this.privDisposedSpeakerRecognizer || o && (this.privDisposedSpeakerRecognizer = !0, await super.dispose(o));
    }
  };
  return Jr.SpeakerRecognizer = r, Jr;
}
var Gr = {}, Ed;
function R0() {
  if (Ed)
    return Gr;
  Ed = 1, Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.SpeakerIdentificationModel = void 0;
  const t = D, e = P();
  let n = class Af {
    constructor(s) {
      if (this.privVoiceProfiles = [], this.privProfileIds = [], t.Contracts.throwIfNullOrUndefined(s, "VoiceProfiles"), s.length === 0)
        throw new Error("Empty Voice Profiles array");
      for (const o of s) {
        if (o.profileType !== e.VoiceProfileType.TextIndependentIdentification)
          throw new Error("Identification model can only be created from Identification profile: " + o.profileId);
        this.privVoiceProfiles.push(o), this.privProfileIds.push(o.profileId);
      }
    }
    static fromProfiles(s) {
      return new Af(s);
    }
    get voiceProfileIds() {
      return this.privProfileIds.join(",");
    }
    get profileIds() {
      return this.privProfileIds;
    }
    get scenario() {
      return "TextIndependentIdentification";
    }
  };
  return Gr.SpeakerIdentificationModel = n, Gr;
}
var Qr = {}, Td;
function P0() {
  if (Td)
    return Qr;
  Td = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.SpeakerVerificationModel = void 0;
  const t = D, e = P();
  let n = class Mf {
    constructor(s) {
      if (t.Contracts.throwIfNullOrUndefined(s, "VoiceProfile"), s.profileType === e.VoiceProfileType.TextIndependentIdentification)
        throw new Error("Verification model cannot be created from Identification profile");
      this.privVoiceProfile = s;
    }
    static fromProfile(s) {
      return new Mf(s);
    }
    get voiceProfile() {
      return this.privVoiceProfile;
    }
    get profileIds() {
      return [this.voiceProfile.profileId];
    }
    get scenario() {
      return this.voiceProfile.profileType === e.VoiceProfileType.TextDependentVerification ? "TextDependentVerification" : "TextIndependentVerification";
    }
  };
  return Qr.SpeakerVerificationModel = n, Qr;
}
var Yr = {}, Iu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LanguageIdMode = void 0, function(e) {
    e[e.AtStart = 0] = "AtStart", e[e.Continuous = 1] = "Continuous";
  }(t.LanguageIdMode || (t.LanguageIdMode = {}));
})(Iu);
var wd;
function E0() {
  if (wd)
    return Yr;
  wd = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.AutoDetectSourceLanguageConfig = void 0;
  const t = b(), e = D, n = P(), r = Iu;
  let s = class to {
    constructor() {
      this.privProperties = new n.PropertyCollection(), this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart"), this.privLanguageIdMode = r.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */
    static fromOpenRange() {
      const a = new to();
      return a.properties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, t.AutoDetectSourceLanguagesOpenRangeOptionName), a;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */
    static fromLanguages(a) {
      e.Contracts.throwIfArrayEmptyOrWhitespace(a, "languages");
      const i = new to();
      return i.properties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, a.join()), i;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */
    static fromSourceLanguageConfigs(a) {
      if (a.length < 1)
        throw new Error("Expected non-empty SourceLanguageConfig array.");
      const i = new to(), c = [];
      return a.forEach((u) => {
        if (c.push(u.language), u.endpointId !== void 0 && u.endpointId !== "") {
          const p = u.language + n.PropertyId.SpeechServiceConnection_EndpointId.toString();
          i.properties.setProperty(p, u.endpointId);
        }
      }), i.properties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, c.join()), i;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets an auto detected language config properties
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.mode
     * @function
     * @public
     * @param {LanguageIdMode} mode LID mode desired.
     * @summary Sets LID operation to desired mode
     */
    set mode(a) {
      a === r.LanguageIdMode.Continuous ? (this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous")) : (this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart")), this.privLanguageIdMode = a;
    }
  };
  return Yr.AutoDetectSourceLanguageConfig = s, Yr;
}
var ua = {};
Object.defineProperty(ua, "__esModule", { value: !0 });
ua.AutoDetectSourceLanguageResult = void 0;
const Id = D;
class po {
  constructor(e, n) {
    Id.Contracts.throwIfNullOrUndefined(e, "language"), Id.Contracts.throwIfNullOrUndefined(n, "languageDetectionConfidence"), this.privLanguage = e, this.privLanguageDetectionConfidence = n;
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
   * @member AutoDetectSourceLanguageResult.fromResult
   * @function
   * @public
   * @param {SpeechRecognitionResult} result - The recognition result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromResult(e) {
    return new po(e.language, e.languageDetectionConfidence);
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
   * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
   * @function
   * @public
   * @param {ConversationTranscriptionResult} result - The transcription result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromConversationTranscriptionResult(e) {
    return new po(e.language, e.languageDetectionConfidence);
  }
  get language() {
    return this.privLanguage;
  }
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
}
ua.AutoDetectSourceLanguageResult = po;
var pa = {};
Object.defineProperty(pa, "__esModule", { value: !0 });
pa.SourceLanguageConfig = void 0;
const T0 = D;
class bu {
  constructor(e, n) {
    T0.Contracts.throwIfNullOrUndefined(e, "language"), this.privLanguage = e, this.privEndpointId = n;
  }
  /**
   * @member SourceLanguageConfig.fromLanguage
   * @function
   * @public
   * @param {string} language language (eg. "en-US") value of config.
   * @param {string?} endpointId endpointId of model bound to given language of config.
   * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
   * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
   * Added in version 1.13.0.
   */
  static fromLanguage(e, n) {
    return new bu(e, n);
  }
  get language() {
    return this.privLanguage;
  }
  get endpointId() {
    return this.privEndpointId;
  }
}
pa.SourceLanguageConfig = bu;
var lc = {}, bd;
function w0() {
  return bd || (bd = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SpeakerRecognitionCancellationDetails = t.SpeakerRecognitionResult = t.SpeakerRecognitionResultType = void 0;
    const e = b(), n = P();
    var r;
    (function(a) {
      a[a.Verify = 0] = "Verify", a[a.Identify = 1] = "Identify";
    })(r = t.SpeakerRecognitionResultType || (t.SpeakerRecognitionResultType = {}));
    class s {
      constructor(i, c = n.ResultReason.RecognizedSpeaker, u = n.CancellationErrorCode.NoError, p = "") {
        this.privProperties = new n.PropertyCollection();
        const d = i.scenario === "TextIndependentIdentification" ? r.Identify : r.Verify;
        this.privReason = c, this.privReason !== n.ResultReason.Canceled ? d === r.Identify ? (this.privProfileId = i.identificationResult.identifiedProfile.profileId, this.privScore = i.identificationResult.identifiedProfile.score, this.privReason = n.ResultReason.RecognizedSpeakers) : (this.privScore = i.verificationResult.score, i.verificationResult.recognitionResult.toLowerCase() !== "accept" && (this.privReason = n.ResultReason.NoMatch), i.verificationResult.profileId !== void 0 && i.verificationResult.profileId !== "" && (this.privProfileId = i.verificationResult.profileId)) : (this.privErrorDetails = p, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, n.CancellationErrorCode[u])), this.privProperties.setProperty(n.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(i));
      }
      get properties() {
        return this.privProperties;
      }
      get reason() {
        return this.privReason;
      }
      get profileId() {
        return this.privProfileId;
      }
      get errorDetails() {
        return this.privErrorDetails;
      }
      get score() {
        return this.privScore;
      }
    }
    t.SpeakerRecognitionResult = s;
    class o extends n.CancellationDetailsBase {
      constructor(i, c, u) {
        super(i, c, u);
      }
      /**
       * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
       * @member SpeakerRecognitionCancellationDetails.fromResult
       * @function
       * @public
       * @param {SpeakerRecognitionResult} result - The result that was canceled.
       * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
       */
      static fromResult(i) {
        const c = n.CancellationReason.Error;
        let u = n.CancellationErrorCode.NoError;
        return i.properties && (u = n.CancellationErrorCode[i.properties.getProperty(e.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.NoError])]), new o(c, i.errorDetails, u);
      }
    }
    t.SpeakerRecognitionCancellationDetails = o;
  }(lc)), lc;
}
var hc = {}, Xt = {}, Ad;
function Of() {
  if (Ad)
    return Xt;
  Ad = 1, Object.defineProperty(Xt, "__esModule", { value: !0 }), Xt.ConversationImpl = Xt.Conversation = void 0;
  const t = b(), e = O(), n = D, r = P();
  let s = class {
    constructor() {
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */
    static createConversationAsync(i, c, u, p) {
      n.Contracts.throwIfNullOrUndefined(i, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), n.Contracts.throwIfNullOrUndefined(i.region, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), !i.subscriptionKey && !i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceAuthorization_Token]) && n.Contracts.throwIfNullOrUndefined(i.subscriptionKey, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      let d, l, h;
      return typeof c == "string" ? (d = new o(i, c), e.marshalPromiseToCallbacks((async () => {
      })(), u, p)) : (d = new o(i), l = c, h = u, d.createConversationAsync(() => {
        l && l();
      }, (v) => {
        h && h(v);
      })), d;
    }
  };
  Xt.Conversation = s;
  class o extends s {
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(i, c) {
      if (super(), this.privErrors = t.ConversationConnectionConfig.restErrors, this.onConnected = (d) => {
        var l;
        this.privIsConnected = !0;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onDisconnected = (d) => {
        var l;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, d);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (d, l) => {
        var h;
        try {
          (h = this.privConversationTranslator) != null && h.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, l);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.id);
          if (h !== void 0) {
            switch (l.key) {
              case t.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = l.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, [this.toParticipant(h)], l.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (d, l) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : l.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, this.toParticipants(!1), l.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(l.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], l.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(l.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], l.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (d, l) => {
        try {
          switch (l.command) {
            case t.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (d, l) => {
        var h;
        try {
          if (l.sessionToken !== void 0 && l.sessionToken !== null && (this.privRoom.token = l.sessionToken), this.privParticipants.participants = [...l.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), l.sessionId)), this.me.isHost) {
            const v = (h = this.privConversationTranslator) == null ? void 0 : h.properties.getProperty(r.PropertyId.ConversationTranslator_Name);
            v !== void 0 && v.length > 0 && v !== this.me.displayName && this.changeNicknameAsync(v);
          }
        } catch {
        }
      }, this.onConversationExpiration = (d, l) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, l);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new r.PropertyCollection(), this.privManager = new t.ConversationManager(), i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]) || i.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage], t.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), c)
        this.privConversationId = c;
      else {
        i.targetLanguages.length === 0 && i.addTargetLanguage(this.privLanguage), i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceResponse_ProfanityOption]) || i.setProfanity(r.ProfanityOption.Masked);
        let l = i.getProperty(r.PropertyId[r.PropertyId.ConversationTranslator_Name]);
        l == null && (l = "Host"), n.Contracts.throwIfNullOrTooLong(l, "nickname", 50), n.Contracts.throwIfNullOrTooShort(l, "nickname", 2), i.setProperty(r.PropertyId[r.PropertyId.ConversationTranslator_Name], l);
      }
      this.privConfig = i;
      const p = i;
      n.Contracts.throwIfNull(p, "speechConfig"), this.privProperties = p.properties.clone(), this.privIsConnected = !1, this.privParticipants = new t.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the conversation Id
    get conversationId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      var i, c;
      return (i = this.privParticipants.me) != null && i.isHost ? !1 : (c = this.privParticipants.me) == null ? void 0 : c.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get conversationInfo() {
      const i = this.conversationId, c = this.participants.map((d) => ({
        id: d.id,
        preferredLanguage: d.preferredLanguage,
        voice: d.voice
      })), u = {};
      for (const d of t.ConversationConnectionConfig.transcriptionEventKeys) {
        const l = this.properties.getProperty(d, "");
        l !== "" && (u[d] = l);
      }
      return { id: i, participants: c, conversationProperties: u };
    }
    get canSend() {
      var i;
      return this.privIsConnected && !((i = this.privParticipants.me) != null && i.isMuted);
    }
    get canSendAsHost() {
      var i;
      return this.privIsConnected && ((i = this.privParticipants.me) == null ? void 0 : i.isHost);
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "authorizationToken"), this.privToken = i;
    }
    set conversationTranslator(i) {
      this.privConversationTranslator = i;
    }
    onToken(i) {
      this.privConversationTranslator.onToken(i);
    }
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */
    createConversationAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */
    startConversationAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer = t.ConversationRecognizerFactory.fromConfig(this, this.privConfig), this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(i, c, u) {
      n.Contracts.throwIfNullOrUndefined(i, "Participant"), e.marshalPromiseToCallbacks(this.addParticipantImplAsync(i), c, u);
    }
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinConversationAsync(i, c, u, p, d) {
      try {
        n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), n.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, i, (l) => {
          n.Contracts.throwIfNullOrUndefined(l, this.privErrors.permissionDeniedConnect), this.privRoom = l, this.privConfig.authorizationToken = l.cognitiveSpeechAuthToken, p && p(l.cognitiveSpeechAuthToken);
        }, (l) => {
          this.handleError(l, d);
        });
      } catch (l) {
        this.handleError(l, d);
      }
    }
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */
    deleteConversationAsync(i, c) {
      e.marshalPromiseToCallbacks(this.deleteConversationImplAsync(), i, c);
    }
    async deleteConversationImplAsync() {
      n.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), n.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endConversationAsync(i, c) {
      e.marshalPromiseToCallbacks(this.endConversationImplAsync(), i, c);
    }
    endConversationImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockConversationAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !0), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(i, c, u) {
      try {
        if (n.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && i.hasOwnProperty("id"))
          e.marshalPromiseToCallbacks(this.removeParticipantImplAsync(i), c, u);
        else {
          n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let p = "";
          typeof i == "string" ? p = i : i.hasOwnProperty("id") ? p = i.id : i.hasOwnProperty("userId") && (p = i.userId), n.Contracts.throwIfNullOrWhitespace(p, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((l) => l.id === p) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(p), () => {
            this.handleCallback(c, u);
          }, (l) => {
            this.handleError(l, u);
          });
        }
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */
    unlockConversationAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !1), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "message")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), i.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfArrayEmptyOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "languages")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(i) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await i.enforceAudioGating(), this.privTranscriberRecognizer = i, this.privTranscriberRecognizer.conversation = this;
    }
    getKeepAlive() {
      const i = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: i,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(i) {
      if (this.privParticipants.addOrUpdateParticipant(i) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.conversationInfo;
        return u.participants = [i], this.privTranscriberRecognizer.pushConversationEvent(u, "join");
      }
    }
    removeParticipantImplAsync(i) {
      this.privParticipants.deleteParticipant(i.id);
      const c = this.conversationInfo;
      return c.participants = [i], this.privTranscriberRecognizer.pushConversationEvent(c, "leave");
    }
    async close(i) {
      var c;
      try {
        this.privIsConnected = !1, await ((c = this.privConversationRecognizer) == null ? void 0 : c.close()), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (u) {
        throw u;
      }
      i && this.dispose();
    }
    /** Helpers */
    handleCallback(i, c) {
      if (i) {
        try {
          i();
        } catch (u) {
          c && c(u);
        }
        i = void 0;
      }
    }
    handleError(i, c) {
      if (c)
        if (i instanceof Error) {
          const u = i;
          c(u.name + ": " + u.message);
        } else
          c(i);
    }
    /** Participant Helpers */
    toParticipants(i) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return i ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(i) {
      return new r.Participant(i.id, i.avatar, i.displayName, i.isHost, i.isMuted, i.isUsingTts, i.preferredLanguage, i.voice);
    }
    getMuteAllCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMuteCommand(i, c) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getEjectCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getChangeNicknameCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "nickname"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.changeNickname,
        nickname: i,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMessageCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), n.Contracts.throwIfNullOrWhitespace(i, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: i,
        type: t.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return Xt.ConversationImpl = o, Xt;
}
var da = {};
Object.defineProperty(da, "__esModule", { value: !0 });
da.ConversationCommon = void 0;
class I0 {
  constructor(e) {
    this.privAudioConfig = e;
  }
  handleCallback(e, n) {
    if (e) {
      try {
        e();
      } catch (r) {
        n && n(r);
      }
      e = void 0;
    }
  }
  handleError(e, n) {
    if (n)
      if (e instanceof Error) {
        const r = e;
        n(r.name + ": " + r.message);
      } else
        n(e);
  }
}
da.ConversationCommon = I0;
var Zr = {}, Md;
function b0() {
  if (Md)
    return Zr;
  Md = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.ConversationExpirationEventArgs = void 0;
  const t = P();
  let e = class extends t.SessionEventArgs {
    constructor(r, s) {
      super(s), this.privExpirationTime = r;
    }
    /** How much longer until the conversation expires (in minutes). */
    get expirationTime() {
      return this.privExpirationTime;
    }
  };
  return Zr.ConversationExpirationEventArgs = e, Zr;
}
var Xr = {}, Od;
function A0() {
  if (Od)
    return Xr;
  Od = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.ConversationParticipantsChangedEventArgs = void 0;
  const t = P();
  let e = class extends t.SessionEventArgs {
    constructor(r, s, o) {
      super(o), this.privReason = r, this.privParticipant = s;
    }
    get reason() {
      return this.privReason;
    }
    get participants() {
      return this.privParticipant;
    }
  };
  return Xr.ConversationParticipantsChangedEventArgs = e, Xr;
}
var ei = {}, kd;
function M0() {
  if (kd)
    return ei;
  kd = 1, Object.defineProperty(ei, "__esModule", { value: !0 }), ei.ConversationTranslationCanceledEventArgs = void 0;
  const t = Ss();
  let e = class extends t.CancellationEventArgsBase {
  };
  return ei.ConversationTranslationCanceledEventArgs = e, ei;
}
var ti = {}, Dd;
function O0() {
  if (Dd)
    return ti;
  Dd = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.ConversationTranslationEventArgs = void 0;
  const t = P();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s, o) {
      super(s, o), this.privResult = r;
    }
    /**
     * Specifies the recognition result.
     * @returns {ConversationTranslationResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return ti.ConversationTranslationEventArgs = e, ti;
}
var ni = {}, Nd;
function k0() {
  if (Nd)
    return ni;
  Nd = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.ConversationTranslationResult = void 0;
  const t = vf();
  let e = class extends t.TranslationRecognitionResult {
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(s, a, i, c, u, p, void 0, void 0, d, l, h), this.privId = r, this.privOrigLang = o;
    }
    /**
     * The unique identifier for the participant this result is for.
     */
    get participantId() {
      return this.privId;
    }
    /**
     * The original language this result was in.
     */
    get originalLang() {
      return this.privOrigLang;
    }
  };
  return ni.ConversationTranslationResult = e, ni;
}
var vc = {}, ri = {}, Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
Cs.StringUtils = void 0;
class D0 {
  /**
   * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
   * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
   * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
   * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
   * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
   */
  static formatString(e, n) {
    if (!e)
      return "";
    if (!n)
      return e;
    let r = "", s = "";
    const o = (c) => {
      r += c;
    }, a = (c) => {
      s += c;
    };
    let i = o;
    for (let c = 0; c < e.length; c++) {
      const u = e[c], p = c + 1 < e.length ? e[c + 1] : "";
      switch (u) {
        case "{":
          p === "{" ? (i("{"), c++) : i = a;
          break;
        case "}":
          p === "}" ? (i("}"), c++) : (n.hasOwnProperty(s) && (r += n[s]), i = o, s = "");
          break;
        default:
          i(u);
          break;
      }
    }
    return r;
  }
}
Cs.StringUtils = D0;
var Ld;
function N0() {
  if (Ld)
    return ri;
  Ld = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.ConversationTranslatorConnectionFactory = void 0;
  const t = Se(), e = Cs, n = D, r = P(), s = me, o = st, a = ot(), i = b();
  let c = class kf extends a.ConnectionFactoryBase {
    constructor(p) {
      super(), n.Contracts.throwIfNullOrUndefined(p, "convGetter"), this.privConvGetter = p;
    }
    create(p, d, l) {
      const h = p.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE", v = this.privConvGetter().room, g = v.cognitiveSpeechRegion || p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region, ""), f = {
        hostSuffix: a.ConnectionFactoryBase.getHostSuffix(g),
        path: kf.CTS_VIRT_MIC_PATH,
        region: encodeURIComponent(g)
      };
      f[o.QueryParameterNames.Language] = encodeURIComponent(p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "")), f[o.QueryParameterNames.CtsMeetingId] = encodeURIComponent(v.roomId), f[o.QueryParameterNames.CtsDeviceId] = encodeURIComponent(v.participantId), f[o.QueryParameterNames.CtsIsParticipant] = v.isHost ? "" : "&" + o.QueryParameterNames.CtsIsParticipant;
      let m = "";
      const S = {}, y = {};
      if (h) {
        m = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint), m || (m = "wss://" + p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}") + "{path}"), m = e.StringUtils.formatString(m, f);
        const _ = new URL(m);
        _.searchParams.forEach((R, T) => {
          S[T] = R;
        }), new i.TranscriberConnectionFactory().setQueryParams(S, p, m), S[o.QueryParameterNames.CtsMeetingId] = f[o.QueryParameterNames.CtsMeetingId], S[o.QueryParameterNames.CtsDeviceId] = f[o.QueryParameterNames.CtsDeviceId], v.isHost || (S[o.QueryParameterNames.CtsIsParticipant] = ""), o.QueryParameterNames.Format in S || (S[o.QueryParameterNames.Format] = "simple"), _.searchParams.forEach((R, T) => {
          _.searchParams.set(T, S[T]), delete S[T];
        }), m = _.toString();
      } else {
        const _ = new i.TranslationConnectionFactory();
        m = _.getEndpointUrl(p, !0), m = e.StringUtils.formatString(m, f), _.setQueryParams(S, p, m);
      }
      y[s.HeaderNames.ConnectionId] = l, y[t.RestConfigBase.configParams.token] = v.token, d.token && (y[d.headerName] = d.token);
      const E = p.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
      return new t.WebsocketConnection(m, S, y, new i.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(p), E, l);
    }
  };
  return ri.ConversationTranslatorConnectionFactory = c, c.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio", ri;
}
var zd;
function L0() {
  return zd || (zd = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ConversationTranslator = t.SpeechState = void 0;
    const e = b(), n = N0(), r = O(), s = D, o = P(), a = Of(), i = Au();
    var c;
    (function(d) {
      d[d.Inactive = 0] = "Inactive", d[d.Connecting = 1] = "Connecting", d[d.Connected = 2] = "Connected";
    })(c = t.SpeechState || (t.SpeechState = {}));
    class u extends o.TranslationRecognizer {
      constructor(l, h, v, g) {
        super(l, h, new n.ConversationTranslatorConnectionFactory(g)), this.privSpeechState = c.Inactive, v && (this.privTranslator = v, this.sessionStarted = () => {
          this.privSpeechState = c.Connected;
        }, this.sessionStopped = () => {
          this.privSpeechState = c.Inactive;
        }, this.recognizing = (f, m) => {
          this.privTranslator.recognizing && this.privTranslator.recognizing(this.privTranslator, m);
        }, this.recognized = async (f, m) => {
          var S;
          (S = m.result) != null && S.errorDetails ? (await this.cancelSpeech(), this.fireCancelEvent(m.result.errorDetails)) : this.privTranslator.recognized && this.privTranslator.recognized(this.privTranslator, m);
        }, this.canceled = async () => {
          if (this.privSpeechState !== c.Inactive)
            try {
              await this.cancelSpeech();
            } catch {
              this.privSpeechState = c.Inactive;
            }
        });
      }
      get state() {
        return this.privSpeechState;
      }
      set state(l) {
        this.privSpeechState = l;
      }
      set authentication(l) {
        this.privReco.authentication = l;
      }
      onConnection() {
        this.privSpeechState = c.Connected;
      }
      async onCancelSpeech() {
        this.privSpeechState = c.Inactive, await this.cancelSpeech();
      }
      /**
       * Fire a cancel event
       * @param error
       */
      fireCancelEvent(l) {
        try {
          if (this.privTranslator.canceled) {
            const h = new i.ConversationTranslationCanceledEventArgs(o.CancellationReason.Error, l, o.CancellationErrorCode.RuntimeError);
            this.privTranslator.canceled(this.privTranslator, h);
          }
        } catch {
        }
      }
      async cancelSpeech() {
        var l;
        try {
          this.stopContinuousRecognitionAsync(), await ((l = this.privReco) == null ? void 0 : l.disconnect()), this.privSpeechState = c.Inactive;
        } catch {
        }
      }
    }
    class p extends i.ConversationCommon {
      constructor(l) {
        super(l), this.privErrors = e.ConversationConnectionConfig.restErrors, this.privIsDisposed = !1, this.privIsSpeaking = !1, this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345", this.privPlaceholderRegion = "westus", this.privProperties = new o.PropertyCollection();
      }
      get properties() {
        return this.privProperties;
      }
      get speechRecognitionLanguage() {
        return this.privSpeechRecognitionLanguage;
      }
      get participants() {
        var l;
        return (l = this.privConversation) == null ? void 0 : l.participants;
      }
      get canSpeak() {
        return !(!this.privConversation.isConnected || !this.privCTRecognizer || this.privIsSpeaking || this.privCTRecognizer.state === c.Connected || this.privCTRecognizer.state === c.Connecting || this.privConversation.isMutedByHost);
      }
      onToken(l) {
        this.privCTRecognizer.authentication = l;
      }
      setServiceProperty(l, h) {
        const v = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
        v[l] = h, this.privProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(v));
      }
      joinConversationAsync(l, h, v, g, f) {
        try {
          if (typeof l == "string") {
            s.Contracts.throwIfNullOrUndefined(l, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), s.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privConversation && this.handleError(new Error(this.privErrors.permissionDeniedStart), f);
            let m = v;
            (m == null || m === "") && (m = e.ConversationConnectionConfig.defaultLanguageCode), this.privSpeechTranslationConfig = o.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion), this.privSpeechTranslationConfig.setProfanity(o.ProfanityOption.Masked), this.privSpeechTranslationConfig.addTargetLanguage(m), this.privSpeechTranslationConfig.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], m), this.privSpeechTranslationConfig.setProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name], h);
            const S = [
              o.PropertyId.SpeechServiceConnection_Host,
              o.PropertyId.ConversationTranslator_Host,
              o.PropertyId.SpeechServiceConnection_Endpoint,
              o.PropertyId.SpeechServiceConnection_ProxyHostName,
              o.PropertyId.SpeechServiceConnection_ProxyPassword,
              o.PropertyId.SpeechServiceConnection_ProxyPort,
              o.PropertyId.SpeechServiceConnection_ProxyUserName,
              "ConversationTranslator_MultiChannelAudio",
              "ConversationTranslator_Region"
            ];
            for (const E of S) {
              const _ = this.privProperties.getProperty(E);
              if (_) {
                const C = typeof E == "string" ? E : o.PropertyId[E];
                this.privSpeechTranslationConfig.setProperty(C, _);
              }
            }
            const y = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
            for (const E of Object.keys(y))
              this.privSpeechTranslationConfig.setServiceProperty(E, y[E], o.ServicePropertyChannel.UriQueryParameter);
            this.privConversation = new a.ConversationImpl(this.privSpeechTranslationConfig), this.privConversation.conversationTranslator = this, this.privConversation.joinConversationAsync(l, h, m, (E) => {
              E || this.handleError(new Error(this.privErrors.permissionDeniedConnect), f), this.privSpeechTranslationConfig.authorizationToken = E, this.privConversation.room.isHost = !1, this.privConversation.startConversationAsync(() => {
                this.handleCallback(g, f);
              }, (_) => {
                this.handleError(_, f);
              });
            }, (E) => {
              this.handleError(E, f);
            });
          } else
            typeof l == "object" ? (s.Contracts.throwIfNullOrUndefined(l, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), s.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privProperties.setProperty(o.PropertyId.ConversationTranslator_Name, h), this.privConversation = l, this.privConversation.conversationTranslator = this, this.privConversation.room.isHost = !0, s.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect), s.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privSpeechTranslationConfig = l.config, this.handleCallback(v, g)) : this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), g);
        } catch (m) {
          this.handleError(m, typeof v == "string" ? f : g);
        }
      }
      /**
       * Leave the conversation
       * @param cb
       * @param err
       */
      leaveConversationAsync(l, h) {
        r.marshalPromiseToCallbacks((async () => {
          await this.cancelSpeech(), await this.privConversation.endConversationImplAsync(), await this.privConversation.deleteConversationImplAsync(), this.dispose();
        })(), l, h);
      }
      /**
       * Send a text message
       * @param message
       * @param cb
       * @param err
       */
      sendTextMessageAsync(l, h, v) {
        try {
          s.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), s.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", l)), this.privConversation.sendTextMessageAsync(l, h, v);
        } catch (g) {
          this.handleError(g, v);
        }
      }
      /**
       * Start speaking
       * @param cb
       * @param err
       */
      startTranscribingAsync(l, h) {
        r.marshalPromiseToCallbacks((async () => {
          try {
            s.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), s.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privCTRecognizer === void 0 && await this.connectTranslatorRecognizer(), s.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend), this.canSpeak || this.handleError(new Error(this.privErrors.permissionDeniedSend), h), await this.startContinuousRecognition(), this.privIsSpeaking = !0;
          } catch (v) {
            throw this.privIsSpeaking = !1, await this.cancelSpeech(), v;
          }
        })(), l, h);
      }
      /**
       * Stop speaking
       * @param cb
       * @param err
       */
      stopTranscribingAsync(l, h) {
        r.marshalPromiseToCallbacks((async () => {
          try {
            if (!this.privIsSpeaking) {
              await this.cancelSpeech();
              return;
            }
            this.privIsSpeaking = !1, await new Promise((v, g) => {
              this.privCTRecognizer.stopContinuousRecognitionAsync(v, g);
            });
          } catch {
            await this.cancelSpeech();
          }
        })(), l, h);
      }
      isDisposed() {
        return this.privIsDisposed;
      }
      dispose(l, h, v) {
        r.marshalPromiseToCallbacks((async () => {
          this.isDisposed && !this.privIsSpeaking || (await this.cancelSpeech(), this.privIsDisposed = !0, this.privSpeechTranslationConfig.close(), this.privSpeechRecognitionLanguage = void 0, this.privProperties = void 0, this.privAudioConfig = void 0, this.privSpeechTranslationConfig = void 0, this.privConversation.dispose(), this.privConversation = void 0);
        })(), h, v);
      }
      /**
       * Cancel the speech websocket
       */
      async cancelSpeech() {
        var l;
        try {
          this.privIsSpeaking = !1, await ((l = this.privCTRecognizer) == null ? void 0 : l.onCancelSpeech()), this.privCTRecognizer = void 0;
        } catch {
        }
      }
      /**
       * Connect to the speech translation recognizer.
       * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
       * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
       * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
       */
      async connectTranslatorRecognizer() {
        try {
          this.privAudioConfig === void 0 && (this.privAudioConfig = o.AudioConfig.fromDefaultMicrophoneInput()), this.privSpeechTranslationConfig.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey && this.privSpeechTranslationConfig.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_Key], "");
          const l = () => this.privConversation;
          this.privCTRecognizer = new u(this.privSpeechTranslationConfig, this.privAudioConfig, this, l);
        } catch (l) {
          throw await this.cancelSpeech(), l;
        }
      }
      /**
       * Handle the start speaking request
       */
      startContinuousRecognition() {
        return new Promise((l, h) => {
          this.privCTRecognizer.startContinuousRecognitionAsync(l, h);
        });
      }
    }
    t.ConversationTranslator = p;
  }(vc)), vc;
}
var ii = {}, jd;
function z0() {
  if (jd)
    return ii;
  jd = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.ConversationTranscriber = void 0;
  const t = b(), e = O(), n = D, r = P();
  let s = class Df extends r.Recognizer {
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(a, i) {
      const c = a;
      n.Contracts.throwIfNull(c, "speechConfig"), n.Contracts.throwIfNullOrWhitespace(c.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(i, c.properties, new t.ConversationTranscriberConnectionFactory()), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privDisposedRecognizer = !1;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(a, i, c) {
      const u = a;
      return i.properties.mergeTo(u.properties), new Df(a, c);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for transcription.
     * @member ConversationTranscriber.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      n.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Gets the spoken language of transcription.
     * @member ConversationTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of transcription.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of transcription.
     * @member ConversationTranscriber.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of transcription.
     */
    get outputFormat() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]) === r.OutputFormat[r.OutputFormat.Simple] ? r.OutputFormat.Simple : r.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this conversation transcriber.
     * @member ConversationTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(a, i) {
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), a, i);
    }
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(a, i) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(a) {
      this.privDisposedRecognizer || (a && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return u.isSpeakerDiarizationEnabled = !0, new t.ConversationTranscriptionServiceRecognizer(a, i, p, u, this);
    }
  };
  return ii.ConversationTranscriber = s, ii;
}
var en = {}, xd;
function j0() {
  if (xd)
    return en;
  xd = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.Participant = en.User = void 0;
  const t = P();
  class e {
    constructor(s) {
      this.privUserId = s;
    }
    get userId() {
      return this.privUserId;
    }
  }
  en.User = e;
  class n {
    constructor(s, o, a, i, c, u, p, d) {
      this.privId = s, this.privAvatar = o, this.privDisplayName = a, this.privIsHost = i, this.privIsMuted = c, this.privIsUsingTts = u, this.privPreferredLanguage = p, this.privVoice = d, this.privProperties = new t.PropertyCollection();
    }
    get avatar() {
      return this.privAvatar;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get id() {
      return this.privId;
    }
    get preferredLanguage() {
      return this.privPreferredLanguage;
    }
    get isHost() {
      return this.privIsHost;
    }
    get isMuted() {
      return this.privIsMuted;
    }
    get isUsingTts() {
      return this.privIsUsingTts;
    }
    get voice() {
      return this.privVoice;
    }
    get properties() {
      return this.privProperties;
    }
    static From(s, o, a) {
      return new n(s, "", s, !1, !1, !1, o, a);
    }
  }
  return en.Participant = n, en;
}
var Nf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ParticipantChangedReason = void 0, function(e) {
    e[e.JoinedConversation = 0] = "JoinedConversation", e[e.LeftConversation = 1] = "LeftConversation", e[e.Updated = 2] = "Updated";
  }(t.ParticipantChangedReason || (t.ParticipantChangedReason = {}));
})(Nf);
var tn = {}, Bd;
function x0() {
  if (Bd)
    return tn;
  Bd = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.MeetingImpl = tn.Meeting = void 0;
  const t = b(), e = O(), n = D, r = P();
  let s = class {
    constructor() {
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param meetingId
     * @param cb
     * @param err
     */
    static createMeetingAsync(i, c, u, p) {
      if (n.Contracts.throwIfNullOrUndefined(i, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), n.Contracts.throwIfNullOrUndefined(i.region, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), n.Contracts.throwIfNull(c, "meetingId"), c.length === 0)
        throw new Error("meetingId cannot be empty");
      !i.subscriptionKey && !i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceAuthorization_Token]) && n.Contracts.throwIfNullOrUndefined(i.subscriptionKey, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      const d = new o(i, c);
      return e.marshalPromiseToCallbacks((async () => {
      })(), u, p), d;
    }
  };
  tn.Meeting = s;
  class o extends s {
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(i, c) {
      super(), this.privErrors = t.ConversationConnectionConfig.restErrors, this.onConnected = (d) => {
        var l;
        this.privIsConnected = !0;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onDisconnected = (d) => {
        var l;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, d);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (d, l) => {
        var h;
        try {
          (h = this.privConversationTranslator) != null && h.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, l);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.id);
          if (h !== void 0) {
            switch (l.key) {
              case t.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = l.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, [this.toParticipant(h)], l.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (d, l) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : l.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, this.toParticipants(!1), l.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(l.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], l.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(l.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], l.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (d, l) => {
        try {
          switch (l.command) {
            case t.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (d, l) => {
        var h;
        try {
          if (l.sessionToken !== void 0 && l.sessionToken !== null && (this.privRoom.token = l.sessionToken), this.privParticipants.participants = [...l.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), l.sessionId)), this.me.isHost) {
            const v = (h = this.privConversationTranslator) == null ? void 0 : h.properties.getProperty(r.PropertyId.ConversationTranslator_Name);
            v !== void 0 && v.length > 0 && v !== this.me.displayName && this.changeNicknameAsync(v);
          }
        } catch {
        }
      }, this.onConversationExpiration = (d, l) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, l);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new r.PropertyCollection(), this.privManager = new t.ConversationManager(), i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]) || i.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage], t.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), this.privConversationId = c, this.privConfig = i;
      const p = i;
      n.Contracts.throwIfNull(p, "speechConfig"), this.privProperties = p.properties.clone(), this.privIsConnected = !1, this.privParticipants = new t.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the meeting Id
    get meetingId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      var i, c;
      return (i = this.privParticipants.me) != null && i.isHost ? !1 : (c = this.privParticipants.me) == null ? void 0 : c.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get meetingInfo() {
      const i = this.meetingId, c = this.participants.map((d) => ({
        id: d.id,
        preferredLanguage: d.preferredLanguage,
        voice: d.voice
      })), u = {};
      for (const d of t.ConversationConnectionConfig.transcriptionEventKeys) {
        const l = this.properties.getProperty(d, "");
        l !== "" && (u[d] = l);
      }
      return { id: i, participants: c, meetingProperties: u };
    }
    get canSend() {
      var i;
      return this.privIsConnected && !((i = this.privParticipants.me) != null && i.isMuted);
    }
    get canSendAsHost() {
      var i;
      return this.privIsConnected && ((i = this.privParticipants.me) == null ? void 0 : i.isHost);
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "authorizationToken"), this.privToken = i;
    }
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */
    createMeetingAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */
    startMeetingAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(i, c, u) {
      n.Contracts.throwIfNullOrUndefined(i, "Participant"), e.marshalPromiseToCallbacks(this.addParticipantImplAsync(i), c, u);
    }
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinMeetingAsync(i, c, u, p, d) {
      try {
        n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), n.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, i, (l) => {
          n.Contracts.throwIfNullOrUndefined(l, this.privErrors.permissionDeniedConnect), this.privRoom = l, this.privConfig.authorizationToken = l.cognitiveSpeechAuthToken, p && p(l.cognitiveSpeechAuthToken);
        }, (l) => {
          this.handleError(l, d);
        });
      } catch (l) {
        this.handleError(l, d);
      }
    }
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */
    deleteMeetingAsync(i, c) {
      e.marshalPromiseToCallbacks(this.deleteMeetingImplAsync(), i, c);
    }
    async deleteMeetingImplAsync() {
      n.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), n.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endMeetingAsync(i, c) {
      e.marshalPromiseToCallbacks(this.endMeetingImplAsync(), i, c);
    }
    endMeetingImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockMeetingAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !0), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(i, c, u) {
      try {
        if (n.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && i.hasOwnProperty("id"))
          e.marshalPromiseToCallbacks(this.removeParticipantImplAsync(i), c, u);
        else {
          n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let p = "";
          typeof i == "string" ? p = i : i.hasOwnProperty("id") ? p = i.id : i.hasOwnProperty("userId") && (p = i.userId), n.Contracts.throwIfNullOrWhitespace(p, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((l) => l.id === p) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(p), () => {
            this.handleCallback(c, u);
          }, (l) => {
            this.handleError(l, u);
          });
        }
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */
    unlockMeetingAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !1), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "message")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), i.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfArrayEmptyOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "languages")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(i) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await i.enforceAudioGating(), this.privTranscriberRecognizer = i, this.privTranscriberRecognizer.meeting = this;
    }
    getKeepAlive() {
      const i = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: i,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(i) {
      if (this.privParticipants.addOrUpdateParticipant(i) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.meetingInfo;
        return u.participants = [i], this.privTranscriberRecognizer.pushMeetingEvent(u, "join");
      }
    }
    removeParticipantImplAsync(i) {
      this.privParticipants.deleteParticipant(i.id);
      const c = this.meetingInfo;
      return c.participants = [i], this.privTranscriberRecognizer.pushMeetingEvent(c, "leave");
    }
    async close(i) {
      var c;
      try {
        this.privIsConnected = !1, await ((c = this.privConversationRecognizer) == null ? void 0 : c.close()), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (u) {
        throw u;
      }
      i && this.dispose();
    }
    /** Helpers */
    handleCallback(i, c) {
      if (i) {
        try {
          i();
        } catch (u) {
          c && c(u);
        }
        i = void 0;
      }
    }
    handleError(i, c) {
      if (c)
        if (i instanceof Error) {
          const u = i;
          c(u.name + ": " + u.message);
        } else
          c(i);
    }
    /** Participant Helpers */
    toParticipants(i) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return i ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(i) {
      return new r.Participant(i.id, i.avatar, i.displayName, i.isHost, i.isMuted, i.isUsingTts, i.preferredLanguage, i.voice);
    }
    getMuteAllCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMuteCommand(i, c) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getEjectCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getChangeNicknameCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(i, "nickname"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.changeNickname,
        nickname: i,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMessageCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), n.Contracts.throwIfNullOrWhitespace(i, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: i,
        type: t.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return tn.MeetingImpl = o, tn;
}
var si = {}, qd;
function B0() {
  if (qd)
    return si;
  qd = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.MeetingTranscriptionCanceledEventArgs = void 0;
  const t = Ss();
  class e extends t.CancellationEventArgsBase {
  }
  return si.MeetingTranscriptionCanceledEventArgs = e, si;
}
var oi = {}, Fd;
function q0() {
  if (Fd)
    return oi;
  Fd = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.MeetingTranscriber = void 0;
  const t = b(), e = O(), n = D, r = P(), s = Au();
  let o = class {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(i) {
      this.privAudioConfig = i, this.privProperties = new r.PropertyCollection(), this.privRecognizer = void 0, this.privDisposedRecognizer = !1;
    }
    /**
     * Gets the spoken language of recognition.
     * @member MeetingTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * The collection of properties and their values defined for this MeetingTranscriber.
     * @member MeetingTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privRecognizer.internalData;
    }
    /**
     * @Deprecated
     * @Obsolete
     * Please use the Connection.fromRecognizer pattern to obtain a connection object
     */
    get connection() {
      return r.Connection.fromRecognizer(this.privRecognizer);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, i);
    }
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */
    joinMeetingAsync(i, c, u) {
      const p = i;
      n.Contracts.throwIfNullOrUndefined(s.MeetingImpl, "Meeting"), this.privRecognizer = new t.TranscriberRecognizer(i.config, this.privAudioConfig), n.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer"), this.privRecognizer.connectMeetingCallbacks(this), e.marshalPromiseToCallbacks(p.connectTranscriberRecognizer(this.privRecognizer), c, u);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(i, c) {
      this.privRecognizer.startContinuousRecognitionAsync(i, c);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(i, c) {
      this.privRecognizer.stopContinuousRecognitionAsync(i, c);
    }
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */
    leaveMeetingAsync(i, c) {
      this.privRecognizer.disconnectCallbacks(), e.marshalPromiseToCallbacks((async () => {
      })(), i, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */
    close(i, c) {
      n.Contracts.throwIfDisposed(this.privDisposedRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), i, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(i) {
      this.privDisposedRecognizer || (this.privRecognizer && (await this.privRecognizer.close(), this.privRecognizer = void 0), i && (this.privDisposedRecognizer = !0));
    }
  };
  return oi.MeetingTranscriber = o, oi;
}
var ai = {}, $d;
function F0() {
  if ($d)
    return ai;
  $d = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.ConversationTranscriptionResult = void 0;
  const t = P();
  let e = class extends t.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(r, s, o, a, i, c, u, d, l, h), this.privSpeakerId = p;
    }
    /**
     * speaker id
     * @member ConversationTranscriptionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return ai.ConversationTranscriptionResult = e, ai;
}
var Ud;
function Au() {
  return Ud || (Ud = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Of();
    Object.defineProperty(t, "Conversation", { enumerable: !0, get: function() {
      return e.Conversation;
    } }), Object.defineProperty(t, "ConversationImpl", { enumerable: !0, get: function() {
      return e.ConversationImpl;
    } });
    var n = da;
    Object.defineProperty(t, "ConversationCommon", { enumerable: !0, get: function() {
      return n.ConversationCommon;
    } });
    var r = b0();
    Object.defineProperty(t, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return r.ConversationExpirationEventArgs;
    } });
    var s = A0();
    Object.defineProperty(t, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return s.ConversationParticipantsChangedEventArgs;
    } });
    var o = M0();
    Object.defineProperty(t, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return o.ConversationTranslationCanceledEventArgs;
    } });
    var a = O0();
    Object.defineProperty(t, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return a.ConversationTranslationEventArgs;
    } });
    var i = k0();
    Object.defineProperty(t, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return i.ConversationTranslationResult;
    } });
    var c = L0();
    Object.defineProperty(t, "ConversationTranslator", { enumerable: !0, get: function() {
      return c.ConversationTranslator;
    } });
    var u = z0();
    Object.defineProperty(t, "ConversationTranscriber", { enumerable: !0, get: function() {
      return u.ConversationTranscriber;
    } });
    var p = j0();
    Object.defineProperty(t, "Participant", { enumerable: !0, get: function() {
      return p.Participant;
    } }), Object.defineProperty(t, "User", { enumerable: !0, get: function() {
      return p.User;
    } });
    var d = Nf;
    Object.defineProperty(t, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return d.ParticipantChangedReason;
    } });
    var l = x0();
    Object.defineProperty(t, "Meeting", { enumerable: !0, get: function() {
      return l.Meeting;
    } }), Object.defineProperty(t, "MeetingImpl", { enumerable: !0, get: function() {
      return l.MeetingImpl;
    } });
    var h = B0();
    Object.defineProperty(t, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return h.MeetingTranscriptionCanceledEventArgs;
    } });
    var v = q0();
    Object.defineProperty(t, "MeetingTranscriber", { enumerable: !0, get: function() {
      return v.MeetingTranscriber;
    } });
    var g = F0();
    Object.defineProperty(t, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return g.ConversationTranscriptionResult;
    } });
  }(hc)), hc;
}
var nn = {}, Hd;
function Mu() {
  if (Hd)
    return nn;
  Hd = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.SynthesisRequest = nn.Synthesizer = void 0;
  const t = b(), e = O(), n = D, r = P();
  let s = class Lf {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
     */
    constructor(i) {
      const c = i;
      n.Contracts.throwIfNull(c, "speechConfig"), this.privProperties = c.properties.clone(), this.privDisposed = !1, this.privSynthesizing = !1, this.synthesisRequestQueue = new e.Queue();
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, i);
    }
    /**
     * The collection of properties and their values defined for this Synthesizer.
     * @member Synthesizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Indicates if auto detect source language is enabled
     * @member Synthesizer.prototype.autoDetectSourceLanguage
     * @function
     * @public
     * @returns {boolean} if auto detect source language is enabled
     */
    get autoDetectSourceLanguage() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === t.AutoDetectSourceLanguagesOpenRangeOptionName;
    }
    buildSsml(i) {
      const c = {
        "af-ZA": "af-ZA-AdriNeural",
        "am-ET": "am-ET-AmehaNeural",
        "ar-AE": "ar-AE-FatimaNeural",
        "ar-BH": "ar-BH-AliNeural",
        "ar-DZ": "ar-DZ-AminaNeural",
        "ar-EG": "ar-EG-SalmaNeural",
        "ar-IQ": "ar-IQ-BasselNeural",
        "ar-JO": "ar-JO-SanaNeural",
        "ar-KW": "ar-KW-FahedNeural",
        "ar-LY": "ar-LY-ImanNeural",
        "ar-MA": "ar-MA-JamalNeural",
        "ar-QA": "ar-QA-AmalNeural",
        "ar-SA": "ar-SA-HamedNeural",
        "ar-SY": "ar-SY-AmanyNeural",
        "ar-TN": "ar-TN-HediNeural",
        "ar-YE": "ar-YE-MaryamNeural",
        "bg-BG": "bg-BG-BorislavNeural",
        "bn-BD": "bn-BD-NabanitaNeural",
        "bn-IN": "bn-IN-BashkarNeural",
        "ca-ES": "ca-ES-JoanaNeural",
        "cs-CZ": "cs-CZ-AntoninNeural",
        "cy-GB": "cy-GB-AledNeural",
        "da-DK": "da-DK-ChristelNeural",
        "de-AT": "de-AT-IngridNeural",
        "de-CH": "de-CH-JanNeural",
        "de-DE": "de-DE-KatjaNeural",
        "el-GR": "el-GR-AthinaNeural",
        "en-AU": "en-AU-NatashaNeural",
        "en-CA": "en-CA-ClaraNeural",
        "en-GB": "en-GB-LibbyNeural",
        "en-HK": "en-HK-SamNeural",
        "en-IE": "en-IE-ConnorNeural",
        "en-IN": "en-IN-NeerjaNeural",
        "en-KE": "en-KE-AsiliaNeural",
        "en-NG": "en-NG-AbeoNeural",
        "en-NZ": "en-NZ-MitchellNeural",
        "en-PH": "en-PH-JamesNeural",
        "en-SG": "en-SG-LunaNeural",
        "en-TZ": "en-TZ-ElimuNeural",
        "en-US": "en-US-AvaMultilingualNeural",
        "en-ZA": "en-ZA-LeahNeural",
        "es-AR": "es-AR-ElenaNeural",
        "es-BO": "es-BO-MarceloNeural",
        "es-CL": "es-CL-CatalinaNeural",
        "es-CO": "es-CO-GonzaloNeural",
        "es-CR": "es-CR-JuanNeural",
        "es-CU": "es-CU-BelkysNeural",
        "es-DO": "es-DO-EmilioNeural",
        "es-EC": "es-EC-AndreaNeural",
        "es-ES": "es-ES-AlvaroNeural",
        "es-GQ": "es-GQ-JavierNeural",
        "es-GT": "es-GT-AndresNeural",
        "es-HN": "es-HN-CarlosNeural",
        "es-MX": "es-MX-DaliaNeural",
        "es-NI": "es-NI-FedericoNeural",
        "es-PA": "es-PA-MargaritaNeural",
        "es-PE": "es-PE-AlexNeural",
        "es-PR": "es-PR-KarinaNeural",
        "es-PY": "es-PY-MarioNeural",
        "es-SV": "es-SV-LorenaNeural",
        "es-US": "es-US-AlonsoNeural",
        "es-UY": "es-UY-MateoNeural",
        "es-VE": "es-VE-PaolaNeural",
        "et-EE": "et-EE-AnuNeural",
        "fa-IR": "fa-IR-DilaraNeural",
        "fi-FI": "fi-FI-SelmaNeural",
        "fil-PH": "fil-PH-AngeloNeural",
        "fr-BE": "fr-BE-CharlineNeural",
        "fr-CA": "fr-CA-SylvieNeural",
        "fr-CH": "fr-CH-ArianeNeural",
        "fr-FR": "fr-FR-DeniseNeural",
        "ga-IE": "ga-IE-ColmNeural",
        "gl-ES": "gl-ES-RoiNeural",
        "gu-IN": "gu-IN-DhwaniNeural",
        "he-IL": "he-IL-AvriNeural",
        "hi-IN": "hi-IN-MadhurNeural",
        "hr-HR": "hr-HR-GabrijelaNeural",
        "hu-HU": "hu-HU-NoemiNeural",
        "id-ID": "id-ID-ArdiNeural",
        "is-IS": "is-IS-GudrunNeural",
        "it-IT": "it-IT-IsabellaNeural",
        "ja-JP": "ja-JP-NanamiNeural",
        "jv-ID": "jv-ID-DimasNeural",
        "kk-KZ": "kk-KZ-AigulNeural",
        "km-KH": "km-KH-PisethNeural",
        "kn-IN": "kn-IN-GaganNeural",
        "ko-KR": "ko-KR-SunHiNeural",
        "lo-LA": "lo-LA-ChanthavongNeural",
        "lt-LT": "lt-LT-LeonasNeural",
        "lv-LV": "lv-LV-EveritaNeural",
        "mk-MK": "mk-MK-AleksandarNeural",
        "ml-IN": "ml-IN-MidhunNeural",
        "mr-IN": "mr-IN-AarohiNeural",
        "ms-MY": "ms-MY-OsmanNeural",
        "mt-MT": "mt-MT-GraceNeural",
        "my-MM": "my-MM-NilarNeural",
        "nb-NO": "nb-NO-PernilleNeural",
        "nl-BE": "nl-BE-ArnaudNeural",
        "nl-NL": "nl-NL-ColetteNeural",
        "pl-PL": "pl-PL-AgnieszkaNeural",
        "ps-AF": "ps-AF-GulNawazNeural",
        "pt-BR": "pt-BR-FranciscaNeural",
        "pt-PT": "pt-PT-DuarteNeural",
        "ro-RO": "ro-RO-AlinaNeural",
        "ru-RU": "ru-RU-SvetlanaNeural",
        "si-LK": "si-LK-SameeraNeural",
        "sk-SK": "sk-SK-LukasNeural",
        "sl-SI": "sl-SI-PetraNeural",
        "so-SO": "so-SO-MuuseNeural",
        "sr-RS": "sr-RS-NicholasNeural",
        "su-ID": "su-ID-JajangNeural",
        "sv-SE": "sv-SE-SofieNeural",
        "sw-KE": "sw-KE-RafikiNeural",
        "sw-TZ": "sw-TZ-DaudiNeural",
        "ta-IN": "ta-IN-PallaviNeural",
        "ta-LK": "ta-LK-KumarNeural",
        "ta-SG": "ta-SG-AnbuNeural",
        "te-IN": "te-IN-MohanNeural",
        "th-TH": "th-TH-PremwadeeNeural",
        "tr-TR": "tr-TR-AhmetNeural",
        "uk-UA": "uk-UA-OstapNeural",
        "ur-IN": "ur-IN-GulNeural",
        "ur-PK": "ur-PK-AsadNeural",
        "uz-UZ": "uz-UZ-MadinaNeural",
        "vi-VN": "vi-VN-HoaiMyNeural",
        "zh-CN": "zh-CN-XiaoxiaoNeural",
        "zh-HK": "zh-HK-HiuMaanNeural",
        "zh-TW": "zh-TW-HsiaoChenNeural",
        "zu-ZA": "zu-ZA-ThandoNeural"
      };
      let u = this.properties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US"), p = this.properties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, ""), d = Lf.XMLEncode(i);
      return this.autoDetectSourceLanguage ? u = "en-US" : p = p || c[u], p && (d = `<voice name='${p}'>${d}</voice>`), d = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${u}'>${d}</speak>`, d;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Synthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(i) {
      this.privDisposed || (i && this.privAdapter && await this.privAdapter.dispose(), this.privDisposed = !0);
    }
    async adapterSpeak() {
      if (!this.privDisposed && !this.privSynthesizing) {
        this.privSynthesizing = !0;
        const i = await this.synthesisRequestQueue.dequeue();
        return this.privAdapter.Speak(i.text, i.isSSML, i.requestId, i.cb, i.err, i.dataStream);
      }
    }
    createSynthesizerConfig(i) {
      return new t.SynthesizerConfig(i, this.privProperties);
    }
    // Does the generic synthesizer setup that is common across all synthesizer types.
    implCommonSynthesizeSetup() {
      let i = typeof window < "u" ? "Browser" : "Node", c = "unknown", u = "unknown";
      typeof navigator < "u" && (i = i + "/" + navigator.platform, c = navigator.userAgent, u = navigator.appVersion);
      const p = this.createSynthesizerConfig(new t.SpeechServiceConfig(new t.Context(new t.OS(i, c, u)))), d = this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Key, void 0), l = d && d !== "" ? new t.CognitiveSubscriptionKeyAuthentication(d) : new t.CognitiveTokenAuthentication(() => {
        const h = this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      }, () => {
        const h = this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      });
      this.privAdapter = this.createSynthesisAdapter(l, this.privConnectionFactory, p), this.privRestAdapter = this.createRestSynthesisAdapter(l, p);
    }
    static XMLEncode(i) {
      return i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
  };
  nn.Synthesizer = s;
  class o {
    constructor(i, c, u, p, d, l) {
      this.requestId = i, this.text = c, this.isSSML = u, this.cb = p, this.err = d, this.dataStream = l;
    }
  }
  return nn.SynthesisRequest = o, nn;
}
var ci = {}, Wd;
function $0() {
  if (Wd)
    return ci;
  Wd = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.SpeechSynthesizer = void 0;
  const t = b(), e = O(), n = ms, r = Vt, s = Re, o = D, a = P(), i = Mu();
  let c = class zf extends a.Synthesizer {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */
    constructor(p, d) {
      super(p), d !== null && (d === void 0 ? this.audioConfig = typeof window > "u" ? void 0 : a.AudioConfig.fromDefaultSpeakerOutput() : this.audioConfig = d), this.privConnectionFactory = new t.SpeechSynthesisConnectionFactory(), this.implCommonSynthesizeSetup();
    }
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */
    static FromConfig(p, d, l) {
      const h = p;
      return d.properties.mergeTo(h.properties), new zf(p, l);
    }
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakTextAsync(p, d, l, h) {
      this.speakImpl(p, !1, d, l, h);
    }
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakSsmlAsync(p, d, l, h) {
      this.speakImpl(p, !0, d, l, h);
    }
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */
    async getVoicesAsync(p = "") {
      return this.getVoices(p);
    }
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */
    close(p, d) {
      o.Contracts.throwIfDisposed(this.privDisposed), e.marshalPromiseToCallbacks(this.dispose(!0), p, d);
    }
    /**
     * @Internal
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privAdapter;
    }
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // ################################################################################################################
    //
    // Creates the synthesis adapter
    createSynthesisAdapter(p, d, l) {
      return new t.SpeechSynthesisAdapter(p, d, l, this, this.audioConfig);
    }
    createRestSynthesisAdapter(p, d) {
      return new t.SynthesisRestAdapter(d, p);
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = r.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(a.SpeechSynthesisOutputFormat[this.properties.getProperty(a.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)]);
    }
    speakImpl(p, d, l, h, v) {
      try {
        o.Contracts.throwIfDisposed(this.privDisposed);
        const g = e.createNoDashGuid();
        let f;
        v instanceof a.PushAudioOutputStreamCallback ? f = new s.PushAudioOutputStreamImpl(v) : v instanceof a.PullAudioOutputStream ? f = v : v !== void 0 ? f = new n.AudioFileWriter(v) : f = void 0, this.synthesisRequestQueue.enqueue(new i.SynthesisRequest(g, p, d, (m) => {
          if (this.privSynthesizing = !1, l)
            try {
              l(m);
            } catch (S) {
              h && h(S);
            }
          l = void 0, this.adapterSpeak().catch(() => {
          });
        }, (m) => {
          h && h(m);
        }, f)), this.adapterSpeak().catch(() => {
        });
      } catch (g) {
        if (h)
          if (g instanceof Error) {
            const f = g;
            h(f.name + ": " + f.message);
          } else
            h(g);
        this.dispose(!0).catch(() => {
        });
      }
    }
    async getVoices(p) {
      const d = e.createNoDashGuid(), l = await this.privRestAdapter.getVoicesList(d);
      if (l.ok && Array.isArray(l.json)) {
        let h = l.json;
        return p && p.length > 0 && (h = h.filter((v) => !!v.Locale && v.Locale.toLowerCase() === p.toLowerCase())), new a.SynthesisVoicesResult(d, h, void 0);
      } else
        return new a.SynthesisVoicesResult(d, void 0, `Error: ${l.status}: ${l.statusText}`);
    }
  };
  return ci.SpeechSynthesizer = c, ci;
}
var la = {};
Object.defineProperty(la, "__esModule", { value: !0 });
la.SynthesisResult = void 0;
class U0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(e, n, r, s) {
    this.privResultId = e, this.privReason = n, this.privErrorDetails = r, this.privProperties = s;
  }
  /**
   * Specifies the result identifier.
   * @member SynthesisResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member SynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful synthesis, provides details of the occurred error.
   * @member SynthesisResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The set of properties exposed in the result.
   * @member SynthesisResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
la.SynthesisResult = U0;
var ui = {}, Vd;
function H0() {
  if (Vd)
    return ui;
  Vd = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.SpeechSynthesisResult = void 0;
  const t = P();
  let e = class extends t.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */
    constructor(r, s, o, a, i, c) {
      super(r, s, a, i), this.privAudioData = o, this.privAudioDuration = c;
    }
    /**
     * The synthesized audio data
     * @member SpeechSynthesisResult.prototype.audioData
     * @function
     * @public
     * @returns {ArrayBuffer} The synthesized audio data.
     */
    get audioData() {
      return this.privAudioData;
    }
    /**
     * The time duration of synthesized audio, in ticks (100 nanoseconds).
     * @member SpeechSynthesisResult.prototype.audioDuration
     * @function
     * @public
     * @returns {number} The time duration of synthesized audio.
     */
    get audioDuration() {
      return this.privAudioDuration;
    }
  };
  return ui.SpeechSynthesisResult = e, ui;
}
var ha = {};
Object.defineProperty(ha, "__esModule", { value: !0 });
ha.SpeechSynthesisEventArgs = void 0;
class W0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {SpeechSynthesisResult} result - The speech synthesis result.
   */
  constructor(e) {
    this.privResult = e;
  }
  /**
   * Specifies the synthesis result.
   * @member SpeechSynthesisEventArgs.prototype.result
   * @function
   * @public
   * @returns {SpeechSynthesisResult} the synthesis result.
   */
  get result() {
    return this.privResult;
  }
}
ha.SpeechSynthesisEventArgs = W0;
var va = {};
Object.defineProperty(va, "__esModule", { value: !0 });
va.SpeechSynthesisWordBoundaryEventArgs = void 0;
class V0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} duration - The audio duration.
   * @param {string} text - The text.
   * @param {number} wordLength - The length of the word.
   * @param {number} textOffset - The text offset.
   * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
   */
  constructor(e, n, r, s, o, a) {
    this.privAudioOffset = e, this.privDuration = n, this.privText = r, this.privWordLength = s, this.privTextOffset = o, this.privBoundaryType = a;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the duration, in ticks (100 nanoseconds).
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
   * @function
   * @public
   * @returns {number} Duration in 100 nanosecond increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Specifies the text of the word boundary event.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the text.
   */
  get text() {
    return this.privText;
  }
  /**
   * Specifies the word length
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
   * @function
   * @public
   * @returns {number} the word length
   */
  get wordLength() {
    return this.privWordLength;
  }
  /**
   * Specifies the text offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
   * @function
   * @public
   * @returns {number} the text offset.
   */
  get textOffset() {
    return this.privTextOffset;
  }
  /**
   * Specifies the boundary type.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
   * @function
   * @public
   * @returns {SpeechSynthesisBoundaryType} the boundary type.
   */
  get boundaryType() {
    return this.privBoundaryType;
  }
}
va.SpeechSynthesisWordBoundaryEventArgs = V0;
var fa = {};
Object.defineProperty(fa, "__esModule", { value: !0 });
fa.SpeechSynthesisBookmarkEventArgs = void 0;
class K0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {string} text - The bookmark text.
   */
  constructor(e, n) {
    this.privAudioOffset = e, this.privText = n;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the bookmark.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the bookmark text.
   */
  get text() {
    return this.privText;
  }
}
fa.SpeechSynthesisBookmarkEventArgs = K0;
var ga = {};
Object.defineProperty(ga, "__esModule", { value: !0 });
ga.SpeechSynthesisVisemeEventArgs = void 0;
class J0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} visemeId - The viseme ID.
   * @param {string} animation - The animation, could be in svg or other format.
   */
  constructor(e, n, r) {
    this.privAudioOffset = e, this.privVisemeId = n, this.privAnimation = r;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the viseme ID.
   * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
   * @function
   * @public
   * @returns {number} the viseme ID.
   */
  get visemeId() {
    return this.privVisemeId;
  }
  /**
   * Specifies the animation.
   * @member SpeechSynthesisVisemeEventArgs.prototype.animation
   * @function
   * @public
   * @returns {string} the animation, could be in svg or other format.
   */
  get animation() {
    return this.privAnimation;
  }
}
ga.SpeechSynthesisVisemeEventArgs = J0;
var jf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.SpeechSynthesisBoundaryType = void 0, function(e) {
    e.Word = "WordBoundary", e.Punctuation = "PunctuationBoundary", e.Sentence = "SentenceBoundary";
  }(t.SpeechSynthesisBoundaryType || (t.SpeechSynthesisBoundaryType = {}));
})(jf);
var pi = {}, Kd;
function G0() {
  if (Kd)
    return pi;
  Kd = 1, Object.defineProperty(pi, "__esModule", { value: !0 }), pi.SynthesisVoicesResult = void 0;
  const t = P();
  let e = class extends t.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */
    constructor(r, s, o) {
      if (Array.isArray(s)) {
        super(r, t.ResultReason.VoicesListRetrieved, void 0, new t.PropertyCollection()), this.privVoices = [];
        for (const a of s)
          this.privVoices.push(new t.VoiceInfo(a));
      } else
        super(r, t.ResultReason.Canceled, o || "Error information unavailable", new t.PropertyCollection());
    }
    /**
     * The list of voices
     * @member SynthesisVoicesResult.prototype.voices
     * @function
     * @public
     * @returns {VoiceInfo[]} List of synthesized voices.
     */
    get voices() {
      return this.privVoices;
    }
  };
  return pi.SynthesisVoicesResult = e, pi;
}
var xf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.VoiceInfo = t.SynthesisVoiceType = t.SynthesisVoiceGender = void 0;
  var e;
  (function(o) {
    o[o.Unknown = 0] = "Unknown", o[o.Female = 1] = "Female", o[o.Male = 2] = "Male", o[o.Neutral = 3] = "Neutral";
  })(e = t.SynthesisVoiceGender || (t.SynthesisVoiceGender = {}));
  var n;
  (function(o) {
    o[o.OnlineNeural = 1] = "OnlineNeural", o[o.OnlineStandard = 2] = "OnlineStandard", o[o.OfflineNeural = 3] = "OfflineNeural", o[o.OfflineStandard = 4] = "OfflineStandard";
  })(n = t.SynthesisVoiceType || (t.SynthesisVoiceType = {}));
  const r = {
    [e[e.Neutral]]: e.Neutral,
    [e[e.Male]]: e.Male,
    [e[e.Female]]: e.Female
  };
  class s {
    constructor(a) {
      if (this.privStyleList = [], a) {
        if (this.privName = a.Name, this.privLocale = a.Locale, this.privShortName = a.ShortName, this.privLocaleName = a.LocaleName, this.privDisplayName = a.DisplayName, this.privLocalName = a.LocalName, this.privVoiceType = a.VoiceType.endsWith("Standard") ? n.OnlineStandard : n.OnlineNeural, this.privGender = r[a.Gender] || e.Unknown, a.StyleList && Array.isArray(a.StyleList))
          for (const i of a.StyleList)
            this.privStyleList.push(i);
        this.privSampleRateHertz = a.SampleRateHertz, this.privStatus = a.Status, a.ExtendedPropertyMap && (this.privExtendedPropertyMap = a.ExtendedPropertyMap), this.privWordsPerMinute = a.WordsPerMinute, Array.isArray(a.SecondaryLocaleList) && (this.privSecondaryLocaleList = [...a.SecondaryLocaleList]), Array.isArray(a.RolePlayList) && (this.privRolePlayList = [...a.RolePlayList]);
      }
    }
    get name() {
      return this.privName;
    }
    get locale() {
      return this.privLocale;
    }
    get shortName() {
      return this.privShortName;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get localName() {
      return this.privLocalName;
    }
    get localeName() {
      return this.privLocaleName;
    }
    get gender() {
      return this.privGender;
    }
    get voiceType() {
      return this.privVoiceType;
    }
    get styleList() {
      return this.privStyleList;
    }
    get sampleRateHertz() {
      return this.privSampleRateHertz;
    }
    get status() {
      return this.privStatus;
    }
    get extendedPropertyMap() {
      return this.privExtendedPropertyMap;
    }
    get wordsPerMinute() {
      return this.privWordsPerMinute;
    }
    get secondaryLocaleList() {
      return this.privSecondaryLocaleList;
    }
    get rolePlayList() {
      return this.privRolePlayList;
    }
  }
  t.VoiceInfo = s;
})(xf);
var ma = {};
Object.defineProperty(ma, "__esModule", { value: !0 });
ma.SpeakerAudioDestination = void 0;
const rn = O(), Q0 = Re, Fe = Wt, Y0 = 60 * 30, Jd = {
  [Fe.AudioFormatTag.PCM]: "audio/wav",
  [Fe.AudioFormatTag.MuLaw]: "audio/x-wav",
  [Fe.AudioFormatTag.MP3]: "audio/mpeg",
  [Fe.AudioFormatTag.OGG_OPUS]: "audio/ogg",
  [Fe.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
  [Fe.AudioFormatTag.ALaw]: "audio/x-wav",
  [Fe.AudioFormatTag.FLAC]: "audio/flac",
  [Fe.AudioFormatTag.AMR_WB]: "audio/amr-wb",
  [Fe.AudioFormatTag.G722]: "audio/G722"
};
class Z0 {
  constructor(e) {
    this.privPlaybackStarted = !1, this.privAppendingToBuffer = !1, this.privMediaSourceOpened = !1, this.privBytesReceived = 0, this.privId = e || rn.createNoDashGuid(), this.privIsPaused = !1, this.privIsClosed = !1;
  }
  id() {
    return this.privId;
  }
  write(e, n, r) {
    this.privAudioBuffer !== void 0 ? (this.privAudioBuffer.push(e), this.updateSourceBuffer().then(() => {
      n && n();
    }, (s) => {
      r && r(s);
    })) : this.privAudioOutputStream !== void 0 && (this.privAudioOutputStream.write(e), this.privBytesReceived += e.byteLength);
  }
  close(e, n) {
    if (this.privIsClosed = !0, this.privSourceBuffer !== void 0)
      this.handleSourceBufferUpdateEnd().then(() => {
        e && e();
      }, (r) => {
        n && n(r);
      });
    else if (this.privAudioOutputStream !== void 0 && typeof window < "u")
      if ((this.privFormat.formatTag === Fe.AudioFormatTag.PCM || this.privFormat.formatTag === Fe.AudioFormatTag.MuLaw || this.privFormat.formatTag === Fe.AudioFormatTag.ALaw) && this.privFormat.hasHeader === !1)
        console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header."), this.onAudioEnd && this.onAudioEnd(this);
      else {
        let r = new ArrayBuffer(this.privBytesReceived);
        this.privAudioOutputStream.read(r).then(() => {
          r = this.privFormat.addHeader(r);
          const s = new Blob([r], { type: Jd[this.privFormat.formatTag] });
          this.privAudio.src = window.URL.createObjectURL(s), this.notifyPlayback().then(() => {
            e && e();
          }, (o) => {
            n && n(o);
          });
        }, (s) => {
          n && n(s);
        });
      }
    else
      this.onAudioEnd && this.onAudioEnd(this);
  }
  set format(e) {
    if (typeof AudioContext < "u" || typeof window < "u" && typeof window.webkitAudioContext < "u") {
      this.privFormat = e;
      const n = Jd[this.privFormat.formatTag];
      n === void 0 ? console.warn(`Unknown mimeType for format ${Fe.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`) : typeof MediaSource < "u" && MediaSource.isTypeSupported(n) ? (this.privAudio = new Audio(), this.privAudioBuffer = [], this.privMediaSource = new MediaSource(), this.privAudio.src = URL.createObjectURL(this.privMediaSource), this.privAudio.load(), this.privMediaSource.onsourceopen = () => {
        this.privMediaSourceOpened = !0, this.privMediaSource.duration = Y0, this.privSourceBuffer = this.privMediaSource.addSourceBuffer(n), this.privSourceBuffer.onupdate = () => {
          this.updateSourceBuffer().catch((r) => {
            rn.Events.instance.onEvent(new rn.BackgroundEvent(r));
          });
        }, this.privSourceBuffer.onupdateend = () => {
          this.handleSourceBufferUpdateEnd().catch((r) => {
            rn.Events.instance.onEvent(new rn.BackgroundEvent(r));
          });
        }, this.privSourceBuffer.onupdatestart = () => {
          this.privAppendingToBuffer = !1;
        };
      }, this.updateSourceBuffer().catch((r) => {
        rn.Events.instance.onEvent(new rn.BackgroundEvent(r));
      })) : (console.warn(`Format ${Fe.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`), this.privAudioOutputStream = new Q0.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privFormat, this.privAudio = new Audio());
    }
  }
  get volume() {
    var e;
    return ((e = this.privAudio) == null ? void 0 : e.volume) ?? -1;
  }
  set volume(e) {
    this.privAudio && (this.privAudio.volume = e);
  }
  mute() {
    this.privAudio && (this.privAudio.muted = !0);
  }
  unmute() {
    this.privAudio && (this.privAudio.muted = !1);
  }
  get isClosed() {
    return this.privIsClosed;
  }
  get currentTime() {
    return this.privAudio !== void 0 ? this.privAudio.currentTime : -1;
  }
  pause() {
    !this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.pause(), this.privIsPaused = !0);
  }
  resume(e, n) {
    this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.play().then(() => {
      e && e();
    }, (r) => {
      n && n(r);
    }), this.privIsPaused = !1);
  }
  get internalAudio() {
    return this.privAudio;
  }
  async updateSourceBuffer() {
    if (this.privAudioBuffer !== void 0 && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
      this.privAppendingToBuffer = !0;
      const e = this.privAudioBuffer.shift();
      try {
        this.privSourceBuffer.appendBuffer(e);
      } catch {
        this.privAudioBuffer.unshift(e), console.log("buffer filled, pausing addition of binaries until space is made");
        return;
      }
      await this.notifyPlayback();
    } else
      this.canEndStream() && await this.handleSourceBufferUpdateEnd();
  }
  async handleSourceBufferUpdateEnd() {
    this.canEndStream() && this.sourceBufferAvailable() && (this.privMediaSource.endOfStream(), await this.notifyPlayback());
  }
  async notifyPlayback() {
    !this.privPlaybackStarted && this.privAudio !== void 0 && (this.privPlaybackStarted = !0, this.onAudioStart && this.onAudioStart(this), this.privAudio.onended = () => {
      this.onAudioEnd && this.onAudioEnd(this);
    }, this.privIsPaused || await this.privAudio.play());
  }
  canEndStream() {
    return this.isClosed && this.privSourceBuffer !== void 0 && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
  }
  sourceBufferAvailable() {
    return this.privSourceBuffer !== void 0 && !this.privSourceBuffer.updating;
  }
}
ma.SpeakerAudioDestination = Z0;
var di = {}, Gd;
function X0() {
  if (Gd)
    return di;
  Gd = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.ConversationTranscriptionCanceledEventArgs = void 0;
  const t = Ss();
  let e = class extends t.CancellationEventArgsBase {
  };
  return di.ConversationTranscriptionCanceledEventArgs = e, di;
}
var li = {}, Qd;
function eR() {
  if (Qd)
    return li;
  Qd = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.MeetingTranscriptionCanceledEventArgs = void 0;
  const t = Ss();
  let e = class extends t.CancellationEventArgsBase {
  };
  return li.MeetingTranscriptionCanceledEventArgs = e, li;
}
var Bf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PronunciationAssessmentGradingSystem = void 0, function(e) {
    e[e.FivePoint = 1] = "FivePoint", e[e.HundredMark = 2] = "HundredMark";
  }(t.PronunciationAssessmentGradingSystem || (t.PronunciationAssessmentGradingSystem = {}));
})(Bf);
var qf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PronunciationAssessmentGranularity = void 0, function(e) {
    e[e.Phoneme = 1] = "Phoneme", e[e.Word = 2] = "Word", e[e.FullText = 3] = "FullText";
  }(t.PronunciationAssessmentGranularity || (t.PronunciationAssessmentGranularity = {}));
})(qf);
var hi = {}, Yd;
function tR() {
  if (Yd)
    return hi;
  Yd = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.PronunciationAssessmentConfig = void 0;
  const t = D, e = P();
  let n = class Ff {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */
    constructor(s, o = e.PronunciationAssessmentGradingSystem.FivePoint, a = e.PronunciationAssessmentGranularity.Phoneme, i = !1) {
      t.Contracts.throwIfNullOrUndefined(s, "referenceText"), this.privProperties = new e.PropertyCollection(), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_ReferenceText, s), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_GradingSystem, e.PronunciationAssessmentGradingSystem[o]), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_Granularity, e.PronunciationAssessmentGranularity[a]), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_EnableMiscue, String(i));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */
    static fromJSON(s) {
      t.Contracts.throwIfNullOrUndefined(s, "json");
      const o = new Ff("");
      return o.privProperties = new e.PropertyCollection(), o.properties.setProperty(e.PropertyId.PronunciationAssessment_Json, s), o;
    }
    toJSON() {
      return this.updateJson(), this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_Params);
    }
    applyTo(s) {
      this.updateJson();
      const o = s.internalData;
      o.expectContentAssessmentResponse = !!this.privContentAssessmentTopic, o.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(e.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, o.isSpeakerDiarizationEnabled);
    }
    /**
     * Gets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @returns {string} Reference text.
     */
    get referenceText() {
      return this.properties.getProperty(e.PropertyId.PronunciationAssessment_ReferenceText);
    }
    /**
     * Gets/Sets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @param {string} referenceText - Reference text.
     */
    set referenceText(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "referenceText"), this.properties.setProperty(e.PropertyId.PronunciationAssessment_ReferenceText, s);
    }
    /**
     * Sets the phoneme alphabet.
     * The valid values are "SAPI" (default) and "IPA".
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
     * @function
     * @public
     * @param {string} phonemeAlphabet - Phoneme alphabet.
     */
    set phonemeAlphabet(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "phonemeAlphabet"), this.privPhonemeAlphabet = s;
    }
    /**
     * Sets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @param {boolean} enableMiscue - enable miscue.
     */
    set enableMiscue(s) {
      const o = s ? "true" : "false";
      this.properties.setProperty(e.PropertyId.PronunciationAssessment_EnableMiscue, o);
    }
    /**
     * Gets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @return {boolean} enableMiscue - enable miscue.
     */
    get enableMiscue() {
      return this.properties.getProperty(e.PropertyId.PronunciationAssessment_EnableMiscue, "false").toLowerCase() === "true";
    }
    /**
     * Sets the nbest phoneme count
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
     * @function
     * @public
     * @param {number} nbestPhonemeCount - NBest phoneme count.
     */
    set nbestPhonemeCount(s) {
      this.privNBestPhonemeCount = s;
    }
    /**
     * Enables the prosody assessment.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
     * @function
     * @public
     * @param {boolean} enableProsodyAssessment - enable prosody assessment.
     */
    set enableProsodyAssessment(s) {
      this.privEnableProsodyAssessment = s;
    }
    /**
     * Enables content assessment and sets the topic.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
     * @function
     * @public
     * @param {string} topic - Topic for content assessment.
     */
    enableContentAssessmentWithTopic(s) {
      this.privContentAssessmentTopic = s;
    }
    /**
     * @member PronunciationAssessmentConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets a pronunciation assessment config properties
     */
    get properties() {
      return this.privProperties;
    }
    updateJson() {
      const s = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_Json, "{}"), o = JSON.parse(s), a = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_ReferenceText);
      a && (o.referenceText = a);
      const i = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_GradingSystem);
      i && (o.gradingSystem = i);
      const c = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_Granularity);
      c && (o.granularity = c), this.privPhonemeAlphabet && (o.phonemeAlphabet = this.privPhonemeAlphabet), this.privNBestPhonemeCount && (o.nbestPhonemeCount = this.privNBestPhonemeCount), o.enableProsodyAssessment = this.privEnableProsodyAssessment, o.dimension = "Comprehensive", this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_EnableMiscue) && (o.enableMiscue = this.enableMiscue), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_Params, JSON.stringify(o));
    }
  };
  return hi.PronunciationAssessmentConfig = n, hi;
}
var sn = {}, Zd;
function nR() {
  if (Zd)
    return sn;
  Zd = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.PronunciationAssessmentResult = sn.ContentAssessmentResult = void 0;
  const t = D, e = P();
  class n {
    /**
     * @Internal
     * Do not use externally.
     */
    constructor(o) {
      this.privPronJson = o;
    }
    /**
     * Correctness in using grammar and variety of sentence patterns.
     * Grammatical errors are jointly evaluated by lexical accuracy,
     * grammatical accuracy and diversity of sentence structures.
     * @member ContentAssessmentResult.prototype.grammarScore
     * @function
     * @public
     * @returns {number} Grammar score.
     */
    get grammarScore() {
      return this.privPronJson.ContentAssessment.GrammarScore;
    }
    /**
     * Proficiency in lexical usage. It evaluates the speaker's effective usage
     * of words and their appropriateness within the given context to express
     * ideas accurately, as well as level of lexical complexity.
     * @member ContentAssessmentResult.prototype.vocabularyScore
     * @function
     * @public
     * @returns {number} Vocabulary score.
     */
    get vocabularyScore() {
      return this.privPronJson.ContentAssessment.VocabularyScore;
    }
    /**
     * Level of understanding and engagement with the topic, which provides
     * insights into the speakers ability to express their thoughts and ideas
     * effectively and the ability to engage with the topic.
     * @member ContentAssessmentResult.prototype.topicScore
     * @function
     * @public
     * @returns {number} Topic score.
     */
    get topicScore() {
      return this.privPronJson.ContentAssessment.TopicScore;
    }
  }
  sn.ContentAssessmentResult = n;
  let r = class $f {
    constructor(o) {
      const a = JSON.parse(o);
      t.Contracts.throwIfNullOrUndefined(a.NBest[0], "NBest"), this.privPronJson = a.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */
    static fromResult(o) {
      t.Contracts.throwIfNullOrUndefined(o, "result");
      const a = o.properties.getProperty(e.PropertyId.SpeechServiceResponse_JsonResult);
      return t.Contracts.throwIfNullOrUndefined(a, "json"), new $f(a);
    }
    /**
     * Gets the detail result of pronunciation assessment.
     * @member PronunciationAssessmentConfig.prototype.detailResult
     * @function
     * @public
     * @returns {DetailResult} detail result.
     */
    get detailResult() {
      return this.privPronJson;
    }
    /**
     * The score indicating the pronunciation accuracy of the given speech, which indicates
     * how closely the phonemes match a native speaker's pronunciation.
     * @member PronunciationAssessmentResult.prototype.accuracyScore
     * @function
     * @public
     * @returns {number} Accuracy score.
     */
    get accuracyScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.AccuracyScore;
    }
    /**
     * The overall score indicating the pronunciation quality of the given speech.
     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
     * @member PronunciationAssessmentResult.prototype.pronunciationScore
     * @function
     * @public
     * @returns {number} Pronunciation score.
     */
    get pronunciationScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.PronScore;
    }
    /**
     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
     * @member PronunciationAssessmentResult.prototype.completenessScore
     * @function
     * @public
     * @returns {number} Completeness score.
     */
    get completenessScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.CompletenessScore;
    }
    /**
     * The score indicating the fluency of the given speech.
     * @member PronunciationAssessmentResult.prototype.fluencyScore
     * @function
     * @public
     * @returns {number} Fluency score.
     */
    get fluencyScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.FluencyScore;
    }
    /**
     * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
     * @member PronunciationAssessmentResult.prototype.prosodyScore
     * @function
     * @public
     * @returns {number} Prosody score.
     */
    get prosodyScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.ProsodyScore;
    }
    /**
     * The concent assessment result.
     * Only available when content assessment is enabled.
     * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
     * @function
     * @public
     * @returns {ContentAssessmentResult} Content assessment result.
     */
    get contentAssessmentResult() {
      if (this.detailResult.ContentAssessment !== void 0)
        return new n(this.detailResult);
    }
  };
  return sn.PronunciationAssessmentResult = r, sn;
}
var vi = {}, Xd;
function rR() {
  if (Xd)
    return vi;
  Xd = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.AvatarConfig = void 0;
  const t = D, e = P();
  let n = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} character - The avatar character.
     * @param {string} style - The avatar style.
     * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
     */
    constructor(s, o, a) {
      this.privCustomized = !1, t.Contracts.throwIfNullOrWhitespace(s, "character"), this.character = s, this.style = o, a === void 0 && (a = new e.AvatarVideoFormat()), this.videoFormat = a;
    }
    /**
     * Indicates if the talking avatar is customized.
     */
    get customized() {
      return this.privCustomized;
    }
    /**
     * Sets if the talking avatar is customized.
     */
    set customized(s) {
      this.privCustomized = s;
    }
    /**
     * Gets the background color.
     */
    get backgroundColor() {
      return this.privBackgroundColor;
    }
    /**
     * Sets the background color.
     */
    set backgroundColor(s) {
      this.privBackgroundColor = s;
    }
    /**
     * Gets the background image.
     */
    get backgroundImage() {
      return this.privBackgroundImage;
    }
    /**
     * Sets the background image.
     * @param {URL} value - The background image.
     */
    set backgroundImage(s) {
      this.privBackgroundImage = s;
    }
    /**
     * Gets the remote ICE servers.
     * @remarks This method is designed to be used internally in the SDK.
     * @returns {RTCIceServer[]} The remote ICE servers.
     */
    get remoteIceServers() {
      return this.privRemoteIceServers;
    }
    /**
     * Sets the remote ICE servers.
     * @remarks Normally, the ICE servers are gathered from the PeerConnection,
     * set this property to override the ICE servers. E.g., the ICE servers are
     * different in client and server side.
     * @param {RTCIceServer[]} value - The remote ICE servers.
     */
    set remoteIceServers(s) {
      this.privRemoteIceServers = s;
    }
  };
  return vi.AvatarConfig = n, vi;
}
var Uf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AvatarEventArgs = t.AvatarEventTypes = void 0, function(n) {
    n.SwitchedToSpeaking = "SwitchedToSpeaking", n.SwitchedToIdle = "SwitchedToIdle", n.SessionClosed = "SessionClosed";
  }(t.AvatarEventTypes || (t.AvatarEventTypes = {}));
  class e {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} description - The description of the event.
     */
    constructor(r, s) {
      this.privOffset = r, this.privDescription = s;
    }
    /**
     * The type of the event.
     * @public
     * @returns {AvatarEventTypes} The type of the event.
     */
    get type() {
      return this.privType;
    }
    /**
     * The time offset associated with this event.
     * @public
     * @returns {number} The time offset associated with this event.
     */
    get offset() {
      return this.privOffset;
    }
    /**
     * The description of the event.
     * @public
     * @returns {string} The description of the event.
     */
    get description() {
      return this.privDescription;
    }
  }
  t.AvatarEventArgs = e;
})(Uf);
var fi = {}, gi = {}, el;
function Hf() {
  if (el)
    return gi;
  el = 1, Object.defineProperty(gi, "__esModule", { value: !0 }), gi.SpeechSynthesisConnectionFactory = void 0;
  const t = Se(), e = P(), n = ot(), r = b(), s = me, o = st;
  let a = class {
    constructor() {
      this.synthesisUri = "/cognitiveservices/websocket/v1";
    }
    create(c, u, p) {
      let d = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const l = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, void 0), h = n.ConnectionFactoryBase.getHostSuffix(l), v = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_EndpointId, void 0), g = v === void 0 ? "tts" : "voice", f = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, "wss://" + l + "." + g + ".speech" + h), m = {}, S = {};
      u.token !== void 0 && u.token !== "" && (S[u.headerName] = u.token), S[s.HeaderNames.ConnectionId] = p, v !== void 0 && v !== "" && (!d || d.search(o.QueryParameterNames.CustomVoiceDeploymentId) === -1) && (m[o.QueryParameterNames.CustomVoiceDeploymentId] = v), c.avatarEnabled && (!d || d.search(o.QueryParameterNames.EnableAvatar) === -1) && (m[o.QueryParameterNames.EnableAvatar] = "true"), d || (d = f + this.synthesisUri), c.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, d);
      const y = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(d, m, S, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromParameters(c.parameters), y, p);
    }
  };
  return gi.SpeechSynthesisConnectionFactory = a, gi;
}
var tl;
function iR() {
  if (tl)
    return fi;
  tl = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.AvatarSynthesizer = void 0;
  const t = Hf(), e = b(), n = O(), r = Vt, s = P(), o = D, a = Mu();
  let i = class extends s.Synthesizer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config.
     * @param {AvatarConfig} avatarConfig - The talking avatar config.
     */
    constructor(u, p) {
      super(u), o.Contracts.throwIfNullOrUndefined(p, "avatarConfig"), this.privConnectionFactory = new t.SpeechSynthesisConnectionFactory(), this.privAvatarConfig = p, this.implCommonSynthesizeSetup();
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = r.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(s.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
    }
    /**
     * Starts the talking avatar session and establishes the WebRTC connection.
     * @member AvatarSynthesizer.prototype.startAvatarAsync
     * @function
     * @public
     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
     * @returns {Promise<SynthesisResult>} The promise of the connection result.
     */
    async startAvatarAsync(u) {
      o.Contracts.throwIfNullOrUndefined(u, "peerConnection"), this.privIceServers = u.getConfiguration().iceServers, o.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
      const p = new n.Deferred();
      u.onicegatheringstatechange = () => {
        n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice gathering state: " + u.iceGatheringState, n.EventType.Debug)), u.iceGatheringState === "complete" && (n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice gathering complete.", n.EventType.Info)), p.resolve());
      }, u.onicecandidate = (g) => {
        g.candidate ? n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice candidate: " + g.candidate.candidate, n.EventType.Debug)) : (n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice candidate: complete", n.EventType.Debug)), p.resolve());
      }, setTimeout(() => {
        u.iceGatheringState !== "complete" && (n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice gathering timeout.", n.EventType.Warning)), p.resolve());
      }, 2e3);
      const d = await u.createOffer();
      await u.setLocalDescription(d), await p.promise, n.Events.instance.onEvent(new n.PlatformEvent("peer connection: got local SDP.", n.EventType.Info)), this.privProperties.setProperty(s.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(u.localDescription));
      const l = await this.speak("", !1);
      if (l.reason !== s.ResultReason.SynthesizingAudioCompleted)
        return new s.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
      const h = atob(l.properties.getProperty(s.PropertyId.TalkingAvatarService_WebRTC_SDP)), v = new RTCSessionDescription(JSON.parse(h));
      return await u.setRemoteDescription(v), new s.SynthesisResult(l.resultId, l.reason, void 0, l.properties);
    }
    /**
     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param {string} text - The plain text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakTextAsync(u) {
      const p = await this.speak(u, !1);
      return new s.SynthesisResult(p.resultId, p.reason, p.errorDetails, p.properties);
    }
    /**
     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param {string} ssml - The SSML text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakSsmlAsync(u) {
      const p = await this.speak(u, !0);
      return new s.SynthesisResult(p.resultId, p.reason, p.errorDetails, p.properties);
    }
    /**
     * Speaks text asynchronously. The avatar will switch to idle state.
     * @member AvatarSynthesizer.prototype.stopSpeakingAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopSpeakingAsync() {
      for (; this.synthesisRequestQueue.length() > 0; )
        (await this.synthesisRequestQueue.dequeue()).err("Synthesis is canceled by user.");
      return this.privAdapter.stopSpeaking();
    }
    /**
     * Stops the talking avatar session and closes the WebRTC connection.
     * For now, this is the same as close().
     * You need to create a new AvatarSynthesizer instance to start a new session.
     * @member AvatarSynthesizer.prototype.stopAvatarAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopAvatarAsync() {
      return o.Contracts.throwIfDisposed(this.privDisposed), this.dispose(!0);
    }
    /**
     * Dispose of associated resources.
     * @member AvatarSynthesizer.prototype.close
     * @function
     * @public
     */
    async close() {
      if (!this.privDisposed)
        return this.dispose(!0);
    }
    /**
     * Gets the ICE servers. Internal use only.
     */
    get iceServers() {
      return this.privIceServers;
    }
    // Creates the synthesis adapter
    createSynthesisAdapter(u, p, d) {
      return new e.AvatarSynthesisAdapter(u, p, d, this, this.privAvatarConfig);
    }
    createRestSynthesisAdapter(u, p) {
    }
    createSynthesizerConfig(u) {
      const p = super.createSynthesizerConfig(u);
      return p.avatarEnabled = !0, p;
    }
    async speak(u, p) {
      const d = n.createNoDashGuid(), l = new n.Deferred();
      return this.synthesisRequestQueue.enqueue(new a.SynthesisRequest(d, u, p, (h) => {
        l.resolve(h), this.privSynthesizing = !1, this.adapterSpeak();
      }, (h) => {
        l.reject(h), this.privSynthesizing = !1;
      })), this.adapterSpeak(), l.promise;
    }
  };
  return fi.AvatarSynthesizer = i, fi;
}
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.AvatarVideoFormat = Fn.Coordinate = void 0;
class sR {
  constructor(e, n) {
    this.x = e, this.y = n;
  }
}
Fn.Coordinate = sR;
class oR {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} codec - The video codec.
   * @param {number} bitrate - The video bitrate.
   * @param {number} width - The video width.
   * @param {number} height - The video height.
   */
  constructor(e = "H264", n = 2e6, r = 1920, s = 1080) {
    this.codec = e, this.bitrate = n, this.width = r, this.height = s;
  }
  /**
   * Sets the video crop range.
   */
  setCropRange(e, n) {
    this.cropRange = {
      bottomRight: n,
      topLeft: e
    };
  }
}
Fn.AvatarVideoFormat = oR;
var mi = {}, nl;
function aR() {
  if (nl)
    return mi;
  nl = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.AvatarWebRTCConnectionResult = void 0;
  const t = P();
  let e = class extends t.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i) {
      super(s, o, a, i), this.privSDPAnswer = r;
    }
    /**
     * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
     * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
     * @function
     * @public
     * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
     */
    get SDPAnswer() {
      return this.privSDPAnswer;
    }
  };
  return mi.AvatarWebRTCConnectionResult = e, mi;
}
var Si = {}, rl;
function cR() {
  if (rl)
    return Si;
  rl = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.Diagnostics = void 0;
  const t = Se(), e = O();
  let n = class {
    static SetLoggingLevel(s) {
      this.privListener = new t.ConsoleLoggingListener(s), e.Events.instance.attachConsoleListener(this.privListener);
    }
    static StartConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !0);
    }
    static StopConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !1);
    }
    static SetLogOutputPath(s) {
      if (typeof window > "u")
        this.privListener && (this.privListener.logPath = s);
      else
        throw new Error("File system logging not available in browser.");
    }
    static set onLogOutput(s) {
      this.privListener && (this.privListener.logCallback = s);
    }
  };
  return Si.Diagnostics = n, n.privListener = void 0, Si;
}
var il;
function P() {
  return il || (il = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = uf();
    Object.defineProperty(t, "AudioConfig", { enumerable: !0, get: function() {
      return e.AudioConfig;
    } });
    var n = Wt;
    Object.defineProperty(t, "AudioStreamFormat", { enumerable: !0, get: function() {
      return n.AudioStreamFormat;
    } }), Object.defineProperty(t, "AudioFormatTag", { enumerable: !0, get: function() {
      return n.AudioFormatTag;
    } });
    var r = rf();
    Object.defineProperty(t, "AudioInputStream", { enumerable: !0, get: function() {
      return r.AudioInputStream;
    } }), Object.defineProperty(t, "PullAudioInputStream", { enumerable: !0, get: function() {
      return r.PullAudioInputStream;
    } }), Object.defineProperty(t, "PushAudioInputStream", { enumerable: !0, get: function() {
      return r.PushAudioInputStream;
    } });
    var s = Re;
    Object.defineProperty(t, "AudioOutputStream", { enumerable: !0, get: function() {
      return s.AudioOutputStream;
    } }), Object.defineProperty(t, "PullAudioOutputStream", { enumerable: !0, get: function() {
      return s.PullAudioOutputStream;
    } }), Object.defineProperty(t, "PushAudioOutputStream", { enumerable: !0, get: function() {
      return s.PushAudioOutputStream;
    } });
    var o = pf;
    Object.defineProperty(t, "CancellationReason", { enumerable: !0, get: function() {
      return o.CancellationReason;
    } });
    var a = Go;
    Object.defineProperty(t, "PullAudioInputStreamCallback", { enumerable: !0, get: function() {
      return a.PullAudioInputStreamCallback;
    } });
    var i = Qo;
    Object.defineProperty(t, "PushAudioOutputStreamCallback", { enumerable: !0, get: function() {
      return i.PushAudioOutputStreamCallback;
    } });
    var c = Yo;
    Object.defineProperty(t, "KeywordRecognitionModel", { enumerable: !0, get: function() {
      return c.KeywordRecognitionModel;
    } });
    var u = Zo;
    Object.defineProperty(t, "SessionEventArgs", { enumerable: !0, get: function() {
      return u.SessionEventArgs;
    } });
    var p = j_();
    Object.defineProperty(t, "RecognitionEventArgs", { enumerable: !0, get: function() {
      return p.RecognitionEventArgs;
    } });
    var d = df;
    Object.defineProperty(t, "OutputFormat", { enumerable: !0, get: function() {
      return d.OutputFormat;
    } });
    var l = x_();
    Object.defineProperty(t, "IntentRecognitionEventArgs", { enumerable: !0, get: function() {
      return l.IntentRecognitionEventArgs;
    } });
    var h = Xo;
    Object.defineProperty(t, "RecognitionResult", { enumerable: !0, get: function() {
      return h.RecognitionResult;
    } });
    var v = q_();
    Object.defineProperty(t, "SpeechRecognitionResult", { enumerable: !0, get: function() {
      return v.SpeechRecognitionResult;
    } });
    var g = F_();
    Object.defineProperty(t, "IntentRecognitionResult", { enumerable: !0, get: function() {
      return g.IntentRecognitionResult;
    } });
    var f = qn;
    Object.defineProperty(t, "LanguageUnderstandingModel", { enumerable: !0, get: function() {
      return f.LanguageUnderstandingModel;
    } });
    var m = $_();
    Object.defineProperty(t, "SpeechRecognitionEventArgs", { enumerable: !0, get: function() {
      return m.SpeechRecognitionEventArgs;
    } }), Object.defineProperty(t, "ConversationTranscriptionEventArgs", { enumerable: !0, get: function() {
      return m.ConversationTranscriptionEventArgs;
    } }), Object.defineProperty(t, "MeetingTranscriptionEventArgs", { enumerable: !0, get: function() {
      return m.MeetingTranscriptionEventArgs;
    } });
    var S = U_();
    Object.defineProperty(t, "SpeechRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return S.SpeechRecognitionCanceledEventArgs;
    } });
    var y = H_();
    Object.defineProperty(t, "TranslationRecognitionEventArgs", { enumerable: !0, get: function() {
      return y.TranslationRecognitionEventArgs;
    } });
    var E = W_();
    Object.defineProperty(t, "TranslationSynthesisEventArgs", { enumerable: !0, get: function() {
      return E.TranslationSynthesisEventArgs;
    } });
    var _ = vf();
    Object.defineProperty(t, "TranslationRecognitionResult", { enumerable: !0, get: function() {
      return _.TranslationRecognitionResult;
    } });
    var C = ea;
    Object.defineProperty(t, "TranslationSynthesisResult", { enumerable: !0, get: function() {
      return C.TranslationSynthesisResult;
    } });
    var R = ff;
    Object.defineProperty(t, "ResultReason", { enumerable: !0, get: function() {
      return R.ResultReason;
    } });
    var T = K_();
    Object.defineProperty(t, "SpeechConfig", { enumerable: !0, get: function() {
      return T.SpeechConfig;
    } }), Object.defineProperty(t, "SpeechConfigImpl", { enumerable: !0, get: function() {
      return T.SpeechConfigImpl;
    } });
    var A = J_();
    Object.defineProperty(t, "SpeechTranslationConfig", { enumerable: !0, get: function() {
      return A.SpeechTranslationConfig;
    } }), Object.defineProperty(t, "SpeechTranslationConfigImpl", { enumerable: !0, get: function() {
      return A.SpeechTranslationConfigImpl;
    } });
    var U = mf();
    Object.defineProperty(t, "PropertyCollection", { enumerable: !0, get: function() {
      return U.PropertyCollection;
    } });
    var K = ta;
    Object.defineProperty(t, "PropertyId", { enumerable: !0, get: function() {
      return K.PropertyId;
    } });
    var Y = G_();
    Object.defineProperty(t, "Recognizer", { enumerable: !0, get: function() {
      return Y.Recognizer;
    } });
    var J = Q_();
    Object.defineProperty(t, "SpeechRecognizer", { enumerable: !0, get: function() {
      return J.SpeechRecognizer;
    } });
    var he = Y_();
    Object.defineProperty(t, "IntentRecognizer", { enumerable: !0, get: function() {
      return he.IntentRecognizer;
    } });
    var ve = yf;
    Object.defineProperty(t, "VoiceProfileType", { enumerable: !0, get: function() {
      return ve.VoiceProfileType;
    } });
    var re = Z_();
    Object.defineProperty(t, "TranslationRecognizer", { enumerable: !0, get: function() {
      return re.TranslationRecognizer;
    } });
    var N = X_();
    Object.defineProperty(t, "Translations", { enumerable: !0, get: function() {
      return N.Translations;
    } });
    var X = Pf;
    Object.defineProperty(t, "NoMatchReason", { enumerable: !0, get: function() {
      return X.NoMatchReason;
    } });
    var Z = e0();
    Object.defineProperty(t, "NoMatchDetails", { enumerable: !0, get: function() {
      return Z.NoMatchDetails;
    } });
    var ye = na;
    Object.defineProperty(t, "TranslationRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return ye.TranslationRecognitionCanceledEventArgs;
    } });
    var Ie = n0();
    Object.defineProperty(t, "IntentRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return Ie.IntentRecognitionCanceledEventArgs;
    } });
    var Ve = ys;
    Object.defineProperty(t, "CancellationDetailsBase", { enumerable: !0, get: function() {
      return Ve.CancellationDetailsBase;
    } });
    var As = i0();
    Object.defineProperty(t, "CancellationDetails", { enumerable: !0, get: function() {
      return As.CancellationDetails;
    } });
    var Ms = wf;
    Object.defineProperty(t, "CancellationErrorCode", { enumerable: !0, get: function() {
      return Ms.CancellationErrorCode;
    } });
    var Os = s0();
    Object.defineProperty(t, "ConnectionEventArgs", { enumerable: !0, get: function() {
      return Os.ConnectionEventArgs;
    } });
    var kn = o0();
    Object.defineProperty(t, "ServiceEventArgs", { enumerable: !0, get: function() {
      return kn.ServiceEventArgs;
    } });
    var Wa = _f();
    Object.defineProperty(t, "Connection", { enumerable: !0, get: function() {
      return Wa.Connection;
    } });
    var Va = ra;
    Object.defineProperty(t, "PhraseListGrammar", { enumerable: !0, get: function() {
      return Va.PhraseListGrammar;
    } });
    var Ka = Tu();
    Object.defineProperty(t, "DialogServiceConfig", { enumerable: !0, get: function() {
      return Ka.DialogServiceConfig;
    } });
    var Ja = a0();
    Object.defineProperty(t, "BotFrameworkConfig", { enumerable: !0, get: function() {
      return Ja.BotFrameworkConfig;
    } });
    var ks = c0();
    Object.defineProperty(t, "CustomCommandsConfig", { enumerable: !0, get: function() {
      return ks.CustomCommandsConfig;
    } });
    var Ds = p0();
    Object.defineProperty(t, "DialogServiceConnector", { enumerable: !0, get: function() {
      return Ds.DialogServiceConnector;
    } });
    var Ns = ia;
    Object.defineProperty(t, "ActivityReceivedEventArgs", { enumerable: !0, get: function() {
      return Ns.ActivityReceivedEventArgs;
    } });
    var Ls = sa;
    Object.defineProperty(t, "TurnStatusReceivedEventArgs", { enumerable: !0, get: function() {
      return Ls.TurnStatusReceivedEventArgs;
    } });
    var zs = If;
    Object.defineProperty(t, "ServicePropertyChannel", { enumerable: !0, get: function() {
      return zs.ServicePropertyChannel;
    } });
    var js = bf;
    Object.defineProperty(t, "ProfanityOption", { enumerable: !0, get: function() {
      return js.ProfanityOption;
    } });
    var V = v0();
    Object.defineProperty(t, "BaseAudioPlayer", { enumerable: !0, get: function() {
      return V.BaseAudioPlayer;
    } });
    var Ne = aa;
    Object.defineProperty(t, "ConnectionMessageEventArgs", { enumerable: !0, get: function() {
      return Ne.ConnectionMessageEventArgs;
    } });
    var lt = Cf();
    Object.defineProperty(t, "ConnectionMessage", { enumerable: !0, get: function() {
      return lt.ConnectionMessage;
    } });
    var Ce = ca;
    Object.defineProperty(t, "VoiceProfile", { enumerable: !0, get: function() {
      return Ce.VoiceProfile;
    } });
    var ht = m0();
    Object.defineProperty(t, "VoiceProfileEnrollmentResult", { enumerable: !0, get: function() {
      return ht.VoiceProfileEnrollmentResult;
    } }), Object.defineProperty(t, "VoiceProfileEnrollmentCancellationDetails", { enumerable: !0, get: function() {
      return ht.VoiceProfileEnrollmentCancellationDetails;
    } });
    var It = S0();
    Object.defineProperty(t, "VoiceProfileResult", { enumerable: !0, get: function() {
      return It.VoiceProfileResult;
    } }), Object.defineProperty(t, "VoiceProfileCancellationDetails", { enumerable: !0, get: function() {
      return It.VoiceProfileCancellationDetails;
    } });
    var pr = y0();
    Object.defineProperty(t, "VoiceProfilePhraseResult", { enumerable: !0, get: function() {
      return pr.VoiceProfilePhraseResult;
    } });
    var Ga = C0();
    Object.defineProperty(t, "VoiceProfileClient", { enumerable: !0, get: function() {
      return Ga.VoiceProfileClient;
    } });
    var xs = _0();
    Object.defineProperty(t, "SpeakerRecognizer", { enumerable: !0, get: function() {
      return xs.SpeakerRecognizer;
    } });
    var gm = R0();
    Object.defineProperty(t, "SpeakerIdentificationModel", { enumerable: !0, get: function() {
      return gm.SpeakerIdentificationModel;
    } });
    var mm = P0();
    Object.defineProperty(t, "SpeakerVerificationModel", { enumerable: !0, get: function() {
      return mm.SpeakerVerificationModel;
    } });
    var Sm = E0();
    Object.defineProperty(t, "AutoDetectSourceLanguageConfig", { enumerable: !0, get: function() {
      return Sm.AutoDetectSourceLanguageConfig;
    } });
    var ym = ua;
    Object.defineProperty(t, "AutoDetectSourceLanguageResult", { enumerable: !0, get: function() {
      return ym.AutoDetectSourceLanguageResult;
    } });
    var Cm = pa;
    Object.defineProperty(t, "SourceLanguageConfig", { enumerable: !0, get: function() {
      return Cm.SourceLanguageConfig;
    } });
    var Qa = w0();
    Object.defineProperty(t, "SpeakerRecognitionResult", { enumerable: !0, get: function() {
      return Qa.SpeakerRecognitionResult;
    } }), Object.defineProperty(t, "SpeakerRecognitionResultType", { enumerable: !0, get: function() {
      return Qa.SpeakerRecognitionResultType;
    } }), Object.defineProperty(t, "SpeakerRecognitionCancellationDetails", { enumerable: !0, get: function() {
      return Qa.SpeakerRecognitionCancellationDetails;
    } });
    var Be = Au();
    Object.defineProperty(t, "Conversation", { enumerable: !0, get: function() {
      return Be.Conversation;
    } }), Object.defineProperty(t, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationExpirationEventArgs;
    } }), Object.defineProperty(t, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationParticipantsChangedEventArgs;
    } }), Object.defineProperty(t, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationTranslationCanceledEventArgs;
    } }), Object.defineProperty(t, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationTranslationEventArgs;
    } }), Object.defineProperty(t, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return Be.ConversationTranslationResult;
    } }), Object.defineProperty(t, "ConversationTranslator", { enumerable: !0, get: function() {
      return Be.ConversationTranslator;
    } }), Object.defineProperty(t, "ConversationTranscriber", { enumerable: !0, get: function() {
      return Be.ConversationTranscriber;
    } }), Object.defineProperty(t, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return Be.ConversationTranscriptionResult;
    } }), Object.defineProperty(t, "Meeting", { enumerable: !0, get: function() {
      return Be.Meeting;
    } }), Object.defineProperty(t, "MeetingTranscriber", { enumerable: !0, get: function() {
      return Be.MeetingTranscriber;
    } }), Object.defineProperty(t, "Participant", { enumerable: !0, get: function() {
      return Be.Participant;
    } }), Object.defineProperty(t, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return Be.ParticipantChangedReason;
    } }), Object.defineProperty(t, "User", { enumerable: !0, get: function() {
      return Be.User;
    } });
    var _m = Mu();
    Object.defineProperty(t, "Synthesizer", { enumerable: !0, get: function() {
      return _m.Synthesizer;
    } });
    var Rm = _u;
    Object.defineProperty(t, "SpeechSynthesisOutputFormat", { enumerable: !0, get: function() {
      return Rm.SpeechSynthesisOutputFormat;
    } });
    var Pm = $0();
    Object.defineProperty(t, "SpeechSynthesizer", { enumerable: !0, get: function() {
      return Pm.SpeechSynthesizer;
    } });
    var Em = la;
    Object.defineProperty(t, "SynthesisResult", { enumerable: !0, get: function() {
      return Em.SynthesisResult;
    } });
    var Tm = H0();
    Object.defineProperty(t, "SpeechSynthesisResult", { enumerable: !0, get: function() {
      return Tm.SpeechSynthesisResult;
    } });
    var wm = ha;
    Object.defineProperty(t, "SpeechSynthesisEventArgs", { enumerable: !0, get: function() {
      return wm.SpeechSynthesisEventArgs;
    } });
    var Im = va;
    Object.defineProperty(t, "SpeechSynthesisWordBoundaryEventArgs", { enumerable: !0, get: function() {
      return Im.SpeechSynthesisWordBoundaryEventArgs;
    } });
    var bm = fa;
    Object.defineProperty(t, "SpeechSynthesisBookmarkEventArgs", { enumerable: !0, get: function() {
      return bm.SpeechSynthesisBookmarkEventArgs;
    } });
    var Am = ga;
    Object.defineProperty(t, "SpeechSynthesisVisemeEventArgs", { enumerable: !0, get: function() {
      return Am.SpeechSynthesisVisemeEventArgs;
    } });
    var Mm = jf;
    Object.defineProperty(t, "SpeechSynthesisBoundaryType", { enumerable: !0, get: function() {
      return Mm.SpeechSynthesisBoundaryType;
    } });
    var Om = G0();
    Object.defineProperty(t, "SynthesisVoicesResult", { enumerable: !0, get: function() {
      return Om.SynthesisVoicesResult;
    } });
    var km = xf;
    Object.defineProperty(t, "VoiceInfo", { enumerable: !0, get: function() {
      return km.VoiceInfo;
    } });
    var Dm = ma;
    Object.defineProperty(t, "SpeakerAudioDestination", { enumerable: !0, get: function() {
      return Dm.SpeakerAudioDestination;
    } });
    var Nm = X0();
    Object.defineProperty(t, "ConversationTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return Nm.ConversationTranscriptionCanceledEventArgs;
    } });
    var Lm = eR();
    Object.defineProperty(t, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return Lm.MeetingTranscriptionCanceledEventArgs;
    } });
    var zm = Bf;
    Object.defineProperty(t, "PronunciationAssessmentGradingSystem", { enumerable: !0, get: function() {
      return zm.PronunciationAssessmentGradingSystem;
    } });
    var jm = qf;
    Object.defineProperty(t, "PronunciationAssessmentGranularity", { enumerable: !0, get: function() {
      return jm.PronunciationAssessmentGranularity;
    } });
    var xm = tR();
    Object.defineProperty(t, "PronunciationAssessmentConfig", { enumerable: !0, get: function() {
      return xm.PronunciationAssessmentConfig;
    } });
    var Bm = nR();
    Object.defineProperty(t, "PronunciationAssessmentResult", { enumerable: !0, get: function() {
      return Bm.PronunciationAssessmentResult;
    } });
    var qm = Iu;
    Object.defineProperty(t, "LanguageIdMode", { enumerable: !0, get: function() {
      return qm.LanguageIdMode;
    } });
    var Fm = rR();
    Object.defineProperty(t, "AvatarConfig", { enumerable: !0, get: function() {
      return Fm.AvatarConfig;
    } });
    var $m = Uf;
    Object.defineProperty(t, "AvatarEventArgs", { enumerable: !0, get: function() {
      return $m.AvatarEventArgs;
    } });
    var Um = iR();
    Object.defineProperty(t, "AvatarSynthesizer", { enumerable: !0, get: function() {
      return Um.AvatarSynthesizer;
    } });
    var cp = Fn;
    Object.defineProperty(t, "AvatarVideoFormat", { enumerable: !0, get: function() {
      return cp.AvatarVideoFormat;
    } }), Object.defineProperty(t, "Coordinate", { enumerable: !0, get: function() {
      return cp.Coordinate;
    } });
    var Hm = aR();
    Object.defineProperty(t, "AvatarWebRTCConnectionResult", { enumerable: !0, get: function() {
      return Hm.AvatarWebRTCConnectionResult;
    } });
    var Wm = cR();
    Object.defineProperty(t, "Diagnostics", { enumerable: !0, get: function() {
      return Wm.Diagnostics;
    } });
    var Vm = yu;
    Object.defineProperty(t, "LogLevel", { enumerable: !0, get: function() {
      return Vm.LogLevel;
    } });
  }(pc)), pc;
}
var sl;
function uR() {
  if (sl)
    return mr;
  sl = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.ProxyInfo = void 0;
  const t = P();
  let e = class Wf {
    constructor(r, s, o, a) {
      this.privProxyHostName = r, this.privProxyPort = s, this.privProxyUserName = o, this.privProxyPassword = a;
    }
    static fromParameters(r) {
      return new Wf(r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyPort), 10), r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyUserName), r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyPassword));
    }
    static fromRecognizerConfig(r) {
      return this.fromParameters(r.parameters);
    }
    get HostName() {
      return this.privProxyHostName;
    }
    get Port() {
      return this.privProxyPort;
    }
    get UserName() {
      return this.privProxyUserName;
    }
    get Password() {
      return this.privProxyPassword;
    }
  };
  return mr.ProxyInfo = e, mr;
}
var Vf = {};
const pR = /* @__PURE__ */ new Set(["json", "buffer", "string"]);
var dR = (t) => (...e) => {
  const n = /* @__PURE__ */ new Set();
  let r, s, o, a = "";
  return e.forEach((i) => {
    if (typeof i == "string")
      if (i.toUpperCase() === i)
        if (r) {
          const c = `Can't set method to ${i}, already set to ${r}.`;
          throw new Error(c);
        } else
          r = i;
      else if (i.startsWith("http:") || i.startsWith("https:"))
        a = i;
      else if (pR.has(i))
        s = i;
      else
        throw new Error(`Unknown encoding, ${i}`);
    else if (typeof i == "number")
      n.add(i);
    else if (typeof i == "object")
      if (Array.isArray(i) || i instanceof Set)
        i.forEach((c) => n.add(c));
      else {
        if (o)
          throw new Error("Cannot set headers twice.");
        o = i;
      }
    else
      throw new Error(`Unknown type: ${typeof i}`);
  }), r || (r = "GET"), n.size === 0 && n.add(200), t(n, r, s, o, a);
};
const lR = dR;
class Ou extends Error {
  constructor(e, ...n) {
    super(...n), Error.captureStackTrace && Error.captureStackTrace(this, Ou), this.name = "StatusError", this.message = e.statusMessage, this.statusCode = e.status, this.res = e, this.json = e.json.bind(e), this.text = e.text.bind(e), this.arrayBuffer = e.arrayBuffer.bind(e);
    let r;
    Object.defineProperty(this, "responseBody", { get: () => (r || (r = this.arrayBuffer()), r) }), this.headers = {};
    for (const [o, a] of e.headers.entries())
      this.headers[o.toLowerCase()] = a;
  }
}
const hR = (t, e, n, r, s) => async (o, a, i = {}) => {
  o = s + (o || "");
  let c = new URL(o);
  if (r || (r = {}), c.username && (r.Authorization = "Basic " + btoa(c.username + ":" + c.password), c = new URL(c.protocol + "//" + c.host + c.pathname + c.search)), c.protocol !== "https:" && c.protocol !== "http:")
    throw new Error(`Unknown protocol, ${c.protocol}`);
  if (a && !(a instanceof ArrayBuffer || ArrayBuffer.isView(a) || typeof a == "string"))
    if (typeof a == "object")
      a = JSON.stringify(a), r["Content-Type"] = "application/json";
    else
      throw new Error("Unknown body type.");
  i = new Headers({ ...r || {}, ...i });
  const u = await fetch(c, { method: e, headers: i, body: a });
  if (u.statusCode = u.status, !t.has(u.status))
    throw new Ou(u);
  return n === "json" ? u.json() : n === "buffer" ? u.arrayBuffer() : n === "string" ? u.text() : u;
};
var vR = lR(hR);
(function(t) {
  var e = $ && $.__importDefault || function(a) {
    return a && a.__esModule ? a : { default: a };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.RestMessageAdapter = t.RestRequestType = void 0;
  const n = e(vR), r = O();
  var s;
  (function(a) {
    a.Get = "GET", a.Post = "POST", a.Delete = "DELETE", a.File = "file";
  })(s = t.RestRequestType || (t.RestRequestType = {}));
  class o {
    constructor(i) {
      if (!i)
        throw new r.ArgumentNullError("configParams");
      this.privHeaders = i.headers, this.privIgnoreCache = i.ignoreCache;
    }
    static extractHeaderValue(i, c) {
      let u = "";
      try {
        const p = c.trim().split(/[\r\n]+/), d = {};
        p.forEach((l) => {
          const h = l.split(": "), v = h.shift().toLowerCase(), g = h.join(": ");
          d[v] = g;
        }), u = d[i.toLowerCase()];
      } catch {
      }
      return u;
    }
    set options(i) {
      this.privHeaders = i.headers, this.privIgnoreCache = i.ignoreCache;
    }
    setHeaders(i, c) {
      this.privHeaders[i] = c;
    }
    request(i, c, u = {}, p = null) {
      const d = new r.Deferred(), l = i === s.File ? "POST" : i, h = (g, f = {}) => {
        const m = g;
        return {
          data: JSON.stringify(f),
          headers: JSON.stringify(g.headers),
          json: f,
          ok: g.statusCode >= 200 && g.statusCode < 300,
          status: g.statusCode,
          statusText: f.error ? f.error.message : m.statusText ? m.statusText : m.statusMessage
        };
      }, v = (g) => {
        const f = n.default(c, l, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404), m = this.queryParams(u) === "" ? "" : `?${this.queryParams(u)}`;
        f(m, g).then(async (S) => {
          if (i === s.Delete || S.statusCode === 204)
            d.resolve(h(S));
          else
            try {
              const y = await S.json();
              d.resolve(h(S, y));
            } catch {
              d.resolve(h(S));
            }
        }).catch((S) => {
          d.reject(S);
        });
      };
      return this.privIgnoreCache && (this.privHeaders["Cache-Control"] = "no-cache"), i === s.Post && p && (this.privHeaders["content-type"] = "application/json", this.privHeaders["Content-Type"] = "application/json"), v(p), d.promise;
    }
    queryParams(i = {}) {
      return Object.keys(i).map((c) => encodeURIComponent(c) + "=" + encodeURIComponent(i[c])).join("&");
    }
  }
  t.RestMessageAdapter = o;
})(Vf);
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.RestConfigBase = void 0;
class jt {
  static get requestOptions() {
    return jt.privDefaultRequestOptions;
  }
  static get configParams() {
    return jt.privDefaultParams;
  }
  static get restErrors() {
    return jt.privRestErrors;
  }
}
_s.RestConfigBase = jt;
jt.privDefaultRequestOptions = {
  headers: {
    Accept: "application/json"
  },
  ignoreCache: !1,
  timeout: 1e4
};
jt.privRestErrors = {
  authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
  authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
  invalidArgs: "Required input not found: {arg}.",
  invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
  invalidParticipantRequest: "The requested participant was not found.",
  permissionDeniedConnect: "Required credentials not found.",
  permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
  permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
  permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
  permissionDeniedStart: "Invalid operation: there is already an active conversation."
};
jt.privDefaultParams = {
  apiVersion: "api-version",
  authorization: "Authorization",
  clientAppId: "X-ClientAppId",
  contentTypeKey: "Content-Type",
  correlationId: "X-CorrelationId",
  languageCode: "language",
  nickname: "nickname",
  profanity: "profanity",
  requestId: "X-RequestId",
  roomId: "roomid",
  sessionToken: "token",
  subscriptionKey: "Ocp-Apim-Subscription-Key",
  subscriptionRegion: "Ocp-Apim-Subscription-Region",
  token: "X-CapitoToken"
};
var ol;
function Se() {
  return ol || (ol = 1, function(t) {
    var e = $ && $.__createBinding || (Object.create ? function(r, s, o, a) {
      a === void 0 && (a = o), Object.defineProperty(r, a, { enumerable: !0, get: function() {
        return s[o];
      } });
    } : function(r, s, o, a) {
      a === void 0 && (a = o), r[a] = s[o];
    }), n = $ && $.__exportStar || function(r, s) {
      for (var o in r)
        o !== "default" && !s.hasOwnProperty(o) && e(s, r, o);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(Wo, t), n(tf, t), n(d_(), t), n(l_(), t), n(Vo, t), n(Ko, t), n(gs, t), n(Jo, t), n(uR(), t), n(Vf, t), n(_s, t);
  }(ac)), ac;
}
var al;
function fR() {
  if (al)
    return vr;
  al = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.IntentConnectionFactory = void 0;
  const t = Se(), e = P(), n = ot(), r = b(), s = me;
  let o = class extends n.ConnectionFactoryBase {
    create(i, c, u) {
      let p = i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint);
      if (!p) {
        const v = i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_IntentRegion), g = n.ConnectionFactoryBase.getHostSuffix(v);
        p = i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, "wss://" + v + ".sr.speech" + g) + "/speech/recognition/interactive/cognitiveservices/v1";
      }
      const d = {
        format: "simple",
        language: i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(i, d, p);
      const l = {};
      c.token !== void 0 && c.token !== "" && (l[c.headerName] = c.token), l[s.HeaderNames.ConnectionId] = u, i.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, p);
      const h = i.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(p, d, l, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(i), h, u);
    }
    getSpeechRegionFromIntentRegion(i) {
      switch (i) {
        case "West US":
        case "US West":
        case "westus":
          return "uswest";
        case "West US 2":
        case "US West 2":
        case "westus2":
          return "uswest2";
        case "South Central US":
        case "US South Central":
        case "southcentralus":
          return "ussouthcentral";
        case "West Central US":
        case "US West Central":
        case "westcentralus":
          return "uswestcentral";
        case "East US":
        case "US East":
        case "eastus":
          return "useast";
        case "East US 2":
        case "US East 2":
        case "eastus2":
          return "useast2";
        case "West Europe":
        case "Europe West":
        case "westeurope":
          return "europewest";
        case "North Europe":
        case "Europe North":
        case "northeurope":
          return "europenorth";
        case "Brazil South":
        case "South Brazil":
        case "southbrazil":
          return "brazilsouth";
        case "Australia East":
        case "East Australia":
        case "eastaustralia":
          return "australiaeast";
        case "Southeast Asia":
        case "Asia Southeast":
        case "southeastasia":
          return "asiasoutheast";
        case "East Asia":
        case "Asia East":
        case "eastasia":
          return "asiaeast";
        default:
          return i;
      }
    }
  };
  return vr.IntentConnectionFactory = o, vr;
}
var on = {}, cl;
function gR() {
  if (cl)
    return on;
  cl = 1, Object.defineProperty(on, "__esModule", { value: !0 }), on.VoiceProfileConnectionFactory = on.SpeakerRecognitionConnectionFactory = void 0;
  const t = Se(), e = P(), n = ot(), r = b(), s = me;
  class o extends n.ConnectionFactoryBase {
    create(u, p, d, l) {
      let h = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint);
      if (!h) {
        const m = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region), S = n.ConnectionFactoryBase.getHostSuffix(m), y = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, `wss://${m}.spr-frontend.speech${S}`), E = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
        h = `${y}/speaker/ws/${this.scenarioToPath(E)}/${d}`;
      }
      const v = {
        format: "simple",
        language: u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(u, v, h);
      const g = {};
      p.token !== void 0 && p.token !== "" && (g[p.headerName] = p.token), g[s.HeaderNames.ConnectionId] = l, g[s.HeaderNames.SpIDAuthKey] = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Key), u.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, h);
      const f = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(h, v, g, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), f, l);
    }
    scenarioToPath(u) {
      switch (u) {
        case "TextIndependentVerification":
        case "2":
          return "verification/text-independent";
        case "TextDependentVerification":
        case "1":
          return "verification/text-dependent";
        default:
          return "identification/text-independent";
      }
    }
  }
  let a = class extends o {
    create(u, p, d) {
      return super.create(u, p, "recognition", d);
    }
  };
  on.SpeakerRecognitionConnectionFactory = a;
  class i extends o {
    create(u, p, d) {
      return super.create(u, p, "profile", d);
    }
  }
  return on.VoiceProfileConnectionFactory = i, on;
}
var Sa = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.RecognitionEndedEvent = t.RecognitionCompletionStatus = t.RecognitionStartedEvent = t.ConnectingToServiceEvent = t.ListeningStartedEvent = t.RecognitionTriggeredEvent = t.SpeechRecognitionEvent = void 0;
  const e = O();
  class n extends e.PlatformEvent {
    constructor(p, d, l, h = e.EventType.Info) {
      super(p, h), this.privRequestId = d, this.privSessionId = l;
    }
    get requestId() {
      return this.privRequestId;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  t.SpeechRecognitionEvent = n;
  class r extends n {
    constructor(p, d, l, h) {
      super("RecognitionTriggeredEvent", p, d), this.privAudioSourceId = l, this.privAudioNodeId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  t.RecognitionTriggeredEvent = r;
  class s extends n {
    constructor(p, d, l, h) {
      super("ListeningStartedEvent", p, d), this.privAudioSourceId = l, this.privAudioNodeId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  t.ListeningStartedEvent = s;
  class o extends n {
    constructor(p, d, l) {
      super("ConnectingToServiceEvent", p, l), this.privAuthFetchEventid = d;
    }
    get authFetchEventid() {
      return this.privAuthFetchEventid;
    }
  }
  t.ConnectingToServiceEvent = o;
  class a extends n {
    constructor(p, d, l, h, v) {
      super("RecognitionStartedEvent", p, v), this.privAudioSourceId = d, this.privAudioNodeId = l, this.privAuthFetchEventId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  t.RecognitionStartedEvent = a;
  var i;
  (function(u) {
    u[u.Success = 0] = "Success", u[u.AudioSourceError = 1] = "AudioSourceError", u[u.AudioSourceTimeout = 2] = "AudioSourceTimeout", u[u.AuthTokenFetchError = 3] = "AuthTokenFetchError", u[u.AuthTokenFetchTimeout = 4] = "AuthTokenFetchTimeout", u[u.UnAuthorized = 5] = "UnAuthorized", u[u.ConnectTimeout = 6] = "ConnectTimeout", u[u.ConnectError = 7] = "ConnectError", u[u.ClientRecognitionActivityTimeout = 8] = "ClientRecognitionActivityTimeout", u[u.UnknownError = 9] = "UnknownError";
  })(i = t.RecognitionCompletionStatus || (t.RecognitionCompletionStatus = {}));
  class c extends n {
    constructor(p, d, l, h, v, g, f, m) {
      super("RecognitionEndedEvent", p, v, f === i.Success ? e.EventType.Info : e.EventType.Error), this.privAudioSourceId = d, this.privAudioNodeId = l, this.privAuthFetchEventId = h, this.privStatus = f, this.privError = m, this.privServiceTag = g;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
    get serviceTag() {
      return this.privServiceTag;
    }
    get status() {
      return this.privStatus;
    }
    get error() {
      return this.privError;
    }
  }
  t.RecognitionEndedEvent = c;
})(Sa);
var yi = {}, Tt = {};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.SpeechConnectionMessage = void 0;
const fc = O(), gt = me;
class ku extends fc.ConnectionMessage {
  constructor(e, n, r, s, o, a, i, c) {
    if (!n)
      throw new fc.ArgumentNullError("path");
    if (!r)
      throw new fc.ArgumentNullError("requestId");
    const u = {};
    if (u[gt.HeaderNames.Path] = n, u[gt.HeaderNames.RequestId] = r, u[gt.HeaderNames.RequestTimestamp] = (/* @__PURE__ */ new Date()).toISOString(), s && (u[gt.HeaderNames.ContentType] = s), a && (u[gt.HeaderNames.RequestStreamId] = a), i)
      for (const p in i)
        p && (u[p] = i[p]);
    c ? super(e, o, u, c) : super(e, o, u), this.privPath = n, this.privRequestId = r, this.privContentType = s, this.privStreamId = a, this.privAdditionalHeaders = i;
  }
  get path() {
    return this.privPath;
  }
  get requestId() {
    return this.privRequestId;
  }
  get contentType() {
    return this.privContentType;
  }
  get streamId() {
    return this.privStreamId;
  }
  get additionalHeaders() {
    return this.privAdditionalHeaders;
  }
  static fromConnectionMessage(e) {
    let n = null, r = null, s = null, o = null;
    const a = {};
    if (e.headers)
      for (const i in e.headers)
        i && (i.toLowerCase() === gt.HeaderNames.Path.toLowerCase() ? n = e.headers[i] : i.toLowerCase() === gt.HeaderNames.RequestId.toLowerCase() ? r = e.headers[i] : i.toLowerCase() === gt.HeaderNames.ContentType.toLowerCase() ? s = e.headers[i] : i.toLowerCase() === gt.HeaderNames.RequestStreamId.toLowerCase() ? o = e.headers[i] : a[i] = e.headers[i]);
    return new ku(e.messageType, n, r, s, e.body, o, a, e.id);
  }
}
Tt.SpeechConnectionMessage = ku;
var ul;
function mR() {
  if (ul)
    return yi;
  ul = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.ServiceRecognizerBase = void 0;
  const t = Se(), e = O(), n = P(), r = b(), s = Tt;
  let o = class Qi {
    constructor(i, c, u, p, d) {
      if (this.privConnectionConfigurationPromise = void 0, this.privConnectionPromise = void 0, this.privSetTimeout = setTimeout, this.privIsLiveAudio = !1, this.privAverageBytesPerMs = 0, this.privEnableSpeakerId = !1, this.privExpectContentAssessmentResponse = !1, this.recognizeOverride = void 0, this.recognizeSpeaker = void 0, this.disconnectOverride = void 0, this.receiveMessageOverride = void 0, this.sendPrePayloadJSONOverride = void 0, this.postConnectImplOverride = void 0, this.configConnectionOverride = void 0, this.handleSpeechPhraseMessage = void 0, this.handleSpeechHypothesisMessage = void 0, !i)
        throw new e.ArgumentNullError("authentication");
      if (!c)
        throw new e.ArgumentNullError("connectionFactory");
      if (!u)
        throw new e.ArgumentNullError("audioSource");
      if (!p)
        throw new e.ArgumentNullError("recognizerConfig");
      this.privEnableSpeakerId = p.isSpeakerDiarizationEnabled, this.privMustReportEndOfStream = !1, this.privAuthentication = i, this.privConnectionFactory = c, this.privAudioSource = u, this.privRecognizerConfig = p, this.privIsDisposed = !1, this.privRecognizer = d, this.privRequestSession = new r.RequestSession(this.privAudioSource.id()), this.privConnectionEvents = new e.EventSource(), this.privServiceEvents = new e.EventSource(), this.privDynamicGrammar = new r.DynamicGrammarBuilder(), this.privSpeechContext = new r.SpeechContext(this.privDynamicGrammar), this.privAgentConfig = new r.AgentConfig(), this.privRecognizerConfig.parameters.getProperty(n.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? this.privSetTimeout = e.Timeout.setTimeout : (typeof window < "u" && (this.privSetTimeout = window.setTimeout.bind(window)), typeof globalThis < "u" && (this.privSetTimeout = globalThis.setTimeout.bind(globalThis))), this.connectionEvents.attach((h) => {
        if (h.name === "ConnectionClosedEvent") {
          const v = h;
          (v.statusCode === 1003 || v.statusCode === 1007 || v.statusCode === 1002 || v.statusCode === 4e3 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) && this.cancelRecognitionLocal(n.CancellationReason.Error, v.statusCode === 1007 ? n.CancellationErrorCode.BadRequestParameters : n.CancellationErrorCode.ConnectionFailure, `${v.reason} websocket error code: ${v.statusCode}`);
        }
      }), this.privEnableSpeakerId && (this.privDiarizationSessionId = e.createNoDashGuid()), this.setLanguageIdJson(), this.setOutputDetailLevelJson();
    }
    setTranslationJson() {
      const i = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (i !== void 0) {
        const c = i.split(","), u = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationVoice, void 0), p = u !== void 0 ? "Synthesize" : "None";
        if (this.privSpeechContext.setSection("translation", {
          onSuccess: { action: p },
          output: { interimResults: { mode: "Always" } },
          targetLanguages: c
        }), u !== void 0) {
          const d = {};
          for (const l of c)
            d[l] = u;
          this.privSpeechContext.setSection("synthesis", {
            defaultVoices: d
          });
        }
      }
    }
    setSpeechSegmentationTimeoutJson() {
      const i = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.Speech_SegmentationSilenceTimeoutMs, void 0), c = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.Speech_SegmentationMaximumTimeMs, void 0), u = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.Speech_SegmentationStrategy, void 0), p = {
        segmentation: {
          mode: ""
        }
      };
      let d = !1;
      if (u !== void 0) {
        d = !0;
        let l = "";
        switch (u.toLowerCase()) {
          case "default":
            break;
          case "time":
            l = "Custom";
            break;
          case "semantic":
            l = "Semantic";
            break;
        }
        p.segmentation.mode = l;
      }
      if (i !== void 0) {
        d = !0;
        const l = parseInt(i, 10);
        p.segmentation.mode = "Custom", p.segmentation.segmentationSilenceTimeoutMs = l;
      }
      if (c !== void 0) {
        d = !0;
        const l = parseInt(c, 10);
        p.segmentation.mode = "Custom", p.segmentation.segmentationForcedTimeoutMs = l;
      }
      if (d) {
        const l = this.recognitionMode === r.RecognitionMode.Conversation ? "CONVERSATION" : this.recognitionMode === r.RecognitionMode.Dictation ? "DICTATION" : "INTERACTIVE", h = this.privSpeechContext.getSection("phraseDetection");
        h.mode = l, h[l] = p, this.privSpeechContext.setSection("phraseDetection", h);
      }
    }
    setLanguageIdJson() {
      const i = this.privSpeechContext.getSection("phraseDetection");
      if (this.privRecognizerConfig.autoDetectSourceLanguages !== void 0) {
        const u = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
        let p;
        this.privRecognizerConfig.languageIdMode === "Continuous" ? p = "DetectContinuous" : p = "DetectAtAudioStart", this.privSpeechContext.setSection("languageId", {
          Priority: "PrioritizeLatency",
          languages: u,
          mode: p,
          onSuccess: { action: "Recognize" },
          onUnknown: { action: "None" }
        }), this.privSpeechContext.setSection("phraseOutput", {
          interimResults: {
            resultType: "Auto"
          },
          phraseResults: {
            resultType: "Always"
          }
        });
        const d = this.privRecognizerConfig.sourceLanguageModels;
        d !== void 0 && (i.customModels = d, i.onInterim = { action: "None" }, i.onSuccess = { action: "None" });
      }
      this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 && (i.onInterim = { action: "Translate" }, i.onSuccess = { action: "Translate" }, this.privSpeechContext.setSection("phraseOutput", {
        interimResults: {
          resultType: "None"
        },
        phraseResults: {
          resultType: "None"
        }
      })), this.privSpeechContext.setSection("phraseDetection", i);
    }
    setOutputDetailLevelJson() {
      this.privEnableSpeakerId && (this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true" ? this.privSpeechContext.setWordLevelTimings() : this.privRecognizerConfig.parameters.getProperty(r.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Simple]).toLowerCase() === n.OutputFormat[n.OutputFormat.Detailed].toLocaleLowerCase() && this.privSpeechContext.setDetailedOutputFormat());
    }
    get isSpeakerDiarizationEnabled() {
      return this.privEnableSpeakerId;
    }
    get audioSource() {
      return this.privAudioSource;
    }
    get speechContext() {
      return this.privSpeechContext;
    }
    get dynamicGrammar() {
      return this.privDynamicGrammar;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    set conversationTranslatorToken(i) {
      this.privRecognizerConfig.parameters.setProperty(n.PropertyId.ConversationTranslator_Token, i);
    }
    set voiceProfileType(i) {
      this.privRecognizerConfig.parameters.setProperty(n.PropertyId.SpeechServiceConnection_SpeakerIdMode, i);
    }
    set authentication(i) {
      this.privAuthentication = i;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(i) {
      if (this.privIsDisposed = !0, this.privConnectionConfigurationPromise !== void 0)
        try {
          await (await this.privConnectionConfigurationPromise).dispose(i);
        } catch {
          return;
        }
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    get recognitionMode() {
      return this.privRecognizerConfig.recognitionMode;
    }
    async recognize(i, c, u) {
      if (this.recognizeOverride !== void 0) {
        await this.recognizeOverride(i, c, u);
        return;
      }
      this.privConnectionConfigurationPromise = void 0, this.privRecognizerConfig.recognitionMode = i, this.setSpeechSegmentationTimeoutJson(), this.setTranslationJson(), this.privSuccessCallback = c, this.privErrorCallback = u, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
      const p = this.connectImpl();
      let d;
      try {
        const v = await this.audioSource.attach(this.privRequestSession.audioNodeId), g = await this.audioSource.format, f = await this.audioSource.deviceInfo;
        this.privIsLiveAudio = f.type && f.type === r.type.Microphones, d = new t.ReplayableAudioNode(v, g.avgBytesPerSec), await this.privRequestSession.onAudioSourceAttachCompleted(d, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: f };
      } catch (v) {
        throw await this.privRequestSession.onStopRecognizing(), v;
      }
      try {
        await p;
      } catch (v) {
        await this.cancelRecognitionLocal(n.CancellationReason.Error, n.CancellationErrorCode.ConnectionFailure, v);
        return;
      }
      const l = new n.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, l), this.receiveMessage(), this.sendAudio(d).catch(async (v) => {
        await this.cancelRecognitionLocal(n.CancellationReason.Error, n.CancellationErrorCode.RuntimeError, v);
      });
    }
    async stopRecognizing() {
      if (this.privRequestSession.isRecognizing)
        try {
          await this.audioSource.turnOff(), await this.sendFinalAudio(), await this.privRequestSession.onStopRecognizing(), await this.privRequestSession.turnCompletionPromise;
        } finally {
          await this.privRequestSession.dispose();
        }
    }
    async connect() {
      return await this.connectImpl(), Promise.resolve();
    }
    connectAsync(i, c) {
      this.connectImpl().then(() => {
        try {
          i && i();
        } catch (u) {
          c && c(u);
        }
      }, (u) => {
        try {
          c && c(u);
        } catch {
        }
      });
    }
    async disconnect() {
      if (await this.cancelRecognitionLocal(n.CancellationReason.Error, n.CancellationErrorCode.NoError, "Disconnecting"), this.disconnectOverride !== void 0 && await this.disconnectOverride(), this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose();
        } catch {
        }
      this.privConnectionPromise = void 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendMessage(i) {
    }
    async sendNetworkMessage(i, c) {
      const u = typeof c == "string" ? e.MessageType.Text : e.MessageType.Binary, p = typeof c == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new s.SpeechConnectionMessage(u, i, this.privRequestSession.requestId, p, c));
    }
    set activityTemplate(i) {
      this.privActivityTemplate = i;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set expectContentAssessmentResponse(i) {
      this.privExpectContentAssessmentResponse = i;
    }
    async sendTelemetryData() {
      const i = this.privRequestSession.getTelemetry();
      if (Qi.telemetryDataEnabled !== !0 || this.privIsDisposed || i === null)
        return;
      if (Qi.telemetryData)
        try {
          Qi.telemetryData(i);
        } catch {
        }
      await (await this.fetchConnection()).send(new s.SpeechConnectionMessage(e.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", i));
    }
    // Cancels recognition.
    async cancelRecognitionLocal(i, c, u) {
      this.privRequestSession.isRecognizing && (await this.privRequestSession.onStopRecognizing(), this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i, c, u));
    }
    async receiveMessage() {
      try {
        if (this.privIsDisposed)
          return;
        let i = await this.fetchConnection();
        const c = await i.read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (!c)
          return this.receiveMessage();
        this.privServiceHasSentMessage = !0;
        const u = s.SpeechConnectionMessage.fromConnectionMessage(c);
        if (u.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase())
          switch (u.path.toLowerCase()) {
            case "turn.start":
              this.privMustReportEndOfStream = !0, this.privRequestSession.onServiceTurnStartResponse();
              break;
            case "speech.startdetected":
              const p = r.SpeechDetected.fromJSON(u.textBody, this.privRequestSession.currentTurnAudioOffset), d = new n.RecognitionEventArgs(p.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, d);
              break;
            case "speech.enddetected":
              let l;
              u.textBody.length > 0 ? l = u.textBody : l = "{ Offset: 0 }";
              const h = r.SpeechDetected.fromJSON(l, this.privRequestSession.currentTurnAudioOffset), v = new n.RecognitionEventArgs(h.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, v);
              break;
            case "turn.end":
              await this.sendTelemetryData(), this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream && (this.privMustReportEndOfStream = !1, await this.cancelRecognitionLocal(n.CancellationReason.EndOfStream, n.CancellationErrorCode.NoError, void 0));
              const g = new n.SessionEventArgs(this.privRequestSession.sessionId);
              if (await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition), !this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, g);
                return;
              } else
                i = await this.fetchConnection(), await this.sendPrePayloadJSON(i);
              break;
            default:
              await this.processTypeSpecificMessages(u) || this.privServiceEvents && this.serviceEvents.onEvent(new e.ServiceEvent(u.path.toLowerCase(), u.textBody));
          }
        return this.receiveMessage();
      } catch {
        return null;
      }
    }
    updateSpeakerDiarizationAudioOffset() {
      const i = this.privRequestSession.recognitionBytesSent, c = this.privAverageBytesPerMs !== 0 ? i / this.privAverageBytesPerMs : 0;
      this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(c);
    }
    sendSpeechContext(i, c) {
      this.privEnableSpeakerId && this.updateSpeakerDiarizationAudioOffset();
      const u = this.speechContext.toJSON();
      if (c && this.privRequestSession.onSpeechContext(), u)
        return i.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", u));
    }
    noOp() {
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendPrePayloadJSON(i, c = !0) {
      if (this.sendPrePayloadJSONOverride !== void 0)
        return this.sendPrePayloadJSONOverride(i);
      await this.sendSpeechContext(i, c), await this.sendWaveHeader(i);
    }
    async sendWaveHeader(i) {
      const c = await this.audioSource.format;
      return i.send(new s.SpeechConnectionMessage(e.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", c.header));
    }
    // Establishes a websocket connection to the end point.
    connectImpl() {
      return this.privConnectionPromise !== void 0 ? this.privConnectionPromise.then((i) => i.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl())) : (this.privConnectionPromise = this.retryableConnect(), this.privConnectionPromise.catch(() => {
      }), this.postConnectImplOverride !== void 0 ? this.postConnectImplOverride(this.privConnectionPromise) : this.privConnectionPromise);
    }
    sendSpeechServiceConfig(i, c, u) {
      if (c.onSpeechContext(), Qi.telemetryDataEnabled !== !0) {
        const d = {
          context: {
            system: JSON.parse(u).context.system
          }
        };
        u = JSON.stringify(d);
      }
      if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
        const p = JSON.parse(u);
        p.context.DisableReferenceChannel = "True", p.context.MicSpec = "1_0_0", u = JSON.stringify(p);
      }
      if (u)
        return i.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speech.config", c.requestId, "application/json", u));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((i) => i.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    async sendAudio(i) {
      const c = await this.audioSource.format;
      this.privAverageBytesPerMs = c.avgBytesPerSec / 1e3;
      let u = Date.now();
      const p = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000"), d = c.avgBytesPerSec / 1e3 * parseInt(p, 10), l = this.privRequestSession.recogNumber, h = async () => {
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === l) {
          const v = await this.fetchConnection(), g = await i.read();
          if (this.privRequestSession.isSpeechEnded)
            return;
          let f, m;
          if (!g || g.isEnd ? (f = null, m = 0) : (f = g.buffer, this.privRequestSession.onAudioSent(f.byteLength), d >= this.privRequestSession.bytesSent ? m = 0 : m = Math.max(0, u - Date.now())), m !== 0 && await this.delay(m), f !== null && (u = Date.now() + f.byteLength * 1e3 / (c.avgBytesPerSec * 2)), !this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === l)
            if (v.send(new s.SpeechConnectionMessage(e.MessageType.Binary, "audio", this.privRequestSession.requestId, null, f)).catch(() => {
              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {
              });
            }), g != null && g.isEnd)
              this.privIsLiveAudio || this.privRequestSession.onSpeechEnded();
            else
              return h();
        }
      };
      return h();
    }
    async retryableConnect() {
      let i = !1;
      this.privAuthFetchEventId = e.createNoDashGuid();
      const c = this.privRequestSession.sessionId;
      this.privConnectionId = c !== void 0 ? c : e.createNoDashGuid(), this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
      let u = 0, p = "";
      for (; this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount; ) {
        const l = await (i ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId));
        await this.privRequestSession.onAuthCompleted(!1);
        const h = this.privConnectionFactory.create(this.privRecognizerConfig, l, this.privConnectionId);
        this.privRequestSession.listenForServiceTelemetry(h.events), h.events.attach((g) => {
          this.connectionEvents.onEvent(g);
        });
        const v = await h.open();
        if (v.statusCode === 200)
          return await this.privRequestSession.onConnectionEstablishCompleted(v.statusCode), Promise.resolve(h);
        v.statusCode === 1006 && (i = !0), u = v.statusCode, p = v.reason, this.privRequestSession.onRetryConnection();
      }
      return await this.privRequestSession.onConnectionEstablishCompleted(u, p), Promise.reject(`Unable to contact server. StatusCode: ${u}, ${this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${p}`);
    }
    delay(i) {
      return new Promise((c) => this.privSetTimeout(c, i));
    }
    writeBufferToConsole(i) {
      let c = "Buffer Size: ";
      if (i === null)
        c += "null";
      else {
        const u = new Uint8Array(i);
        c += `${i.byteLength}\r
`;
        for (let p = 0; p < i.byteLength; p++)
          c += u[p].toString(16).padStart(2, "0") + " ", (p + 1) % 16 === 0 && (console.info(c), c = "");
      }
      console.info(c);
    }
    async sendFinalAudio() {
      await (await this.fetchConnection()).send(new s.SpeechConnectionMessage(e.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const i = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(i) : (await this.sendSpeechServiceConfig(i, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendPrePayloadJSON(i, !1), i);
    }
  };
  return yi.ServiceRecognizerBase = o, o.telemetryDataEnabled = !0, yi;
}
var Ci = {}, pl;
function SR() {
  if (pl)
    return Ci;
  pl = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.ConversationServiceRecognizer = void 0;
  const t = P(), e = b();
  let n = class extends e.ServiceRecognizerBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, i, c), this.handleSpeechPhraseMessage = async (u) => this.handleSpeechPhrase(u), this.handleSpeechHypothesisMessage = (u) => this.handleSpeechHypothesis(u);
    }
    processTypeSpecificMessages(s) {
    }
    handleRecognizedCallback(s, o, a) {
    }
    handleRecognizingCallback(s, o, a) {
    }
    async processSpeechMessages(s) {
      let o = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          this.handleSpeechHypothesisMessage && this.handleSpeechHypothesisMessage(s.textBody), o = !0;
          break;
        case "speech.phrase":
          this.handleSpeechPhraseMessage && await this.handleSpeechPhraseMessage(s.textBody), o = !0;
          break;
      }
      return o;
    }
    cancelRecognition(s, o, a, i, c) {
    }
    async handleSpeechPhrase(s) {
      const o = e.SimpleSpeechPhrase.fromJSON(s, this.privRequestSession.currentTurnAudioOffset), a = e.EnumTranslation.implTranslateRecognitionResult(o.RecognitionStatus);
      let i;
      const c = new t.PropertyCollection();
      if (c.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, s), this.privRequestSession.onPhraseRecognized(o.Offset + o.Duration), t.ResultReason.Canceled === a) {
        const u = e.EnumTranslation.implTranslateCancelResult(o.RecognitionStatus), p = e.EnumTranslation.implTranslateCancelErrorCode(o.RecognitionStatus);
        await this.cancelRecognitionLocal(u, p, e.EnumTranslation.implTranslateErrorDetails(p));
      } else if (o.RecognitionStatus !== e.RecognitionStatus.EndOfDictation) {
        if (this.privRecognizerConfig.parameters.getProperty(e.OutputFormatPropertyName) === t.OutputFormat[t.OutputFormat.Simple])
          i = new t.SpeechRecognitionResult(this.privRequestSession.requestId, a, o.DisplayText, o.Duration, o.Offset, o.Language, o.LanguageDetectionConfidence, o.SpeakerId, void 0, o.asJson(), c);
        else {
          const u = e.DetailedSpeechPhrase.fromJSON(s, this.privRequestSession.currentTurnAudioOffset);
          i = new t.SpeechRecognitionResult(this.privRequestSession.requestId, a, u.Text, u.Duration, u.Offset, u.Language, u.LanguageDetectionConfidence, u.SpeakerId, void 0, u.asJson(), c);
        }
        this.handleRecognizedCallback(i, i.offset, this.privRequestSession.sessionId);
      }
    }
    handleSpeechHypothesis(s) {
      const o = e.SpeechHypothesis.fromJSON(s, this.privRequestSession.currentTurnAudioOffset), a = new t.PropertyCollection();
      a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, s);
      const i = new t.SpeechRecognitionResult(this.privRequestSession.requestId, t.ResultReason.RecognizingSpeech, o.Text, o.Duration, o.Offset, o.Language, o.LanguageDetectionConfidence, o.SpeakerId, void 0, o.asJson(), a);
      this.privRequestSession.onHypothesis(o.Offset), this.handleRecognizingCallback(i, o.Duration, this.privRequestSession.sessionId);
    }
  };
  return Ci.ConversationServiceRecognizer = n, Ci;
}
var gc = {}, dl;
function yR() {
  return dl || (dl = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.RecognizerConfig = t.SpeechResultFormat = t.RecognitionMode = void 0;
    const e = P(), n = b();
    var r;
    (function(o) {
      o[o.Interactive = 0] = "Interactive", o[o.Conversation = 1] = "Conversation", o[o.Dictation = 2] = "Dictation";
    })(r = t.RecognitionMode || (t.RecognitionMode = {})), function(o) {
      o[o.Simple = 0] = "Simple", o[o.Detailed = 1] = "Detailed";
    }(t.SpeechResultFormat || (t.SpeechResultFormat = {}));
    class s {
      constructor(a, i) {
        this.privSpeechServiceConfig = a || new n.SpeechServiceConfig(new n.Context(null)), this.privParameters = i, this.privMaxRetryCount = parseInt(i.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10), this.privLanguageIdMode = i.getProperty(e.PropertyId.SpeechServiceConnection_LanguageIdMode, void 0), this.privEnableSpeakerId = !1;
      }
      get parameters() {
        return this.privParameters;
      }
      get recognitionMode() {
        return this.privRecognitionMode;
      }
      set recognitionMode(a) {
        this.privRecognitionMode = a, this.privRecognitionActivityTimeout = a === r.Interactive ? 8e3 : 25e3, this.privSpeechServiceConfig.Recognition = r[a];
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
      get recognitionActivityTimeout() {
        return this.privRecognitionActivityTimeout;
      }
      get isContinuousRecognition() {
        return this.privRecognitionMode !== r.Interactive;
      }
      get languageIdMode() {
        return this.privLanguageIdMode;
      }
      get autoDetectSourceLanguages() {
        return this.parameters.getProperty(e.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
      }
      get recognitionEndpointVersion() {
        return this.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, void 0);
      }
      get sourceLanguageModels() {
        const a = [];
        let i = !1;
        if (this.autoDetectSourceLanguages !== void 0)
          for (const c of this.autoDetectSourceLanguages.split(",")) {
            const u = c + e.PropertyId.SpeechServiceConnection_EndpointId.toString(), p = this.parameters.getProperty(u, void 0);
            p !== void 0 ? (a.push({ language: c, endpoint: p }), i = !0) : a.push({ language: c, endpoint: "" });
          }
        return i ? a : void 0;
      }
      get maxRetryCount() {
        return this.privMaxRetryCount;
      }
      get isSpeakerDiarizationEnabled() {
        return this.privEnableSpeakerId;
      }
      set isSpeakerDiarizationEnabled(a) {
        this.privEnableSpeakerId = a;
      }
    }
    t.RecognizerConfig = s;
  }(gc)), gc;
}
var Kf = {};
Object.defineProperty(Kf, "__esModule", { value: !0 });
var ya = {};
Object.defineProperty(ya, "__esModule", { value: !0 });
ya.WebsocketMessageFormatter = void 0;
const Ge = O(), ll = `\r
`;
class CR {
  toConnectionMessage(e) {
    const n = new Ge.Deferred();
    try {
      if (e.messageType === Ge.MessageType.Text) {
        const r = e.textContent;
        let s = {}, o = null;
        if (r) {
          const a = r.split(`\r
\r
`);
          a && a.length > 0 && (s = this.parseHeaders(a[0]), a.length > 1 && (o = a[1]));
        }
        n.resolve(new Ge.ConnectionMessage(e.messageType, o, s, e.id));
      } else if (e.messageType === Ge.MessageType.Binary) {
        const r = e.binaryContent;
        let s = {}, o = null;
        if (!r || r.byteLength < 2)
          throw new Error("Invalid binary message format. Header length missing.");
        const a = new DataView(r), i = a.getInt16(0);
        if (r.byteLength < i + 2)
          throw new Error("Invalid binary message format. Header content missing.");
        let c = "";
        for (let u = 0; u < i; u++)
          c += String.fromCharCode(a.getInt8(u + 2));
        s = this.parseHeaders(c), r.byteLength > i + 2 && (o = r.slice(2 + i)), n.resolve(new Ge.ConnectionMessage(e.messageType, o, s, e.id));
      }
    } catch (r) {
      n.reject(`Error formatting the message. Error: ${r}`);
    }
    return n.promise;
  }
  fromConnectionMessage(e) {
    const n = new Ge.Deferred();
    try {
      if (e.messageType === Ge.MessageType.Text) {
        const r = `${this.makeHeaders(e)}${ll}${e.textBody ? e.textBody : ""}`;
        n.resolve(new Ge.RawWebsocketMessage(Ge.MessageType.Text, r, e.id));
      } else if (e.messageType === Ge.MessageType.Binary) {
        const r = this.makeHeaders(e), s = e.binaryBody, o = this.stringToArrayBuffer(r), a = new Int8Array(o), i = a.byteLength, c = new Int8Array(2 + i + (s ? s.byteLength : 0));
        if (c[0] = i >> 8 & 255, c[1] = i & 255, c.set(a, 2), s) {
          const p = new Int8Array(s);
          c.set(p, 2 + i);
        }
        const u = c.buffer;
        n.resolve(new Ge.RawWebsocketMessage(Ge.MessageType.Binary, u, e.id));
      }
    } catch (r) {
      n.reject(`Error formatting the message. ${r}`);
    }
    return n.promise;
  }
  makeHeaders(e) {
    let n = "";
    if (e.headers)
      for (const r in e.headers)
        r && (n += `${r}: ${e.headers[r]}${ll}`);
    return n;
  }
  parseHeaders(e) {
    const n = {};
    if (e) {
      const r = e.match(/[^\r\n]+/g);
      if (n) {
        for (const s of r)
          if (s) {
            const o = s.indexOf(":"), a = o > 0 ? s.substr(0, o).trim().toLowerCase() : s, i = o > 0 && s.length > o + 1 ? s.substr(o + 1).trim() : "";
            n[a] = i;
          }
      }
    }
    return n;
  }
  stringToArrayBuffer(e) {
    const n = new ArrayBuffer(e.length), r = new DataView(n);
    for (let s = 0; s < e.length; s++)
      r.setUint8(s, e.charCodeAt(s));
    return n;
  }
}
ya.WebsocketMessageFormatter = CR;
var _i = {}, hl;
function _R() {
  if (hl)
    return _i;
  hl = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.SpeechConnectionFactory = void 0;
  const t = Se(), e = b(), n = P(), r = ot(), s = b(), o = me, a = st;
  let i = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1", this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1", this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1", this.universalUri = "/speech/universal/v";
    }
    create(u, p, d) {
      let l = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Region, void 0), v = r.ConnectionFactoryBase.getHostSuffix(h), g = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, "wss://" + h + ".stt.speech" + v), f = {}, m = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (m ? (!l || l.search(a.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (f[a.QueryParameterNames.CustomSpeechDeploymentId] = m) : S && (!l || l.search(a.QueryParameterNames.Language) === -1) && (f[a.QueryParameterNames.Language] = S), (!l || l.search(a.QueryParameterNames.Format) === -1) && (f[a.QueryParameterNames.Format] = u.parameters.getProperty(e.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Simple]).toLowerCase()), u.autoDetectSourceLanguages !== void 0 && (f[a.QueryParameterNames.EnableLanguageId] = "true"), this.setCommonUrlParams(u, f, l), !l)
        switch (u.recognitionMode) {
          case s.RecognitionMode.Conversation:
            u.parameters.getProperty(e.ForceDictationPropertyName, "false") === "true" ? l = g + this.dictationRelativeUri : u.recognitionEndpointVersion !== void 0 && parseInt(u.recognitionEndpointVersion, 10) > 1 ? l = `${g}${this.universalUri}${u.recognitionEndpointVersion}` : l = g + this.conversationRelativeUri;
            break;
          case s.RecognitionMode.Dictation:
            l = g + this.dictationRelativeUri;
            break;
          default:
            u.recognitionEndpointVersion !== void 0 && parseInt(u.recognitionEndpointVersion, 10) > 1 ? l = `${g}${this.universalUri}${u.recognitionEndpointVersion}` : l = g + this.interactiveRelativeUri;
            break;
        }
      const y = {};
      p.token !== void 0 && p.token !== "" && (y[p.headerName] = p.token), y[o.HeaderNames.ConnectionId] = d;
      const E = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", _ = new t.WebsocketConnection(l, f, y, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), E, d), C = _.uri;
      return u.parameters.setProperty(n.PropertyId.SpeechServiceConnection_Url, C), _;
    }
  };
  return _i.SpeechConnectionFactory = i, _i;
}
var Ri = {}, vl;
function RR() {
  if (vl)
    return Ri;
  vl = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.ConversationTranscriberConnectionFactory = void 0;
  const t = Se(), e = P(), n = b(), r = ot(), s = b(), o = me, a = st;
  let i = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/speech/universal/v2";
    }
    create(u, p, d) {
      let l = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, void 0), v = r.ConnectionFactoryBase.getHostSuffix(h), g = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, "wss://" + h + ".stt.speech" + v), f = {}, m = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      m ? (!l || l.search(a.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (f[a.QueryParameterNames.CustomSpeechDeploymentId] = m) : S && (!l || l.search(a.QueryParameterNames.Language) === -1) && (f[a.QueryParameterNames.Language] = S), u.autoDetectSourceLanguages !== void 0 && (f[a.QueryParameterNames.EnableLanguageId] = "true"), this.setV2UrlParams(u, f, l), l || (l = `${g}${this.universalUri}`);
      const y = {};
      p.token !== void 0 && p.token !== "" && (y[p.headerName] = p.token), y[o.HeaderNames.ConnectionId] = d;
      const E = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", _ = new t.WebsocketConnection(l, f, y, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), E, d), C = _.uri;
      return u.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, C), _;
    }
    setV2UrlParams(u, p, d) {
      (/* @__PURE__ */ new Map([
        [e.PropertyId.Speech_SegmentationSilenceTimeoutMs, a.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_EnableAudioLogging, a.QueryParameterNames.EnableAudioLogging],
        [e.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, a.QueryParameterNames.EndSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, a.QueryParameterNames.InitialSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceResponse_PostProcessingOption, a.QueryParameterNames.Postprocessing],
        [e.PropertyId.SpeechServiceResponse_ProfanityOption, a.QueryParameterNames.Profanity],
        [e.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, a.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((v, g) => {
        this.setUrlParameter(g, v, u, p, d);
      });
      const h = JSON.parse(u.parameters.getProperty(n.ServicePropertiesPropertyName, "{}"));
      Object.keys(h).forEach((v) => {
        p[v] = h[v];
      });
    }
  };
  return Ri.ConversationTranscriberConnectionFactory = i, Ri;
}
var Pi = {}, fl;
function PR() {
  if (fl)
    return Pi;
  fl = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.TranscriberConnectionFactory = void 0;
  const t = Se(), e = P(), n = ot(), r = b(), s = me, o = st;
  let a = class extends n.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
    }
    create(c, u, p) {
      let d = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const l = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, "centralus"), h = n.ConnectionFactoryBase.getHostSuffix(l), v = "wss://transcribe." + l + ".cts.speech" + h + this.multiaudioRelativeUri, g = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, v), f = {};
      this.setQueryParams(f, c, d), d || (d = g);
      const m = {};
      u.token !== void 0 && u.token !== "" && (m[u.headerName] = u.token), m[s.HeaderNames.ConnectionId] = p, c.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, d);
      const S = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(d, f, m, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(c), S, p);
    }
    setQueryParams(c, u, p) {
      const d = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_EndpointId, void 0), l = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      d && !(o.QueryParameterNames.CustomSpeechDeploymentId in c) && (c[o.QueryParameterNames.CustomSpeechDeploymentId] = d), l && !(o.QueryParameterNames.Language in c) && (c[o.QueryParameterNames.Language] = l);
      const h = u.parameters.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true", v = u.parameters.getProperty(r.OutputFormatPropertyName, e.OutputFormat[e.OutputFormat.Simple]) !== e.OutputFormat[e.OutputFormat.Simple];
      (h || v) && (c[o.QueryParameterNames.Format] = e.OutputFormat[e.OutputFormat.Detailed].toLowerCase()), this.setCommonUrlParams(u, c, p);
    }
  };
  return Pi.TranscriberConnectionFactory = a, Pi;
}
var Ei = {}, gl;
function ER() {
  if (gl)
    return Ei;
  gl = 1, Object.defineProperty(Ei, "__esModule", { value: !0 }), Ei.TranslationConnectionFactory = void 0;
  const t = Se(), e = Cs, n = P(), r = ot(), s = b(), o = me, a = st;
  let i = class extends r.ConnectionFactoryBase {
    create(u, p, d) {
      const l = this.getEndpointUrl(u), h = {};
      u.autoDetectSourceLanguages !== void 0 && (h[a.QueryParameterNames.EnableLanguageId] = "true"), this.setQueryParams(h, u, l);
      const v = {};
      p.token !== void 0 && p.token !== "" && (v[p.headerName] = p.token), v[o.HeaderNames.ConnectionId] = d, u.parameters.setProperty(n.PropertyId.SpeechServiceConnection_Url, l);
      const g = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(l, h, v, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), g, d);
    }
    getEndpointUrl(u, p) {
      const d = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Region), l = r.ConnectionFactoryBase.getHostSuffix(d);
      let h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      return h || (u.autoDetectSourceLanguages !== void 0 ? h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + l) + "/speech/universal/v2" : h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + l) + "/speech/translation/cognitiveservices/v1"), p === !0 ? h : e.StringUtils.formatString(h, { region: d });
    }
    setQueryParams(u, p, d) {
      u.from = p.parameters.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage), u.to = p.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages), u.scenario = p.recognitionMode === s.RecognitionMode.Interactive ? "interactive" : p.recognitionMode === s.RecognitionMode.Conversation ? "conversation" : "", this.setCommonUrlParams(p, u, d), this.setUrlParameter(n.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, a.QueryParameterNames.StableTranslation, p, u, d);
      const l = p.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
      l !== void 0 && (u.voice = l, u.features = "texttospeech");
    }
  };
  return Ei.TranslationConnectionFactory = i, Ei;
}
var Ti = {}, ml;
function TR() {
  if (ml)
    return Ti;
  ml = 1, Object.defineProperty(Ti, "__esModule", { value: !0 }), Ti.EnumTranslation = void 0;
  const t = P(), e = b();
  let n = class {
    static implTranslateRecognitionResult(s, o = !1) {
      let a = t.ResultReason.Canceled;
      switch (s) {
        case e.RecognitionStatus.Success:
          a = t.ResultReason.RecognizedSpeech;
          break;
        case e.RecognitionStatus.EndOfDictation:
          a = o ? t.ResultReason.RecognizedSpeech : t.ResultReason.NoMatch;
          break;
        case e.RecognitionStatus.NoMatch:
        case e.RecognitionStatus.InitialSilenceTimeout:
        case e.RecognitionStatus.BabbleTimeout:
          a = t.ResultReason.NoMatch;
          break;
        case e.RecognitionStatus.Error:
        case e.RecognitionStatus.BadRequest:
        case e.RecognitionStatus.Forbidden:
        default:
          a = t.ResultReason.Canceled;
          break;
      }
      return a;
    }
    static implTranslateCancelResult(s) {
      let o = t.CancellationReason.EndOfStream;
      switch (s) {
        case e.RecognitionStatus.Success:
        case e.RecognitionStatus.EndOfDictation:
        case e.RecognitionStatus.NoMatch:
          o = t.CancellationReason.EndOfStream;
          break;
        case e.RecognitionStatus.InitialSilenceTimeout:
        case e.RecognitionStatus.BabbleTimeout:
        case e.RecognitionStatus.Error:
        case e.RecognitionStatus.BadRequest:
        case e.RecognitionStatus.Forbidden:
        default:
          o = t.CancellationReason.Error;
          break;
      }
      return o;
    }
    static implTranslateCancelErrorCode(s) {
      let o = t.CancellationErrorCode.NoError;
      switch (s) {
        case e.RecognitionStatus.Error:
          o = t.CancellationErrorCode.ServiceError;
          break;
        case e.RecognitionStatus.TooManyRequests:
          o = t.CancellationErrorCode.TooManyRequests;
          break;
        case e.RecognitionStatus.BadRequest:
          o = t.CancellationErrorCode.BadRequestParameters;
          break;
        case e.RecognitionStatus.Forbidden:
          o = t.CancellationErrorCode.Forbidden;
          break;
        default:
          o = t.CancellationErrorCode.NoError;
          break;
      }
      return o;
    }
    static implTranslateErrorDetails(s) {
      let o = "The speech service encountered an internal error and could not continue.";
      switch (s) {
        case t.CancellationErrorCode.Forbidden:
          o = "The recognizer is using a free subscription that ran out of quota.";
          break;
        case t.CancellationErrorCode.BadRequestParameters:
          o = "Invalid parameter or unsupported audio format in the request.";
          break;
        case t.CancellationErrorCode.TooManyRequests:
          o = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
          break;
      }
      return o;
    }
  };
  return Ti.EnumTranslation = n, Ti;
}
var Jf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.RecognitionStatus = t.SynthesisStatus = void 0, function(e) {
    e[e.Success = 0] = "Success", e[e.SynthesisEnd = 1] = "SynthesisEnd", e[e.Error = 2] = "Error";
  }(t.SynthesisStatus || (t.SynthesisStatus = {})), function(e) {
    e[e.Success = 0] = "Success", e[e.NoMatch = 1] = "NoMatch", e[e.InitialSilenceTimeout = 2] = "InitialSilenceTimeout", e[e.BabbleTimeout = 3] = "BabbleTimeout", e[e.Error = 4] = "Error", e[e.EndOfDictation = 5] = "EndOfDictation", e[e.TooManyRequests = 6] = "TooManyRequests", e[e.BadRequest = 7] = "BadRequest", e[e.Forbidden = 8] = "Forbidden";
  }(t.RecognitionStatus || (t.RecognitionStatus = {}));
})(Jf);
var wi = {}, Sl;
function wR() {
  if (Sl)
    return wi;
  Sl = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.TranslationSynthesisEnd = void 0;
  const t = b();
  let e = class Gf {
    constructor(r) {
      this.privSynthesisEnd = JSON.parse(r), this.privSynthesisEnd.SynthesisStatus && (this.privSynthesisEnd.SynthesisStatus = t.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus]), this.privSynthesisEnd.Status && (this.privSynthesisEnd.SynthesisStatus = t.SynthesisStatus[this.privSynthesisEnd.Status]);
    }
    static fromJSON(r) {
      return new Gf(r);
    }
    get SynthesisStatus() {
      return this.privSynthesisEnd.SynthesisStatus;
    }
    get FailureReason() {
      return this.privSynthesisEnd.FailureReason;
    }
  };
  return wi.TranslationSynthesisEnd = e, wi;
}
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.TranslationHypothesis = void 0;
const IR = D, yl = $o;
class lo {
  constructor(e, n) {
    this.privTranslationHypothesis = e, this.privTranslationHypothesis.Offset += n, this.privTranslationHypothesis.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationHypothesis.Translation.TranslationStatus);
  }
  static fromJSON(e, n) {
    return new lo(JSON.parse(e), n);
  }
  static fromTranslationResponse(e, n) {
    IR.Contracts.throwIfNullOrUndefined(e, "translationHypothesis");
    const r = e.SpeechHypothesis;
    return e.SpeechHypothesis = void 0, r.Translation = e, new lo(r, n);
  }
  get Duration() {
    return this.privTranslationHypothesis.Duration;
  }
  get Offset() {
    return this.privTranslationHypothesis.Offset;
  }
  get Text() {
    return this.privTranslationHypothesis.Text;
  }
  get Translation() {
    return this.privTranslationHypothesis.Translation;
  }
  get Language() {
    var e;
    return (e = this.privTranslationHypothesis.PrimaryLanguage) == null ? void 0 : e.Language;
  }
  asJson() {
    const e = { ...this.privTranslationHypothesis };
    return e.Translation !== void 0 ? JSON.stringify({
      ...e,
      TranslationStatus: yl.TranslationStatus[e.Translation.TranslationStatus]
    }) : JSON.stringify(e);
  }
  mapTranslationStatus(e) {
    if (typeof e == "string")
      return yl.TranslationStatus[e];
    if (typeof e == "number")
      return e;
  }
}
Ca.TranslationHypothesis = lo;
var Ii = {}, Cl;
function bR() {
  if (Cl)
    return Ii;
  Cl = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.TranslationPhrase = void 0;
  const t = D, e = b(), n = $o;
  let r = class qc {
    constructor(o, a) {
      this.privTranslationPhrase = o, this.privTranslationPhrase.Offset += a, this.privTranslationPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privTranslationPhrase.RecognitionStatus), this.privTranslationPhrase.Translation !== void 0 && (this.privTranslationPhrase.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationPhrase.Translation.TranslationStatus));
    }
    static fromJSON(o, a) {
      return new qc(JSON.parse(o), a);
    }
    static fromTranslationResponse(o, a) {
      t.Contracts.throwIfNullOrUndefined(o, "translationResponse");
      const i = o.SpeechPhrase;
      return o.SpeechPhrase = void 0, i.Translation = o, i.Text = i.DisplayText, new qc(i, a);
    }
    get RecognitionStatus() {
      return this.privTranslationPhrase.RecognitionStatus;
    }
    get Offset() {
      return this.privTranslationPhrase.Offset;
    }
    get Duration() {
      return this.privTranslationPhrase.Duration;
    }
    get Text() {
      return this.privTranslationPhrase.Text;
    }
    get Language() {
      var o;
      return (o = this.privTranslationPhrase.PrimaryLanguage) == null ? void 0 : o.Language;
    }
    get Confidence() {
      var o;
      return (o = this.privTranslationPhrase.PrimaryLanguage) == null ? void 0 : o.Confidence;
    }
    get Translation() {
      return this.privTranslationPhrase.Translation;
    }
    asJson() {
      const o = { ...this.privTranslationPhrase }, a = {
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      };
      return o.Translation && (a.Translation = {
        ...o.Translation,
        TranslationStatus: n.TranslationStatus[o.Translation.TranslationStatus]
      }), JSON.stringify(a);
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
    mapTranslationStatus(o) {
      if (typeof o == "string")
        return n.TranslationStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return Ii.TranslationPhrase = r, Ii;
}
var bi = {}, _l;
function AR() {
  if (_l)
    return bi;
  _l = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.TranslationServiceRecognizer = void 0;
  const t = O(), e = P(), n = b();
  let r = class extends n.ConversationServiceRecognizer {
    constructor(o, a, i, c, u) {
      super(o, a, i, c, u), this.privTranslationRecognizer = u, this.connectionEvents.attach((p) => {
        p.name === "ConnectionEstablishedEvent" && this.privTranslationRecognizer.onConnection();
      });
    }
    async processTypeSpecificMessages(o) {
      const a = new e.PropertyCollection();
      let i = await this.processSpeechMessages(o);
      if (i)
        return !0;
      const c = async (p) => {
        if (a.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, p.asJson()), this.privRequestSession.onPhraseRecognized(p.Offset + p.Duration), p.RecognitionStatus === n.RecognitionStatus.Success) {
          const d = this.fireEventForResult(p, a);
          if (this.privTranslationRecognizer.recognized)
            try {
              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, d);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(d.result);
            } catch (l) {
              this.privErrorCallback && this.privErrorCallback(l);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
        } else {
          const d = n.EnumTranslation.implTranslateRecognitionResult(p.RecognitionStatus), l = new e.TranslationRecognitionResult(void 0, this.privRequestSession.requestId, d, p.Text, p.Duration, p.Offset, p.Language, p.Confidence, void 0, p.asJson(), a);
          if (d === e.ResultReason.Canceled) {
            const h = n.EnumTranslation.implTranslateCancelResult(p.RecognitionStatus), v = n.EnumTranslation.implTranslateCancelErrorCode(p.RecognitionStatus);
            await this.cancelRecognitionLocal(h, v, n.EnumTranslation.implTranslateErrorDetails(v));
          } else if (p.RecognitionStatus !== n.RecognitionStatus.EndOfDictation) {
            const h = new e.TranslationRecognitionEventArgs(l, l.offset, this.privRequestSession.sessionId);
            if (this.privTranslationRecognizer.recognized)
              try {
                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, h);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(l);
              } catch (v) {
                this.privErrorCallback && this.privErrorCallback(v);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          i = !0;
        }
      }, u = (p) => {
        a.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, p.asJson());
        const d = this.fireEventForResult(p, a);
        if (this.privRequestSession.onHypothesis(d.offset), this.privTranslationRecognizer.recognizing)
          try {
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, d);
          } catch {
          }
        i = !0;
      };
      switch (o.messageType === t.MessageType.Text && a.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, o.textBody), o.path.toLowerCase()) {
        case "translation.hypothesis":
          u(n.TranslationHypothesis.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.response":
          const p = JSON.parse(o.textBody);
          if (p.SpeechPhrase)
            await c(n.TranslationPhrase.fromTranslationResponse(p, this.privRequestSession.currentTurnAudioOffset));
          else {
            const l = JSON.parse(o.textBody);
            l.SpeechHypothesis && u(n.TranslationHypothesis.fromTranslationResponse(l, this.privRequestSession.currentTurnAudioOffset));
          }
          break;
        case "translation.phrase":
          await c(n.TranslationPhrase.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.synthesis":
          this.sendSynthesisAudio(o.binaryBody, this.privRequestSession.sessionId), i = !0;
          break;
        case "audio.end":
        case "translation.synthesis.end":
          const d = n.TranslationSynthesisEnd.fromJSON(o.textBody);
          switch (d.SynthesisStatus) {
            case n.SynthesisStatus.Error:
              if (this.privTranslationRecognizer.synthesizing) {
                const l = new e.TranslationSynthesisResult(e.ResultReason.Canceled, void 0), h = new e.TranslationSynthesisEventArgs(l, this.privRequestSession.sessionId);
                try {
                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, h);
                } catch {
                }
              }
              if (this.privTranslationRecognizer.canceled) {
                const l = new e.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, e.CancellationReason.Error, d.FailureReason, e.CancellationErrorCode.ServiceError, null);
                try {
                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, l);
                } catch {
                }
              }
              break;
            case n.SynthesisStatus.Success:
              this.sendSynthesisAudio(void 0, this.privRequestSession.sessionId);
              break;
          }
          i = !0;
          break;
      }
      return i;
    }
    // Cancels recognition.
    cancelRecognition(o, a, i, c, u) {
      const p = new e.PropertyCollection();
      if (p.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[c]), this.privTranslationRecognizer.canceled) {
        const d = new e.TranslationRecognitionCanceledEventArgs(o, i, u, c, void 0);
        try {
          this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, d);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const d = new e.TranslationRecognitionResult(
          void 0,
          // Translations
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Druation
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(d), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    handleRecognizingCallback(o, a, i) {
      try {
        const c = new e.TranslationRecognitionEventArgs(e.TranslationRecognitionResult.fromSpeechRecognitionResult(o), a, i);
        this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    handleRecognizedCallback(o, a, i) {
      try {
        const c = new e.TranslationRecognitionEventArgs(e.TranslationRecognitionResult.fromSpeechRecognitionResult(o), a, i);
        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    fireEventForResult(o, a) {
      let i;
      if (o.Translation.Translations !== void 0) {
        i = new e.Translations();
        for (const h of o.Translation.Translations)
          i.set(h.Language, h.Text || h.DisplayText);
      }
      let c, u;
      o instanceof n.TranslationPhrase ? (o.Translation && o.Translation.TranslationStatus === t.TranslationStatus.Success ? c = e.ResultReason.TranslatedSpeech : c = e.ResultReason.RecognizedSpeech, u = o.Confidence) : c = e.ResultReason.TranslatingSpeech;
      const p = o.Language, d = new e.TranslationRecognitionResult(i, this.privRequestSession.requestId, c, o.Text, o.Duration, o.Offset, p, u, o.Translation.FailureReason, o.asJson(), a);
      return new e.TranslationRecognitionEventArgs(d, o.Offset, this.privRequestSession.sessionId);
    }
    sendSynthesisAudio(o, a) {
      const i = o === void 0 ? e.ResultReason.SynthesizingAudioCompleted : e.ResultReason.SynthesizingAudio, c = new e.TranslationSynthesisResult(i, o), u = new e.TranslationSynthesisEventArgs(c, a);
      if (this.privTranslationRecognizer.synthesizing)
        try {
          this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, u);
        } catch {
        }
    }
  };
  return bi.TranslationServiceRecognizer = r, bi;
}
var _a = {};
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.SpeechDetected = void 0;
class Du {
  constructor(e, n) {
    this.privSpeechStartDetected = JSON.parse(e), this.privSpeechStartDetected.Offset += n;
  }
  static fromJSON(e, n) {
    return new Du(e, n);
  }
  get Offset() {
    return this.privSpeechStartDetected.Offset;
  }
}
_a.SpeechDetected = Du;
var Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.SpeechHypothesis = void 0;
class Nu {
  constructor(e, n) {
    this.privSpeechHypothesis = JSON.parse(e), this.updateOffset(n);
  }
  static fromJSON(e, n) {
    return new Nu(e, n);
  }
  updateOffset(e) {
    this.privSpeechHypothesis.Offset += e;
  }
  asJson() {
    return JSON.stringify(this.privSpeechHypothesis);
  }
  get Text() {
    return this.privSpeechHypothesis.Text;
  }
  get Offset() {
    return this.privSpeechHypothesis.Offset;
  }
  get Duration() {
    return this.privSpeechHypothesis.Duration;
  }
  get Language() {
    return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
  }
  get LanguageDetectionConfidence() {
    return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
  }
  get SpeakerId() {
    return this.privSpeechHypothesis.SpeakerId;
  }
}
Ra.SpeechHypothesis = Nu;
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.SpeechKeyword = void 0;
class Lu {
  constructor(e, n) {
    this.privSpeechKeyword = JSON.parse(e), this.privSpeechKeyword.Offset += n;
  }
  static fromJSON(e, n) {
    return new Lu(e, n);
  }
  get Status() {
    return this.privSpeechKeyword.Status;
  }
  get Text() {
    return this.privSpeechKeyword.Text;
  }
  get Offset() {
    return this.privSpeechKeyword.Offset;
  }
  get Duration() {
    return this.privSpeechKeyword.Duration;
  }
  asJson() {
    return JSON.stringify(this.privSpeechKeyword);
  }
}
Pa.SpeechKeyword = Lu;
var Ai = {}, Rl;
function MR() {
  if (Rl)
    return Ai;
  Rl = 1, Object.defineProperty(Ai, "__esModule", { value: !0 }), Ai.SpeechServiceRecognizer = void 0;
  const t = P(), e = b();
  let n = class extends e.ServiceRecognizerBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, i, c), this.privSpeechRecognizer = c;
    }
    async processTypeSpecificMessages(s) {
      let o;
      const a = new t.PropertyCollection();
      let i = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = e.SpeechHypothesis.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, c.asJson()), o = new t.SpeechRecognitionResult(
            this.privRequestSession.requestId,
            t.ResultReason.RecognizingSpeech,
            c.Text,
            c.Duration,
            c.Offset,
            c.Language,
            c.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            c.asJson(),
            a
          ), this.privRequestSession.onHypothesis(c.Offset);
          const u = new t.SpeechRecognitionEventArgs(o, c.Offset, this.privRequestSession.sessionId);
          if (this.privSpeechRecognizer.recognizing)
            try {
              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, u);
            } catch {
            }
          i = !0;
          break;
        case "speech.phrase":
          const p = e.SimpleSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, p.asJson());
          const d = e.EnumTranslation.implTranslateRecognitionResult(p.RecognitionStatus, this.privExpectContentAssessmentResponse);
          if (this.privRequestSession.onPhraseRecognized(p.Offset + p.Duration), t.ResultReason.Canceled === d) {
            const l = e.EnumTranslation.implTranslateCancelResult(p.RecognitionStatus), h = e.EnumTranslation.implTranslateCancelErrorCode(p.RecognitionStatus);
            await this.cancelRecognitionLocal(l, h, e.EnumTranslation.implTranslateErrorDetails(h));
          } else {
            if (p.RecognitionStatus === e.RecognitionStatus.EndOfDictation)
              break;
            if (this.privRecognizerConfig.parameters.getProperty(e.OutputFormatPropertyName) === t.OutputFormat[t.OutputFormat.Simple])
              o = new t.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                d,
                p.DisplayText,
                p.Duration,
                p.Offset,
                p.Language,
                p.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                p.asJson(),
                a
              );
            else {
              const h = e.DetailedSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
              a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, h.asJson()), o = new t.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                d,
                h.RecognitionStatus === e.RecognitionStatus.Success ? h.NBest[0].Display : "",
                h.Duration,
                h.Offset,
                h.Language,
                h.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                h.asJson(),
                a
              );
            }
            const l = new t.SpeechRecognitionEventArgs(o, o.offset, this.privRequestSession.sessionId);
            if (this.privSpeechRecognizer.recognized)
              try {
                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, l);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(o);
              } catch (h) {
                this.privErrorCallback && this.privErrorCallback(h);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          i = !0;
          break;
      }
      return i;
    }
    // Cancels recognition.
    cancelRecognition(s, o, a, i, c) {
      const u = new t.PropertyCollection();
      if (u.setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[i]), this.privSpeechRecognizer.canceled) {
        const p = new t.SpeechRecognitionCanceledEventArgs(a, c, i, void 0, s);
        try {
          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.SpeechRecognitionResult(
          o,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          c,
          void 0,
          // Json
          u
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Ai.SpeechServiceRecognizer = n, Ai;
}
var Mi = {}, Pl;
function OR() {
  if (Pl)
    return Mi;
  Pl = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.ConversationTranscriptionServiceRecognizer = void 0;
  const t = P(), e = b();
  let n = class extends e.ServiceRecognizerBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, i, c), this.privConversationTranscriber = c, this.setSpeakerDiarizationJson();
    }
    setSpeakerDiarizationJson() {
      if (this.privEnableSpeakerId) {
        const s = this.privSpeechContext.getSection("phraseDetection");
        s.mode = "Conversation";
        const o = {};
        o.mode = "Anonymous", o.audioSessionId = this.privDiarizationSessionId, o.audioOffsetMs = 0, o.diarizeIntermediates = this.privRecognizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceResponse_DiarizeIntermediateResults, "false") === "true", s.speakerDiarization = o, this.privSpeechContext.setSection("phraseDetection", s);
      }
    }
    async processTypeSpecificMessages(s) {
      let o;
      const a = new t.PropertyCollection();
      a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, s.textBody);
      let i = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = e.SpeechHypothesis.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          o = new t.ConversationTranscriptionResult(this.privRequestSession.requestId, t.ResultReason.RecognizingSpeech, c.Text, c.Duration, c.Offset, c.Language, c.LanguageDetectionConfidence, c.SpeakerId, void 0, c.asJson(), a), this.privRequestSession.onHypothesis(c.Offset);
          const u = new t.ConversationTranscriptionEventArgs(o, c.Duration, this.privRequestSession.sessionId);
          if (this.privConversationTranscriber.transcribing)
            try {
              this.privConversationTranscriber.transcribing(this.privConversationTranscriber, u);
            } catch {
            }
          i = !0;
          break;
        case "speech.phrase":
          const p = e.SimpleSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset), d = e.EnumTranslation.implTranslateRecognitionResult(p.RecognitionStatus);
          if (this.privRequestSession.onPhraseRecognized(p.Offset + p.Duration), t.ResultReason.Canceled === d) {
            const l = e.EnumTranslation.implTranslateCancelResult(p.RecognitionStatus), h = e.EnumTranslation.implTranslateCancelErrorCode(p.RecognitionStatus);
            await this.cancelRecognitionLocal(l, h, e.EnumTranslation.implTranslateErrorDetails(h));
          } else if (!(this.privRequestSession.isSpeechEnded && d === t.ResultReason.NoMatch && p.RecognitionStatus !== e.RecognitionStatus.InitialSilenceTimeout)) {
            if (this.privRecognizerConfig.parameters.getProperty(e.OutputFormatPropertyName) === t.OutputFormat[t.OutputFormat.Simple])
              o = new t.ConversationTranscriptionResult(this.privRequestSession.requestId, d, p.DisplayText, p.Duration, p.Offset, p.Language, p.LanguageDetectionConfidence, p.SpeakerId, void 0, p.asJson(), a);
            else {
              const h = e.DetailedSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
              o = new t.ConversationTranscriptionResult(this.privRequestSession.requestId, d, h.RecognitionStatus === e.RecognitionStatus.Success ? h.NBest[0].Display : void 0, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, p.SpeakerId, void 0, h.asJson(), a);
            }
            const l = new t.ConversationTranscriptionEventArgs(o, o.offset, this.privRequestSession.sessionId);
            if (this.privConversationTranscriber.transcribed)
              try {
                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, l);
              } catch {
              }
          }
          i = !0;
          break;
      }
      return i;
    }
    // Cancels recognition.
    cancelRecognition(s, o, a, i, c) {
      if (new t.PropertyCollection().setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[i]), this.privConversationTranscriber.canceled) {
        const p = new t.ConversationTranscriptionCanceledEventArgs(a, c, i, void 0, s);
        try {
          this.privConversationTranscriber.canceled(this.privConversationTranscriber, p);
        } catch {
        }
      }
    }
  };
  return Mi.ConversationTranscriptionServiceRecognizer = n, Mi;
}
var Oi = {}, El;
function kR() {
  if (El)
    return Oi;
  El = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.TranscriptionServiceRecognizer = void 0;
  const t = O(), e = P(), n = b(), r = Tt;
  let s = class extends n.ConversationServiceRecognizer {
    constructor(a, i, c, u, p) {
      super(a, i, c, u, p), this.privTranscriberRecognizer = p, this.sendPrePayloadJSONOverride = (d) => this.sendTranscriptionStartJSON(d), this.privRecognizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true" && this.privSpeechContext.setWordLevelTimings();
    }
    async sendSpeechEventAsync(a, i) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createSpeechEventPayload(a, i));
      }
    }
    async sendMeetingSpeechEventAsync(a, i) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createMeetingSpeechEventPayload(a, i));
      }
    }
    processTypeSpecificMessages(a) {
      return this.processSpeechMessages(a);
    }
    handleRecognizedCallback(a, i, c) {
      try {
        const u = new e.SpeechRecognitionEventArgs(a, i, c);
        if (this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, u), this.privSuccessCallback) {
          try {
            this.privSuccessCallback(a);
          } catch (p) {
            this.privErrorCallback && this.privErrorCallback(p);
          }
          this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
        }
      } catch {
      }
    }
    handleRecognizingCallback(a, i, c) {
      try {
        const u = new e.SpeechRecognitionEventArgs(a, i, c);
        this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, u);
      } catch {
      }
    }
    // Cancels recognition.
    cancelRecognition(a, i, c, u, p) {
      const d = new e.PropertyCollection();
      if (d.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[u]), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        if (this.privTranscriberRecognizer.canceled) {
          const l = new e.MeetingTranscriptionCanceledEventArgs(c, p, u, void 0, a);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, l);
          } catch {
          }
        }
      } else if (this.privTranscriberRecognizer.canceled) {
        const l = new e.ConversationTranscriptionCanceledEventArgs(c, p, u, void 0, a);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, l);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const l = new e.SpeechRecognitionResult(
          i,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          p,
          void 0,
          // Json
          d
        );
        try {
          this.privSuccessCallback(l), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendTranscriptionStartJSON(a) {
      if (await this.sendSpeechContext(a, !0), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        const i = this.privTranscriberRecognizer.getMeetingInfo(), c = this.createMeetingSpeechEventPayload(i, "start");
        await this.sendSpeechEvent(a, c);
      } else {
        const i = this.privTranscriberRecognizer.getConversationInfo(), c = this.createSpeechEventPayload(i, "start");
        await this.sendSpeechEvent(a, c);
      }
      await this.sendWaveHeader(a);
    }
    sendSpeechEvent(a, i) {
      const c = JSON.stringify(i);
      if (c)
        return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", c));
    }
    createSpeechEventPayload(a, i) {
      const c = { id: "meeting", name: i, meeting: a.conversationProperties };
      return c.meeting.id = a.id, c.meeting.attendees = a.participants, c;
    }
    createMeetingSpeechEventPayload(a, i) {
      const c = { id: "meeting", name: i, meeting: a.meetingProperties };
      return c.meeting.id = a.id, c.meeting.attendees = a.participants, c;
    }
  };
  return Oi.TranscriptionServiceRecognizer = s, Oi;
}
var ki = {}, Tl;
function DR() {
  if (Tl)
    return ki;
  Tl = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.DetailedSpeechPhrase = void 0;
  const t = b();
  let e = class Qf {
    constructor(r, s) {
      this.privDetailedSpeechPhrase = JSON.parse(r), this.privDetailedSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privDetailedSpeechPhrase.RecognitionStatus), this.updateOffsets(s);
    }
    static fromJSON(r, s) {
      return new Qf(r, s);
    }
    updateOffsets(r) {
      if (this.privDetailedSpeechPhrase.Offset += r, this.privDetailedSpeechPhrase.NBest)
        for (const s of this.privDetailedSpeechPhrase.NBest) {
          if (s.Words)
            for (const o of s.Words)
              o.Offset += r;
          if (s.DisplayWords)
            for (const o of s.DisplayWords)
              o.Offset += r;
        }
    }
    asJson() {
      const r = { ...this.privDetailedSpeechPhrase };
      return JSON.stringify({
        ...r,
        RecognitionStatus: t.RecognitionStatus[r.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privDetailedSpeechPhrase.RecognitionStatus;
    }
    get NBest() {
      return this.privDetailedSpeechPhrase.NBest;
    }
    get Duration() {
      return this.privDetailedSpeechPhrase.Duration;
    }
    get Offset() {
      return this.privDetailedSpeechPhrase.Offset;
    }
    get Language() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get Text() {
      return this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0] ? this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText : this.privDetailedSpeechPhrase.DisplayText;
    }
    get SpeakerId() {
      return this.privDetailedSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(r) {
      if (typeof r == "string")
        return t.RecognitionStatus[r];
      if (typeof r == "number")
        return r;
    }
  };
  return ki.DetailedSpeechPhrase = e, ki;
}
var Di = {}, wl;
function NR() {
  if (wl)
    return Di;
  wl = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.SimpleSpeechPhrase = void 0;
  const t = b();
  let e = class Yf {
    constructor(r, s = 0) {
      this.privSimpleSpeechPhrase = JSON.parse(r), this.privSimpleSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privSimpleSpeechPhrase.RecognitionStatus), this.updateOffset(s);
    }
    static fromJSON(r, s) {
      return new Yf(r, s);
    }
    updateOffset(r) {
      this.privSimpleSpeechPhrase.Offset += r;
    }
    asJson() {
      const r = { ...this.privSimpleSpeechPhrase };
      return JSON.stringify({
        ...r,
        RecognitionStatus: t.RecognitionStatus[r.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privSimpleSpeechPhrase.RecognitionStatus;
    }
    get DisplayText() {
      return this.privSimpleSpeechPhrase.DisplayText;
    }
    get Offset() {
      return this.privSimpleSpeechPhrase.Offset;
    }
    get Duration() {
      return this.privSimpleSpeechPhrase.Duration;
    }
    get Language() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSimpleSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(r) {
      if (typeof r == "string")
        return t.RecognitionStatus[r];
      if (typeof r == "number")
        return r;
    }
  };
  return Di.SimpleSpeechPhrase = e, Di;
}
var Ea = {};
Object.defineProperty(Ea, "__esModule", { value: !0 });
Ea.AddedLmIntent = void 0;
class LR {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param modelImpl - The model.
   * @param intentName - The intent name.
   */
  constructor(e, n) {
    this.modelImpl = e, this.intentName = n;
  }
}
Ea.AddedLmIntent = LR;
var Ni = {}, Il;
function zR() {
  if (Il)
    return Ni;
  Il = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.IntentServiceRecognizer = void 0;
  const t = O(), e = P(), n = b();
  let r = class extends n.ServiceRecognizerBase {
    constructor(o, a, i, c, u) {
      super(o, a, i, c, u), this.privIntentRecognizer = u, this.privIntentDataSent = !1;
    }
    setIntents(o, a) {
      this.privAddedLmIntents = o, this.privUmbrellaIntent = a, this.privIntentDataSent = !0;
    }
    processTypeSpecificMessages(o) {
      let a, i, c = !1;
      const u = new e.PropertyCollection();
      switch (o.messageType === t.MessageType.Text && u.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, o.textBody), o.path.toLowerCase()) {
        case "speech.hypothesis":
          const d = n.SpeechHypothesis.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (a = new e.IntentRecognitionResult(void 0, this.privRequestSession.requestId, e.ResultReason.RecognizingIntent, d.Text, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, d.asJson(), u), this.privRequestSession.onHypothesis(a.offset), i = new e.IntentRecognitionEventArgs(a, d.Offset, this.privRequestSession.sessionId), this.privIntentRecognizer.recognizing)
            try {
              this.privIntentRecognizer.recognizing(this.privIntentRecognizer, i);
            } catch {
            }
          c = !0;
          break;
        case "speech.phrase":
          const l = n.SimpleSpeechPhrase.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset);
          a = new e.IntentRecognitionResult(void 0, this.privRequestSession.requestId, n.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus), l.DisplayText, l.Duration, l.Offset, l.Language, l.LanguageDetectionConfidence, void 0, l.asJson(), u), i = new e.IntentRecognitionEventArgs(a, a.offset, this.privRequestSession.sessionId);
          const h = () => {
            if (this.privIntentRecognizer.recognized)
              try {
                this.privIntentRecognizer.recognized(this.privIntentRecognizer, i);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(a);
              } catch (g) {
                this.privErrorCallback && this.privErrorCallback(g);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          };
          this.privIntentDataSent === !1 || e.ResultReason.NoMatch === i.result.reason ? (this.privRequestSession.onPhraseRecognized(i.offset + i.result.duration), h()) : this.privPendingIntentArgs = i, c = !0;
          break;
        case "response":
          if (i = this.privPendingIntentArgs, this.privPendingIntentArgs = void 0, i === void 0) {
            if (o.textBody === "")
              return;
            i = new e.IntentRecognitionEventArgs(new e.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
          }
          const v = n.IntentResponse.fromJSON(o.textBody);
          if (v !== null && v.topScoringIntent && v.topScoringIntent.intent) {
            let g = this.privAddedLmIntents[v.topScoringIntent.intent];
            if (this.privUmbrellaIntent !== void 0 && (g = this.privUmbrellaIntent), g) {
              const f = g === void 0 || g.intentName === void 0 ? v.topScoringIntent.intent : g.intentName;
              let m = i.result.reason;
              f !== void 0 && (m = e.ResultReason.RecognizedIntent);
              const S = i.result.properties !== void 0 ? i.result.properties : new e.PropertyCollection();
              S.setProperty(e.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, o.textBody), i = new e.IntentRecognitionEventArgs(new e.IntentRecognitionResult(f, i.result.resultId, m, i.result.text, i.result.duration, i.result.offset, void 0, void 0, i.result.errorDetails, i.result.json, S), i.offset, i.sessionId);
            }
          }
          if (this.privRequestSession.onPhraseRecognized(i.offset + i.result.duration), this.privIntentRecognizer.recognized)
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, i);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(i.result);
            } catch (g) {
              this.privErrorCallback && this.privErrorCallback(g);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
          c = !0;
          break;
      }
      const p = new t.Deferred();
      return p.resolve(c), p.promise;
    }
    // Cancels recognition.
    cancelRecognition(o, a, i, c, u) {
      const p = new e.PropertyCollection();
      if (p.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[c]), this.privIntentRecognizer.canceled) {
        const d = new e.IntentRecognitionCanceledEventArgs(i, u, c, void 0, void 0, o);
        try {
          this.privIntentRecognizer.canceled(this.privIntentRecognizer, d);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const d = new e.IntentRecognitionResult(
          void 0,
          // Intent Id
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(d), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Ni.IntentServiceRecognizer = r, Ni;
}
var Ta = {};
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.IntentResponse = void 0;
class zu {
  constructor(e) {
    e === "" ? this.privIntentResponse = {} : this.privIntentResponse = JSON.parse(e);
  }
  static fromJSON(e) {
    return new zu(e);
  }
  get query() {
    return this.privIntentResponse.query;
  }
  get topScoringIntent() {
    return this.privIntentResponse.topScoringIntent;
  }
  get entities() {
    return this.privIntentResponse.entities;
  }
}
Ta.IntentResponse = zu;
var Zf = {};
Object.defineProperty(Zf, "__esModule", { value: !0 });
var wa = {}, Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
Ia.ServiceTelemetryListener = void 0;
const mt = O(), bl = Sa;
class jR {
  constructor(e, n, r) {
    this.privIsDisposed = !1, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privRequestId = e, this.privAudioSourceId = n, this.privAudioNodeId = r, this.privReceivedMessages = {}, this.privPhraseLatencies = [], this.privHypothesisLatencies = [];
  }
  phraseReceived(e) {
    e > 0 && this.privPhraseLatencies.push(Date.now() - e);
  }
  hypothesisReceived(e) {
    e > 0 && this.privHypothesisLatencies.push(Date.now() - e);
  }
  onEvent(e) {
    this.privIsDisposed || (e instanceof bl.RecognitionTriggeredEvent && e.requestId === this.privRequestId && (this.privListeningTriggerMetric = {
      End: e.eventTime,
      Name: "ListeningTrigger",
      Start: e.eventTime
    }), e instanceof mt.AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = e.eventTime), e instanceof mt.AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = e.eventTime), e instanceof mt.AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId && (this.privMicMetric || (this.privMicMetric = {
      End: e.eventTime,
      Error: e.error,
      Name: "Microphone",
      Start: this.privMicStartTime
    })), e instanceof mt.AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
      End: e.eventTime,
      Error: e.error,
      Name: "Microphone",
      Start: this.privMicStartTime
    })), e instanceof mt.AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
      End: e.eventTime,
      Name: "Microphone",
      Start: this.privMicStartTime
    })), e instanceof bl.ConnectingToServiceEvent && e.requestId === this.privRequestId && (this.privConnectionId = e.sessionId), e instanceof mt.ConnectionStartEvent && e.connectionId === this.privConnectionId && (this.privConnectionStartTime = e.eventTime), e instanceof mt.ConnectionEstablishedEvent && e.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
      End: e.eventTime,
      Id: this.privConnectionId,
      Name: "Connection",
      Start: this.privConnectionStartTime
    })), e instanceof mt.ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
      End: e.eventTime,
      Error: this.getConnectionError(e.statusCode),
      Id: this.privConnectionId,
      Name: "Connection",
      Start: this.privConnectionStartTime
    })), e instanceof mt.ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId && e.message && e.message.headers && e.message.headers.path && (this.privReceivedMessages[e.message.headers.path] || (this.privReceivedMessages[e.message.headers.path] = new Array()), this.privReceivedMessages[e.message.headers.path].length < 50 && this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime)));
  }
  getTelemetry() {
    const e = new Array();
    this.privListeningTriggerMetric && e.push(this.privListeningTriggerMetric), this.privMicMetric && e.push(this.privMicMetric), this.privConnectionEstablishMetric && e.push(this.privConnectionEstablishMetric), this.privPhraseLatencies.length > 0 && e.push({
      PhraseLatencyMs: this.privPhraseLatencies
    }), this.privHypothesisLatencies.length > 0 && e.push({
      FirstHypothesisLatencyMs: this.privHypothesisLatencies
    });
    const n = {
      Metrics: e,
      ReceivedMessages: this.privReceivedMessages
    }, r = JSON.stringify(n);
    return this.privReceivedMessages = {}, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privPhraseLatencies = [], this.privHypothesisLatencies = [], r;
  }
  // Determines if there are any telemetry events to send to the service.
  get hasTelemetry() {
    return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
  }
  dispose() {
    this.privIsDisposed = !0;
  }
  getConnectionError(e) {
    switch (e) {
      case 400:
      case 1002:
      case 1003:
      case 1005:
      case 1007:
      case 1008:
      case 1009:
        return "BadRequest";
      case 401:
        return "Unauthorized";
      case 403:
        return "Forbidden";
      case 503:
      case 1001:
        return "ServerUnavailable";
      case 500:
      case 1011:
        return "ServerError";
      case 408:
      case 504:
        return "Timeout";
      default:
        return "statuscode:" + e.toString();
    }
  }
}
Ia.ServiceTelemetryListener = jR;
Object.defineProperty(wa, "__esModule", { value: !0 });
wa.RequestSession = void 0;
const Nn = O(), $s = Sa, xR = Ia;
class BR {
  constructor(e) {
    this.privIsDisposed = !1, this.privDetachables = new Array(), this.privIsAudioNodeDetached = !1, this.privIsRecognizing = !1, this.privIsSpeechEnded = !1, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privHypothesisReceived = !1, this.privBytesSent = 0, this.privRecognitionBytesSent = 0, this.privRecogNumber = 0, this.privInTurn = !1, this.privConnectionAttempts = 0, this.privAudioSourceId = e, this.privRequestId = Nn.createNoDashGuid(), this.privAudioNodeId = Nn.createNoDashGuid(), this.privTurnDeferral = new Nn.Deferred(), this.privTurnDeferral.resolve();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
  get turnCompletionPromise() {
    return this.privTurnDeferral.promise;
  }
  get isSpeechEnded() {
    return this.privIsSpeechEnded;
  }
  get isRecognizing() {
    return this.privIsRecognizing;
  }
  get currentTurnAudioOffset() {
    return this.privTurnStartAudioOffset;
  }
  get recogNumber() {
    return this.privRecogNumber;
  }
  get numConnectionAttempts() {
    return this.privConnectionAttempts;
  }
  // The number of bytes sent for the current connection.
  // Counter is reset to 0 each time a connection is established.
  get bytesSent() {
    return this.privBytesSent;
  }
  // The number of bytes sent for the current recognition.
  // Counter is reset to 0 each time recognition is started.
  get recognitionBytesSent() {
    return this.privRecognitionBytesSent;
  }
  listenForServiceTelemetry(e) {
    this.privServiceTelemetryListener && this.privDetachables.push(e.attachListener(this.privServiceTelemetryListener));
  }
  startNewRecognition() {
    this.privRecognitionBytesSent = 0, this.privIsSpeechEnded = !1, this.privIsRecognizing = !0, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privRecogNumber++, this.privServiceTelemetryListener = new xR.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId), this.onEvent(new $s.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
  }
  async onAudioSourceAttachCompleted(e, n) {
    this.privAudioNode = e, this.privIsAudioNodeDetached = !1, n ? await this.onComplete() : this.onEvent(new $s.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
  }
  onPreConnectionStart(e, n) {
    this.privAuthFetchEventId = e, this.privSessionId = n, this.onEvent(new $s.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
  }
  async onAuthCompleted(e) {
    e && await this.onComplete();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async onConnectionEstablishCompleted(e, n) {
    if (e === 200) {
      this.onEvent(new $s.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId)), this.privAudioNode && this.privAudioNode.replay(), this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privBytesSent = 0;
      return;
    } else
      e === 403 && await this.onComplete();
  }
  async onServiceTurnEndResponse(e) {
    this.privTurnDeferral.resolve(), !e || this.isSpeechEnded ? (await this.onComplete(), this.privInTurn = !1) : (this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privAudioNode.replay());
  }
  onSpeechContext() {
    this.privRequestId = Nn.createNoDashGuid();
  }
  onServiceTurnStartResponse() {
    this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
    })), this.privInTurn = !0, this.privTurnDeferral = new Nn.Deferred();
  }
  onHypothesis(e) {
    this.privHypothesisReceived || (this.privHypothesisReceived = !0, this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(e)));
  }
  onPhraseRecognized(e) {
    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(e)), this.onServiceRecognized(e);
  }
  onServiceRecognized(e) {
    this.privLastRecoOffset = e, this.privHypothesisReceived = !1, this.privAudioNode.shrinkBuffers(e), this.privConnectionAttempts = 0;
  }
  onAudioSent(e) {
    this.privBytesSent += e, this.privRecognitionBytesSent += e;
  }
  onRetryConnection() {
    this.privConnectionAttempts++;
  }
  async dispose() {
    if (!this.privIsDisposed) {
      this.privIsDisposed = !0;
      for (const e of this.privDetachables)
        await e.detach();
      this.privServiceTelemetryListener && this.privServiceTelemetryListener.dispose(), this.privIsRecognizing = !1;
    }
  }
  getTelemetry() {
    return this.privServiceTelemetryListener.hasTelemetry ? this.privServiceTelemetryListener.getTelemetry() : null;
  }
  async onStopRecognizing() {
    await this.onComplete();
  }
  // Should be called with the audioNode for this session has indicated that it is out of speech.
  onSpeechEnded() {
    this.privIsSpeechEnded = !0;
  }
  onEvent(e) {
    this.privServiceTelemetryListener && this.privServiceTelemetryListener.onEvent(e), Nn.Events.instance.onEvent(e);
  }
  async onComplete() {
    this.privIsRecognizing && (this.privIsRecognizing = !1, await this.detachAudioNode());
  }
  async detachAudioNode() {
    this.privIsAudioNodeDetached || (this.privIsAudioNodeDetached = !0, this.privAudioNode && await this.privAudioNode.detach());
  }
}
wa.RequestSession = BR;
var ba = {};
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.SpeechContext = void 0;
class qR {
  constructor(e) {
    this.privContext = {}, this.privDynamicGrammar = e;
  }
  /**
   * Gets a section of the speech.context object.
   * @param sectionName Name of the section to get.
   * @return string or Context JSON serializable object that represents the value.
   */
  getSection(e) {
    return this.privContext[e] || {};
  }
  /**
   * Adds a section to the speech.context object.
   * @param sectionName Name of the section to add.
   * @param value JSON serializable object that represents the value.
   */
  setSection(e, n) {
    this.privContext[e] = n;
  }
  /**
   * @Internal
   * This is only used by pronunciation assessment config.
   * Do not use externally, object returned will change without warning or notice.
   */
  setPronunciationAssessmentParams(e, n, r = !1) {
    this.privContext.phraseDetection === void 0 && (this.privContext.phraseDetection = {
      enrichment: {
        pronunciationAssessment: {}
      }
    }), this.privContext.phraseDetection.enrichment === void 0 && (this.privContext.phraseDetection.enrichment = {
      pronunciationAssessment: {}
    }), this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(e), r && (this.privContext.phraseDetection.mode = "Conversation"), this.setWordLevelTimings(), this.privContext.phraseOutput.detailed.options.push("PronunciationAssessment"), this.privContext.phraseOutput.detailed.options.indexOf("SNR") === -1 && this.privContext.phraseOutput.detailed.options.push("SNR"), n && (this.privContext.phraseDetection.enrichment.contentAssessment = {
      topic: n
    }, this.privContext.phraseOutput.detailed.options.push("ContentAssessment"));
  }
  setDetailedOutputFormat() {
    this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
      detailed: {
        options: []
      },
      format: {}
    }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
      options: []
    }), this.privContext.phraseOutput.format = "Detailed";
  }
  setWordLevelTimings() {
    this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
      detailed: {
        options: []
      },
      format: {}
    }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
      options: []
    }), this.privContext.phraseOutput.format = "Detailed", this.privContext.phraseOutput.detailed.options.indexOf("WordTimings") === -1 && this.privContext.phraseOutput.detailed.options.push("WordTimings");
  }
  setSpeakerDiarizationAudioOffsetMs(e) {
    this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = e;
  }
  toJSON() {
    const e = this.privDynamicGrammar.generateGrammarObject();
    return this.setSection("dgi", e), JSON.stringify(this.privContext);
  }
}
ba.SpeechContext = qR;
var Aa = {};
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.DynamicGrammarBuilder = void 0;
class FR {
  // Adds one more reference phrases to the dynamic grammar to send.
  // All added phrases are generic phrases.
  addPhrase(e) {
    this.privPhrases || (this.privPhrases = []), e instanceof Array ? this.privPhrases = this.privPhrases.concat(e) : this.privPhrases.push(e);
  }
  // Clears all phrases stored in the current object.
  clearPhrases() {
    this.privPhrases = void 0;
  }
  // Adds one or more reference grammars to the current grammar.
  addReferenceGrammar(e) {
    this.privGrammars || (this.privGrammars = []), e instanceof Array ? this.privGrammars = this.privGrammars.concat(e) : this.privGrammars.push(e);
  }
  // clears all grammars stored on the recognizer.
  clearGrammars() {
    this.privGrammars = void 0;
  }
  // Generates an object that represents the dynamic grammar used by the Speech Service.
  // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
  // of a DynamicGrammarBuilder
  generateGrammarObject() {
    if (this.privGrammars === void 0 && this.privPhrases === void 0)
      return;
    const e = {};
    if (e.ReferenceGrammars = this.privGrammars, this.privPhrases !== void 0 && this.privPhrases.length !== 0) {
      const n = [];
      this.privPhrases.forEach((r) => {
        n.push({
          Text: r
        });
      }), e.Groups = [{ Type: "Generic", Items: n }];
    }
    return e;
  }
}
Aa.DynamicGrammarBuilder = FR;
var Xf = {};
Object.defineProperty(Xf, "__esModule", { value: !0 });
var Li = {}, Ma = {}, Oa = {}, ju = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MessageDataStreamType = t.ActivityPayloadResponse = void 0;
  class e {
    constructor(r) {
      this.privActivityResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get conversationId() {
      return this.privActivityResponse.conversationId;
    }
    get messageDataStreamType() {
      return this.privActivityResponse.messageDataStreamType;
    }
    get messagePayload() {
      return this.privActivityResponse.messagePayload;
    }
    get version() {
      return this.privActivityResponse.version;
    }
  }
  t.ActivityPayloadResponse = e, function(n) {
    n[n.None = 0] = "None", n[n.TextToSpeechAudio = 1] = "TextToSpeechAudio";
  }(t.MessageDataStreamType || (t.MessageDataStreamType = {}));
})(ju);
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.DialogServiceTurnState = void 0;
const $R = Vt, UR = Re, HR = ju;
class WR {
  constructor(e, n) {
    this.privRequestId = n, this.privIsCompleted = !1, this.privAudioStream = null, this.privTurnManager = e, this.resetTurnEndTimeout();
  }
  get audioStream() {
    return this.resetTurnEndTimeout(), this.privAudioStream;
  }
  processActivityPayload(e, n) {
    return e.messageDataStreamType === HR.MessageDataStreamType.TextToSpeechAudio && (this.privAudioStream = UR.AudioOutputStream.createPullStream(), this.privAudioStream.format = n !== void 0 ? n : $R.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privAudioStream;
  }
  endAudioStream() {
    this.privAudioStream !== null && !this.privAudioStream.isClosed && this.privAudioStream.close();
  }
  complete() {
    this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.endAudioStream();
  }
  resetTurnEndTimeout() {
    this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.privTimeoutToken = setTimeout(() => {
      this.privTurnManager.CompleteTurn(this.privRequestId);
    }, 2e3);
  }
}
Oa.DialogServiceTurnState = WR;
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.DialogServiceTurnStateManager = void 0;
const Al = Ee, VR = Oa;
class KR {
  constructor() {
    this.privTurnMap = /* @__PURE__ */ new Map();
  }
  StartTurn(e) {
    if (this.privTurnMap.has(e))
      throw new Al.InvalidOperationError("Service error: There is already a turn with id:" + e);
    const n = new VR.DialogServiceTurnState(this, e);
    return this.privTurnMap.set(e, n), this.privTurnMap.get(e);
  }
  GetTurn(e) {
    return this.privTurnMap.get(e);
  }
  CompleteTurn(e) {
    if (!this.privTurnMap.has(e))
      throw new Al.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + e);
    const n = this.privTurnMap.get(e);
    return n.complete(), this.privTurnMap.delete(e), n;
  }
}
Ma.DialogServiceTurnStateManager = KR;
var Ml;
function JR() {
  if (Ml)
    return Li;
  Ml = 1, Object.defineProperty(Li, "__esModule", { value: !0 }), Li.DialogServiceAdapter = void 0;
  const t = Se(), e = yn, n = O(), r = Vt, s = P(), o = Ma, a = b(), i = ju, c = Tt;
  let u = class extends a.ServiceRecognizerBase {
    constructor(d, l, h, v, g) {
      super(d, l, h, v, g), this.privEvents = new n.EventSource(), this.privDialogServiceConnector = g, this.receiveMessageOverride = () => this.receiveDialogMessageOverride(), this.privTurnStateManager = new o.DialogServiceTurnStateManager(), this.recognizeOverride = (f, m, S) => this.listenOnce(f, m, S), this.postConnectImplOverride = (f) => this.dialogConnectImpl(f), this.configConnectionOverride = (f) => this.configConnection(f), this.disconnectOverride = () => this.privDisconnect(), this.privDialogAudioSource = h, this.agentConfigSent = !1, this.privLastResult = null, this.connectionEvents.attach((f) => {
        f.name === "ConnectionClosedEvent" && (this.terminateMessageLoop = !0);
      });
    }
    async sendMessage(d) {
      const l = n.createGuid(), h = n.createNoDashGuid(), v = {
        context: {
          interactionId: l
        },
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        messagePayload: JSON.parse(d),
        version: 0.5
      }, g = JSON.stringify(v);
      await (await this.fetchConnection()).send(new c.SpeechConnectionMessage(n.MessageType.Text, "agent", h, "application/json", g));
    }
    async privDisconnect() {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, this.agentConfigSent = !1;
    }
    processTypeSpecificMessages(d) {
      const l = new s.PropertyCollection();
      d.messageType === n.MessageType.Text && l.setProperty(s.PropertyId.SpeechServiceResponse_JsonResult, d.textBody);
      let h, v;
      switch (d.path.toLowerCase()) {
        case "speech.phrase":
          const f = a.SimpleSpeechPhrase.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (this.privRequestSession.onPhraseRecognized(f.Offset + f.Duration), f.RecognitionStatus !== a.RecognitionStatus.TooManyRequests && f.RecognitionStatus !== a.RecognitionStatus.Error) {
            const _ = this.fireEventForResult(f, l);
            if (this.privLastResult = _.result, this.privDialogServiceConnector.recognized)
              try {
                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, _);
              } catch {
              }
          }
          v = !0;
          break;
        case "speech.hypothesis":
          const m = a.SpeechHypothesis.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          h = new s.SpeechRecognitionResult(this.privRequestSession.requestId, s.ResultReason.RecognizingSpeech, m.Text, m.Duration, m.Offset, m.Language, m.LanguageDetectionConfidence, void 0, void 0, m.asJson(), l), this.privRequestSession.onHypothesis(m.Offset);
          const S = new s.SpeechRecognitionEventArgs(h, m.Offset, this.privRequestSession.sessionId);
          if (this.privDialogServiceConnector.recognizing)
            try {
              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, S);
            } catch {
            }
          v = !0;
          break;
        case "speech.keyword":
          const y = a.SpeechKeyword.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          h = new s.SpeechRecognitionResult(this.privRequestSession.requestId, y.Status === "Accepted" ? s.ResultReason.RecognizedKeyword : s.ResultReason.NoMatch, y.Text, y.Duration, y.Offset, void 0, void 0, void 0, void 0, y.asJson(), l), y.Status !== "Accepted" && (this.privLastResult = h);
          const E = new s.SpeechRecognitionEventArgs(h, h.duration, h.resultId);
          if (this.privDialogServiceConnector.recognized)
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, E);
            } catch {
            }
          v = !0;
          break;
        case "audio":
          {
            const _ = d.requestId.toUpperCase(), C = this.privTurnStateManager.GetTurn(_);
            try {
              d.binaryBody ? C.audioStream.write(d.binaryBody) : C.endAudioStream();
            } catch {
            }
          }
          v = !0;
          break;
        case "response":
          this.handleResponseMessage(d), v = !0;
          break;
      }
      const g = new n.Deferred();
      return g.resolve(v), g.promise;
    }
    // Cancels recognition.
    async cancelRecognition(d, l, h, v, g) {
      if (this.terminateMessageLoop = !0, this.privRequestSession.isRecognizing && await this.privRequestSession.onStopRecognizing(), this.privDialogServiceConnector.canceled) {
        const f = new s.PropertyCollection();
        f.setProperty(a.CancellationErrorCodePropertyName, s.CancellationErrorCode[v]);
        const m = new s.SpeechRecognitionCanceledEventArgs(h, g, v, void 0, d);
        try {
          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, m);
        } catch {
        }
        if (this.privSuccessCallback) {
          const S = new s.SpeechRecognitionResult(
            void 0,
            // ResultId
            s.ResultReason.Canceled,
            void 0,
            // Text
            void 0,
            // Duration
            void 0,
            // Offset
            void 0,
            // Language
            void 0,
            // Language Detection Confidence
            void 0,
            // Speaker Id
            g,
            void 0,
            // Json
            f
          );
          try {
            this.privSuccessCallback(S), this.privSuccessCallback = void 0;
          } catch {
          }
        }
      }
    }
    async listenOnce(d, l, h) {
      this.privRecognizerConfig.recognitionMode = d, this.privSuccessCallback = l, this.privErrorCallback = h, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events), this.privRecognizerConfig.parameters.setProperty(s.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const v = this.connectImpl(), g = this.sendPreAudioMessages(), f = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId), m = await this.privDialogAudioSource.format, S = await this.privDialogAudioSource.deviceInfo, y = new t.ReplayableAudioNode(f, m.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(y, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: S };
      try {
        await v, await g;
      } catch (C) {
        return await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.ConnectionFailure, C), Promise.resolve();
      }
      const E = new s.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, E), this.sendAudio(y).then(() => {
      }, async (C) => {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.RuntimeError, C);
      });
    }
    // Establishes a websocket connection to the end point.
    dialogConnectImpl(d) {
      return this.privConnectionLoop = this.startMessageLoop(), d;
    }
    receiveDialogMessageOverride() {
      const d = new n.Deferred(), l = async () => {
        try {
          const h = this.isDisposed(), v = !this.isDisposed() && this.terminateMessageLoop;
          if (h || v) {
            d.resolve(void 0);
            return;
          }
          const f = await (await this.fetchConnection()).read();
          if (!f)
            return l();
          const m = c.SpeechConnectionMessage.fromConnectionMessage(f);
          switch (m.path.toLowerCase()) {
            case "turn.start":
              {
                const T = m.requestId.toUpperCase(), A = this.privRequestSession.requestId.toUpperCase();
                T !== A ? this.privTurnStateManager.StartTurn(T) : this.privRequestSession.onServiceTurnStartResponse();
              }
              break;
            case "speech.startdetected":
              const y = a.SpeechDetected.fromJSON(m.textBody, this.privRequestSession.currentTurnAudioOffset), E = new s.RecognitionEventArgs(y.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, E);
              break;
            case "speech.enddetected":
              let _;
              m.textBody.length > 0 ? _ = m.textBody : _ = "{ Offset: 0 }";
              const C = a.SpeechDetected.fromJSON(_, this.privRequestSession.currentTurnAudioOffset);
              this.privRequestSession.onServiceRecognized(C.Offset);
              const R = new s.RecognitionEventArgs(C.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, R);
              break;
            case "turn.end":
              {
                const T = m.requestId.toUpperCase(), A = this.privRequestSession.requestId.toUpperCase();
                if (T !== A)
                  this.privTurnStateManager.CompleteTurn(T);
                else {
                  const U = new s.SessionEventArgs(this.privRequestSession.sessionId);
                  if (await this.privRequestSession.onServiceTurnEndResponse(!1), (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) && this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, U), this.privSuccessCallback && this.privLastResult) {
                    try {
                      this.privSuccessCallback(this.privLastResult), this.privLastResult = null;
                    } catch (K) {
                      this.privErrorCallback && this.privErrorCallback(K);
                    }
                    this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
                  }
                }
              }
              break;
            default:
              try {
                await this.processTypeSpecificMessages(m) || this.serviceEvents && this.serviceEvents.onEvent(new n.ServiceEvent(m.path.toLowerCase(), m.textBody));
              } catch {
              }
          }
          return l();
        } catch {
          this.terminateMessageLoop = !0, d.resolve();
        }
      };
      return l().catch((h) => {
        n.Events.instance.onEvent(new n.BackgroundEvent(h));
      }), d.promise;
    }
    async startMessageLoop() {
      this.terminateMessageLoop = !1;
      try {
        await this.receiveDialogMessageOverride();
      } catch (d) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.RuntimeError, d);
      }
      return Promise.resolve();
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configConnection(d) {
      return this.terminateMessageLoop ? (this.terminateMessageLoop = !1, Promise.reject("Connection to service terminated.")) : (await this.sendSpeechServiceConfig(d, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendAgentConfig(d), d);
    }
    async sendPreAudioMessages() {
      const d = await this.fetchConnection();
      this.addKeywordContextData(), await this.sendSpeechContext(d, !0), await this.sendAgentContext(d), await this.sendWaveHeader(d);
    }
    sendAgentConfig(d) {
      if (this.agentConfig && !this.agentConfigSent) {
        if (this.privRecognizerConfig.parameters.getProperty(s.PropertyId.Conversation_DialogType) === s.DialogServiceConfig.DialogTypes.CustomCommands) {
          const h = this.agentConfig.get();
          h.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us"), this.agentConfig.set(h);
        }
        this.onEvent(new e.SendingAgentContextMessageEvent(this.agentConfig));
        const l = this.agentConfig.toJsonString();
        return this.agentConfigSent = !0, d.send(new c.SpeechConnectionMessage(n.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", l));
      }
    }
    sendAgentContext(d) {
      const l = n.createGuid(), h = this.privDialogServiceConnector.properties.getProperty(s.PropertyId.Conversation_Speech_Activity_Template), g = JSON.stringify({
        channelData: "",
        context: {
          interactionId: l
        },
        messagePayload: typeof h === void 0 ? void 0 : h,
        version: 0.5
      });
      return d.send(new c.SpeechConnectionMessage(n.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", g));
    }
    fireEventForResult(d, l) {
      const h = a.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus), v = new s.SpeechRecognitionResult(this.privRequestSession.requestId, h, d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, void 0, d.asJson(), l);
      return new s.SpeechRecognitionEventArgs(v, d.Offset, this.privRequestSession.sessionId);
    }
    handleResponseMessage(d) {
      const l = JSON.parse(d.textBody);
      switch (l.messageType.toLowerCase()) {
        case "message":
          const h = d.requestId.toUpperCase(), v = i.ActivityPayloadResponse.fromJSON(d.textBody), g = this.privTurnStateManager.GetTurn(h);
          if (v.conversationId) {
            const S = this.agentConfig.get();
            S.botInfo.conversationId = v.conversationId, this.agentConfig.set(S);
          }
          const f = g.processActivityPayload(v, r.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0))), m = new s.ActivityReceivedEventArgs(v.messagePayload, f);
          if (this.privDialogServiceConnector.activityReceived)
            try {
              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, m);
            } catch {
            }
          break;
        case "messagestatus":
          if (this.privDialogServiceConnector.turnStatusReceived)
            try {
              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new s.TurnStatusReceivedEventArgs(d.textBody));
            } catch {
            }
          break;
        default:
          n.Events.instance.onEvent(new n.BackgroundEvent(`Unexpected response of type ${l.messageType}. Ignoring.`));
          break;
      }
    }
    onEvent(d) {
      this.privEvents.onEvent(d), n.Events.instance.onEvent(d);
    }
    addKeywordContextData() {
      const d = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
      if (d === void 0)
        return;
      const l = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets"), h = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations"), v = d.split(";"), g = l === void 0 ? [] : l.split(";"), f = h === void 0 ? [] : h.split(";"), m = [];
      for (let S = 0; S < v.length; S++) {
        const y = {};
        y.text = v[S], S < g.length && (y.offset = Number(g[S])), S < f.length && (y.duration = Number(f[S])), m.push(y);
      }
      this.speechContext.setSection("invocationSource", "VoiceActivationWithKeyword"), this.speechContext.setSection("keywordDetection", [{
        clientDetectedKeywords: m,
        onReject: { action: "EndOfTurn" },
        type: "startTrigger"
      }]);
    }
  };
  return Li.DialogServiceAdapter = u, Li;
}
var ka = {};
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.AgentConfig = void 0;
class GR {
  toJsonString() {
    return JSON.stringify(this.iPrivConfig);
  }
  get() {
    return this.iPrivConfig;
  }
  /**
   * Setter for the agent.config object.
   * @param value a JSON serializable object.
   */
  set(e) {
    this.iPrivConfig = e;
  }
}
ka.AgentConfig = GR;
var mc = {}, zi = {}, tr = {};
Object.defineProperty(tr, "__esModule", { value: !0 });
tr.ConversationConnectionConfig = void 0;
const QR = _s;
class De extends QR.RestConfigBase {
  static get host() {
    return De.privHost;
  }
  static get apiVersion() {
    return De.privApiVersion;
  }
  static get clientAppId() {
    return De.privClientAppId;
  }
  static get defaultLanguageCode() {
    return De.privDefaultLanguageCode;
  }
  static get restPath() {
    return De.privRestPath;
  }
  static get webSocketPath() {
    return De.privWebSocketPath;
  }
  static get transcriptionEventKeys() {
    return De.privTranscriptionEventKeys;
  }
}
tr.ConversationConnectionConfig = De;
De.privHost = "dev.microsofttranslator.com";
De.privRestPath = "/capito/room";
De.privApiVersion = "2.0";
De.privDefaultLanguageCode = "en-US";
De.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15";
De.privWebSocketPath = "/capito/translate";
De.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"];
var Ol;
function YR() {
  if (Ol)
    return zi;
  Ol = 1, Object.defineProperty(zi, "__esModule", { value: !0 }), zi.ConversationManager = void 0;
  const t = Se(), e = D, n = P(), r = tr;
  let s = class {
    constructor() {
      this.privRequestParams = r.ConversationConnectionConfig.configParams, this.privErrors = r.ConversationConnectionConfig.restErrors, this.privHost = r.ConversationConnectionConfig.host, this.privApiVersion = r.ConversationConnectionConfig.apiVersion, this.privRestPath = r.ConversationConnectionConfig.restPath, this.privRestAdapter = new t.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    createOrJoin(a, i, c, u) {
      try {
        e.Contracts.throwIfNullOrUndefined(a, "args");
        const p = a.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, r.ConversationConnectionConfig.defaultLanguageCode), d = a.getProperty(n.PropertyId.ConversationTranslator_Name, "conversation_host"), l = a.getProperty(n.PropertyId.ConversationTranslator_Host, this.privHost), h = a.getProperty(n.PropertyId.ConversationTranslator_CorrelationId), v = a.getProperty(n.PropertyId.SpeechServiceConnection_Key), g = a.getProperty(n.PropertyId.SpeechServiceConnection_Region), f = a.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
        e.Contracts.throwIfNullOrWhitespace(p, "languageCode"), e.Contracts.throwIfNullOrWhitespace(d, "nickname"), e.Contracts.throwIfNullOrWhitespace(l, "endpointHost");
        const m = {};
        m[this.privRequestParams.apiVersion] = this.privApiVersion, m[this.privRequestParams.languageCode] = p, m[this.privRequestParams.nickname] = d;
        const S = {};
        h && (S[this.privRequestParams.correlationId] = h), S[this.privRequestParams.clientAppId] = r.ConversationConnectionConfig.clientAppId, i !== void 0 ? m[this.privRequestParams.roomId] = i : (e.Contracts.throwIfNullOrUndefined(g, this.privErrors.authInvalidSubscriptionRegion), S[this.privRequestParams.subscriptionRegion] = g, v ? S[this.privRequestParams.subscriptionKey] = v : f ? S[this.privRequestParams.authorization] = `Bearer ${f}` : e.Contracts.throwIfNullOrUndefined(v, this.privErrors.authInvalidSubscriptionKey));
        const y = {};
        y.headers = S, this.privRestAdapter.options = y;
        const E = `https://${l}${this.privRestPath}`;
        this.privRestAdapter.request(t.RestRequestType.Post, E, m, null).then((_) => {
          const C = t.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, _.headers);
          if (!_.ok) {
            if (u) {
              let T = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", _.status.toString()), A;
              try {
                A = JSON.parse(_.data), T += ` [${A.error.code}: ${A.error.message}]`;
              } catch {
                T += ` [${_.data}]`;
              }
              C && (T += ` ${C}`), u(T);
            }
            return;
          }
          const R = JSON.parse(_.data);
          if (R && (R.requestId = C), c) {
            try {
              c(R);
            } catch (T) {
              u && u(T);
            }
            c = void 0;
          }
        }).catch(() => {
        });
      } catch (p) {
        if (u)
          if (p instanceof Error) {
            const d = p;
            u(d.name + ": " + d.message);
          } else
            u(p);
      }
    }
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    leave(a, i) {
      return new Promise((c, u) => {
        try {
          e.Contracts.throwIfNullOrUndefined(a, this.privErrors.invalidArgs.replace("{arg}", "config")), e.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "token"));
          const p = a.getProperty(n.PropertyId.ConversationTranslator_Host, this.privHost), d = a.getProperty(n.PropertyId.ConversationTranslator_CorrelationId), l = {};
          l[this.privRequestParams.apiVersion] = this.privApiVersion, l[this.privRequestParams.sessionToken] = i;
          const h = {};
          d && (h[this.privRequestParams.correlationId] = d);
          const v = {};
          v.headers = h, this.privRestAdapter.options = v;
          const g = `https://${p}${this.privRestPath}`;
          this.privRestAdapter.request(t.RestRequestType.Delete, g, l, null).then((f) => {
            f.ok, c();
          }).catch(() => {
          });
        } catch (p) {
          if (p instanceof Error) {
            const d = p;
            u(d.name + ": " + d.message);
          } else
            u(p);
        }
      });
    }
  };
  return zi.ConversationManager = s, zi;
}
var an = {}, ji = {}, Da = {}, Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
Rs.ConversationConnectionMessage = void 0;
const ZR = O();
class XR extends ZR.ConnectionMessage {
  constructor(e, n, r, s) {
    super(e, n, r, s);
    const o = JSON.parse(this.textBody);
    o.type !== void 0 && (this.privConversationMessageType = o.type);
  }
  get conversationMessageType() {
    return this.privConversationMessageType;
  }
}
Rs.ConversationConnectionMessage = XR;
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.ConversationWebsocketMessageFormatter = void 0;
const cn = O(), kl = Rs;
class eP {
  /**
   * Format incoming messages: text (speech partial/final, IM) or binary (tts)
   */
  toConnectionMessage(e) {
    const n = new cn.Deferred();
    try {
      if (e.messageType === cn.MessageType.Text) {
        const r = new kl.ConversationConnectionMessage(e.messageType, e.textContent, {}, e.id);
        n.resolve(r);
      } else
        e.messageType === cn.MessageType.Binary && n.resolve(new kl.ConversationConnectionMessage(e.messageType, e.binaryContent, void 0, e.id));
    } catch (r) {
      n.reject(`Error formatting the message. Error: ${r}`);
    }
    return n.promise;
  }
  /**
   * Format outgoing messages: text (commands or IM)
   */
  fromConnectionMessage(e) {
    const n = new cn.Deferred();
    try {
      if (e.messageType === cn.MessageType.Text) {
        const r = `${e.textBody ? e.textBody : ""}`;
        n.resolve(new cn.RawWebsocketMessage(cn.MessageType.Text, r, e.id));
      }
    } catch (r) {
      n.reject(`Error formatting the message. ${r}`);
    }
    return n.promise;
  }
}
Da.ConversationWebsocketMessageFormatter = eP;
var Dl;
function tP() {
  if (Dl)
    return ji;
  Dl = 1, Object.defineProperty(ji, "__esModule", { value: !0 }), ji.ConversationConnectionFactory = void 0;
  const t = Se(), e = O(), n = D, r = P(), s = ot(), o = tr, a = Da;
  let i = class extends s.ConnectionFactoryBase {
    create(u, p, d) {
      const l = u.parameters.getProperty(r.PropertyId.ConversationTranslator_Host, o.ConversationConnectionConfig.host), h = u.parameters.getProperty(r.PropertyId.ConversationTranslator_CorrelationId, e.createGuid()), v = `wss://${l}${o.ConversationConnectionConfig.webSocketPath}`, g = u.parameters.getProperty(r.PropertyId.ConversationTranslator_Token, void 0);
      n.Contracts.throwIfNullOrUndefined(g, "token");
      const f = {};
      f[o.ConversationConnectionConfig.configParams.apiVersion] = o.ConversationConnectionConfig.apiVersion, f[o.ConversationConnectionConfig.configParams.token] = g, f[o.ConversationConnectionConfig.configParams.correlationId] = h;
      const m = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(v, f, {}, new a.ConversationWebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), m, d);
    }
  };
  return ji.ConversationConnectionFactory = i, ji;
}
var xi = {}, Na = {};
Object.defineProperty(Na, "__esModule", { value: !0 });
Na.ConversationRequestSession = void 0;
const Sc = O();
class nP {
  constructor(e) {
    this.privIsDisposed = !1, this.privDetachables = new Array(), this.privSessionId = e, this.privRequestId = Sc.createNoDashGuid(), this.privRequestCompletionDeferral = new Sc.Deferred();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get completionPromise() {
    return this.privRequestCompletionDeferral.promise;
  }
  onPreConnectionStart(e, n) {
    this.privSessionId = n;
  }
  onAuthCompleted(e) {
    e && this.onComplete();
  }
  onConnectionEstablishCompleted(e) {
    e !== 200 && e === 403 && this.onComplete();
  }
  onServiceTurnEndResponse(e) {
    e ? this.privRequestId = Sc.createNoDashGuid() : this.onComplete();
  }
  async dispose() {
    if (!this.privIsDisposed) {
      this.privIsDisposed = !0;
      for (const e of this.privDetachables)
        await e.detach();
    }
  }
  onComplete() {
  }
}
Na.ConversationRequestSession = nP;
var ze = {}, Nl;
function eg() {
  if (Nl)
    return ze;
  Nl = 1, Object.defineProperty(ze, "__esModule", { value: !0 }), ze.ConversationReceivedTranslationEventArgs = ze.ParticipantsListEventArgs = ze.ParticipantAttributeEventArgs = ze.ParticipantEventArgs = ze.LockRoomEventArgs = ze.MuteAllEventArgs = void 0;
  const t = P();
  class e extends t.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsMuted = c;
    }
    get isMuted() {
      return this.privIsMuted;
    }
  }
  ze.MuteAllEventArgs = e;
  class n extends t.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsLocked = c;
    }
    get isMuted() {
      return this.privIsLocked;
    }
  }
  ze.LockRoomEventArgs = n;
  class r extends t.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privParticipant = c;
    }
    get participant() {
      return this.privParticipant;
    }
  }
  ze.ParticipantEventArgs = r;
  class s extends t.SessionEventArgs {
    constructor(c, u, p, d) {
      super(d), this.privKey = u, this.privValue = p, this.privParticipantId = c;
    }
    get value() {
      return this.privValue;
    }
    get key() {
      return this.privKey;
    }
    get id() {
      return this.privParticipantId;
    }
  }
  ze.ParticipantAttributeEventArgs = s;
  class o extends t.SessionEventArgs {
    constructor(c, u, p, d, l, h, v, g, f) {
      super(f), this.privRoomId = c, this.privSessionToken = u, this.privTranslateTo = p, this.privProfanityFilter = d, this.privRoomProfanityFilter = l, this.privIsRoomLocked = h, this.privIsRoomLocked = v, this.privParticipants = g;
    }
    get sessionToken() {
      return this.privSessionToken;
    }
    get conversationId() {
      return this.privRoomId;
    }
    get translateTo() {
      return this.privTranslateTo;
    }
    get profanityFilter() {
      return this.privProfanityFilter;
    }
    get roomProfanityFilter() {
      return this.privRoomProfanityFilter;
    }
    get isRoomLocked() {
      return this.privIsRoomLocked;
    }
    get isMuteAll() {
      return this.privIsMuteAll;
    }
    get participants() {
      return this.privParticipants;
    }
  }
  ze.ParticipantsListEventArgs = o;
  class a {
    constructor(c, u, p) {
      this.privPayload = u, this.privCommand = c, this.privSessionId = p;
    }
    get payload() {
      return this.privPayload;
    }
    get command() {
      return this.privCommand;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  return ze.ConversationReceivedTranslationEventArgs = a, ze;
}
var _t = {};
Object.defineProperty(_t, "__esModule", { value: !0 });
_t.ConversationTranslatorCommandTypes = _t.ConversationTranslatorMessageTypes = _t.InternalParticipants = void 0;
class rP {
  constructor(e = [], n) {
    this.participants = e, this.meId = n;
  }
  /**
   * Add or update a participant
   * @param value
   */
  addOrUpdateParticipant(e) {
    if (e === void 0)
      return;
    const n = this.getParticipantIndex(e.id);
    return n > -1 ? this.participants.splice(n, 1, e) : this.participants.push(e), this.getParticipant(e.id);
  }
  /**
   * Find the participant's position in the participants list.
   * @param id
   */
  getParticipantIndex(e) {
    return this.participants.findIndex((n) => n.id === e);
  }
  /**
   * Find the participant by id.
   * @param id
   */
  getParticipant(e) {
    return this.participants.find((n) => n.id === e);
  }
  /**
   * Remove a participant from the participants list.
   */
  deleteParticipant(e) {
    this.participants = this.participants.filter((n) => n.id !== e);
  }
  /**
   * Helper to return the conversation host.
   */
  get host() {
    return this.participants.find((e) => e.isHost === !0);
  }
  /**
   * Helper to return the current user.
   */
  get me() {
    return this.getParticipant(this.meId);
  }
}
_t.InternalParticipants = rP;
_t.ConversationTranslatorMessageTypes = {
  command: "command",
  final: "final",
  info: "info",
  instantMessage: "instant_message",
  keepAlive: "keep_alive",
  partial: "partial",
  participantCommand: "participant_command",
  translatedMessage: "translated_message"
};
_t.ConversationTranslatorCommandTypes = {
  changeNickname: "ChangeNickname",
  disconnectSession: "DisconnectSession",
  ejectParticipant: "EjectParticipant",
  instant_message: "instant_message",
  joinSession: "JoinSession",
  leaveSession: "LeaveSession",
  participantList: "ParticipantList",
  roomExpirationWarning: "RoomExpirationWarning",
  setLockState: "SetLockState",
  setMute: "SetMute",
  setMuteAll: "SetMuteAll",
  setProfanityFiltering: "SetProfanityFiltering",
  setTranslateToLanguages: "SetTranslateToLanguages",
  setUseTTS: "SetUseTTS"
};
var tg = {}, La = {};
Object.defineProperty(La, "__esModule", { value: !0 });
La.CommandResponsePayload = void 0;
const iP = (t) => JSON.parse(t);
class xu {
  constructor(e) {
    this.privCommandResponse = iP(e);
  }
  get type() {
    return this.privCommandResponse.type;
  }
  get command() {
    return this.privCommandResponse.command;
  }
  get id() {
    return this.privCommandResponse.id;
  }
  get nickname() {
    return this.privCommandResponse.nickname;
  }
  get participantId() {
    return this.privCommandResponse.participantId;
  }
  get roomid() {
    return this.privCommandResponse.roomid;
  }
  get value() {
    return this.privCommandResponse.value;
  }
  get token() {
    return this.privCommandResponse.token;
  }
  static fromJSON(e) {
    return new xu(e);
  }
}
La.CommandResponsePayload = xu;
var $n = {};
Object.defineProperty($n, "__esModule", { value: !0 });
$n.ParticipantPayloadResponse = $n.ParticipantsListPayloadResponse = void 0;
const sP = (t) => JSON.parse(t), oP = (t) => JSON.parse(t);
class Bu {
  constructor(e) {
    this.privParticipantsPayloadResponse = sP(e);
  }
  get roomid() {
    return this.privParticipantsPayloadResponse.roomid;
  }
  get id() {
    return this.privParticipantsPayloadResponse.id;
  }
  get command() {
    return this.privParticipantsPayloadResponse.command;
  }
  get participants() {
    return this.privParticipantsPayloadResponse.participants;
  }
  get token() {
    return this.privParticipantsPayloadResponse.token;
  }
  get translateTo() {
    return this.privParticipantsPayloadResponse.translateTo;
  }
  get profanityFilter() {
    return this.privParticipantsPayloadResponse.profanityFilter;
  }
  get roomProfanityFilter() {
    return this.privParticipantsPayloadResponse.roomProfanityFilter;
  }
  get roomLocked() {
    return this.privParticipantsPayloadResponse.roomLocked;
  }
  get muteAll() {
    return this.privParticipantsPayloadResponse.muteAll;
  }
  get type() {
    return this.privParticipantsPayloadResponse.type;
  }
  static fromJSON(e) {
    return new Bu(e);
  }
}
$n.ParticipantsListPayloadResponse = Bu;
class qu {
  constructor(e) {
    this.privParticipantPayloadResponse = oP(e);
  }
  get nickname() {
    return this.privParticipantPayloadResponse.nickname;
  }
  get locale() {
    return this.privParticipantPayloadResponse.locale;
  }
  get usetts() {
    return this.privParticipantPayloadResponse.usetts;
  }
  get ismuted() {
    return this.privParticipantPayloadResponse.ismuted;
  }
  get ishost() {
    return this.privParticipantPayloadResponse.ishost;
  }
  get participantId() {
    return this.privParticipantPayloadResponse.participantId;
  }
  get avatar() {
    return this.privParticipantPayloadResponse.avatar;
  }
  static fromJSON(e) {
    return new qu(e);
  }
}
$n.ParticipantPayloadResponse = qu;
var Un = {};
Object.defineProperty(Un, "__esModule", { value: !0 });
Un.TextResponsePayload = Un.SpeechResponsePayload = void 0;
const aP = (t) => JSON.parse(t), cP = (t) => JSON.parse(t);
class Fu {
  constructor(e) {
    this.privSpeechResponse = aP(e);
  }
  get recognition() {
    return this.privSpeechResponse.recognition;
  }
  get translations() {
    return this.privSpeechResponse.translations;
  }
  get id() {
    return this.privSpeechResponse.id;
  }
  get language() {
    return this.privSpeechResponse.language;
  }
  get nickname() {
    return this.privSpeechResponse.nickname;
  }
  get participantId() {
    return this.privSpeechResponse.participantId;
  }
  get roomid() {
    return this.privSpeechResponse.roomid;
  }
  get timestamp() {
    return this.privSpeechResponse.timestamp;
  }
  get type() {
    return this.privSpeechResponse.type;
  }
  get isFinal() {
    return this.privSpeechResponse.type === "final";
  }
  static fromJSON(e) {
    return new Fu(e);
  }
}
Un.SpeechResponsePayload = Fu;
class $u {
  constructor(e) {
    this.privTextResponse = cP(e);
  }
  get originalText() {
    return this.privTextResponse.originalText;
  }
  get translations() {
    return this.privTextResponse.translations;
  }
  get id() {
    return this.privTextResponse.id;
  }
  get language() {
    return this.privTextResponse.language;
  }
  get nickname() {
    return this.privTextResponse.nickname;
  }
  get participantId() {
    return this.privTextResponse.participantId;
  }
  get roomid() {
    return this.privTextResponse.roomid;
  }
  get timestamp() {
    return this.privTextResponse.timestamp;
  }
  get type() {
    return this.privTextResponse.type;
  }
  static fromJSON(e) {
    return new $u(e);
  }
}
Un.TextResponsePayload = $u;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = La;
  Object.defineProperty(t, "CommandResponsePayload", { enumerable: !0, get: function() {
    return e.CommandResponsePayload;
  } });
  var n = $n;
  Object.defineProperty(t, "ParticipantsListPayloadResponse", { enumerable: !0, get: function() {
    return n.ParticipantsListPayloadResponse;
  } }), Object.defineProperty(t, "ParticipantPayloadResponse", { enumerable: !0, get: function() {
    return n.ParticipantPayloadResponse;
  } });
  var r = Un;
  Object.defineProperty(t, "SpeechResponsePayload", { enumerable: !0, get: function() {
    return r.SpeechResponsePayload;
  } }), Object.defineProperty(t, "TextResponsePayload", { enumerable: !0, get: function() {
    return r.TextResponsePayload;
  } });
})(tg);
var Ll;
function uP() {
  if (Ll)
    return xi;
  Ll = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.ConversationServiceAdapter = void 0;
  const t = O(), e = P(), n = b(), r = Rs, s = Na, o = eg(), a = _t, i = tg;
  let c = class extends n.ServiceRecognizerBase {
    constructor(p, d, l, h, v) {
      super(p, d, l, h, v), this.privConnectionConfigPromise = void 0, this.privLastPartialUtteranceId = "", this.privConversationServiceConnector = v, this.privConversationAuthentication = p, this.receiveMessageOverride = () => this.receiveConversationMessageOverride(), this.recognizeOverride = () => this.noOp(), this.postConnectImplOverride = (g) => this.conversationConnectImpl(g), this.configConnectionOverride = () => this.configConnection(), this.disconnectOverride = () => this.privDisconnect(), this.privConversationRequestSession = new s.ConversationRequestSession(t.createNoDashGuid()), this.privConversationConnectionFactory = d, this.privConversationIsDisposed = !1;
    }
    isDisposed() {
      return super.isDisposed() || this.privConversationIsDisposed;
    }
    async dispose(p) {
      this.privConversationIsDisposed = !0, this.privConnectionConfigPromise !== void 0 && await (await this.privConnectionConfigPromise).dispose(p), await super.dispose(p);
    }
    async sendMessage(p) {
      return (await this.fetchConnection()).send(new r.ConversationConnectionMessage(t.MessageType.Text, p));
    }
    async sendMessageAsync(p) {
      await (await this.fetchConnection()).send(new r.ConversationConnectionMessage(t.MessageType.Text, p));
    }
    privDisconnect() {
      if (!this.terminateMessageLoop)
        return this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, e.CancellationReason.Error, e.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processTypeSpecificMessages() {
      return !0;
    }
    // Cancels recognition.
    cancelRecognition(p, d, l, h, v) {
      this.terminateMessageLoop = !0;
      const g = new e.ConversationTranslationCanceledEventArgs(l, v, h, void 0, p);
      try {
        this.privConversationServiceConnector.canceled && this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, g);
      } catch {
      }
    }
    /**
     * Establishes a websocket connection to the end point.
     */
    async conversationConnectImpl(p) {
      return this.privConnectionLoop = this.startMessageLoop(), p;
    }
    /**
     * Process incoming websocket messages
     */
    async receiveConversationMessageOverride() {
      if (this.isDisposed() || this.terminateMessageLoop)
        return Promise.resolve();
      const p = new t.Deferred();
      try {
        const l = await (await this.fetchConnection()).read();
        if (this.isDisposed() || this.terminateMessageLoop)
          return p.resolve(), Promise.resolve();
        if (!l)
          return this.receiveConversationMessageOverride();
        const h = this.privConversationRequestSession.sessionId, v = l.conversationMessageType.toLowerCase();
        let g = !1;
        try {
          switch (v) {
            case "info":
            case "participant_command":
            case "command":
              const f = i.CommandResponsePayload.fromJSON(l.textBody);
              switch (f.command.toLowerCase()) {
                case "participantlist":
                  const C = i.ParticipantsListPayloadResponse.fromJSON(l.textBody), R = C.participants.map((J) => ({
                    avatar: J.avatar,
                    displayName: J.nickname,
                    id: J.participantId,
                    isHost: J.ishost,
                    isMuted: J.ismuted,
                    isUsingTts: J.usetts,
                    preferredLanguage: J.locale
                  }));
                  this.privConversationServiceConnector.participantsListReceived && this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new o.ParticipantsListEventArgs(C.roomid, C.token, C.translateTo, C.profanityFilter, C.roomProfanityFilter, C.roomLocked, C.muteAll, R, h));
                  break;
                case "settranslatetolanguages":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setTranslateToLanguages, f.value, h));
                  break;
                case "setprofanityfiltering":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setProfanityFiltering, f.value, h));
                  break;
                case "setmute":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setMute, f.value, h));
                  break;
                case "setmuteall":
                  this.privConversationServiceConnector.muteAllCommandReceived && this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new o.MuteAllEventArgs(f.value, h));
                  break;
                case "roomexpirationwarning":
                  this.privConversationServiceConnector.conversationExpiration && this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new e.ConversationExpirationEventArgs(f.value, this.privConversationRequestSession.sessionId));
                  break;
                case "setusetts":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setUseTTS, f.value, h));
                  break;
                case "setlockstate":
                  this.privConversationServiceConnector.lockRoomCommandReceived && this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new o.LockRoomEventArgs(f.value, h));
                  break;
                case "changenickname":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.changeNickname, f.value, h));
                  break;
                case "joinsession":
                  const T = i.ParticipantPayloadResponse.fromJSON(l.textBody), A = {
                    avatar: T.avatar,
                    displayName: T.nickname,
                    id: T.participantId,
                    isHost: T.ishost,
                    isMuted: T.ismuted,
                    isUsingTts: T.usetts,
                    preferredLanguage: T.locale
                  };
                  this.privConversationServiceConnector.participantJoinCommandReceived && this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new o.ParticipantEventArgs(A, h));
                  break;
                case "leavesession":
                  const U = {
                    id: f.participantId
                  };
                  this.privConversationServiceConnector.participantLeaveCommandReceived && this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new o.ParticipantEventArgs(U, h));
                  break;
                case "disconnectsession":
                  const K = {
                    id: f.participantId
                  };
                  break;
                case "token":
                  const Y = new n.CognitiveTokenAuthentication(() => {
                    const J = f.token;
                    return Promise.resolve(J);
                  }, () => {
                    const J = f.token;
                    return Promise.resolve(J);
                  });
                  this.authentication = Y, this.privConversationServiceConnector.onToken(Y);
                  break;
                default:
                  break;
              }
              break;
            case "partial":
            case "final":
              const m = i.SpeechResponsePayload.fromJSON(l.textBody), S = v === "final" ? e.ResultReason.TranslatedParticipantSpeech : e.ResultReason.TranslatingParticipantSpeech, y = new e.ConversationTranslationResult(m.participantId, this.getTranslations(m.translations), m.language, m.id, S, m.recognition, void 0, void 0, l.textBody, void 0);
              m.isFinal ? ((y.text !== void 0 && y.text.length > 0 || m.id === this.privLastPartialUtteranceId) && (g = !0), g && this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new o.ConversationReceivedTranslationEventArgs(a.ConversationTranslatorMessageTypes.final, y, h))) : y.text !== void 0 && (this.privLastPartialUtteranceId = m.id, this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new o.ConversationReceivedTranslationEventArgs(a.ConversationTranslatorMessageTypes.partial, y, h)));
              break;
            case "translated_message":
              const E = i.TextResponsePayload.fromJSON(l.textBody), _ = new e.ConversationTranslationResult(E.participantId, this.getTranslations(E.translations), E.language, void 0, void 0, E.originalText, void 0, void 0, void 0, l.textBody, void 0);
              this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new o.ConversationReceivedTranslationEventArgs(a.ConversationTranslatorMessageTypes.instantMessage, _, h));
              break;
            default:
              break;
          }
        } catch {
        }
        return this.receiveConversationMessageOverride();
      } catch {
        this.terminateMessageLoop = !0;
      }
      return p.promise;
    }
    async startMessageLoop() {
      if (this.isDisposed())
        return Promise.resolve();
      this.terminateMessageLoop = !1;
      const p = this.receiveConversationMessageOverride();
      try {
        return await p;
      } catch (d) {
        return this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", e.CancellationReason.Error, e.CancellationErrorCode.RuntimeError, d), null;
      }
    }
    // Takes an established websocket connection to the endpoint
    configConnection() {
      return this.isDisposed() ? Promise.resolve(void 0) : this.privConnectionConfigPromise !== void 0 ? this.privConnectionConfigPromise.then((p) => p.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection()) : this.privConnectionConfigPromise, () => (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection())) : this.terminateMessageLoop ? Promise.resolve(void 0) : (this.privConnectionConfigPromise = this.connectImpl().then((p) => p), this.privConnectionConfigPromise);
    }
    getTranslations(p) {
      let d;
      if (p !== void 0) {
        d = new e.Translations();
        for (const l of p)
          d.set(l.lang, l.translation);
      }
      return d;
    }
  };
  return xi.ConversationServiceAdapter = c, xi;
}
var zl;
function pP() {
  if (zl)
    return an;
  zl = 1, Object.defineProperty(an, "__esModule", { value: !0 }), an.ConversationTranslatorRecognizer = an.ConversationRecognizerFactory = void 0;
  const t = b(), e = O(), n = D, r = P(), s = tP(), o = uP();
  class a {
    static fromConfig(u, p, d) {
      return new i(u, p, d);
    }
  }
  an.ConversationRecognizerFactory = a;
  let i = class extends r.Recognizer {
    constructor(u, p, d) {
      const l = p;
      n.Contracts.throwIfNull(l, "speechConfig");
      const h = u;
      n.Contracts.throwIfNull(h, "conversationImpl"), super(d, l.properties, new s.ConversationConnectionFactory()), this.privConversation = h, this.privIsDisposed = !1, this.privProperties = l.properties.clone(), this.privConnection = r.Connection.fromRecognizer(this), this.privProperties.getProperty(r.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? (this.privSetTimeout = e.Timeout.setTimeout, this.privClearTimeout = e.Timeout.clearTimeout) : typeof window < "u" ? (this.privSetTimeout = window.setTimeout.bind(window), this.privClearTimeout = window.clearTimeout.bind(window)) : (this.privSetTimeout = setTimeout, this.privClearTimeout = clearTimeout);
    }
    set connected(u) {
      this.privConnection.connected = u;
    }
    set disconnected(u) {
      this.privConnection.disconnected = u;
    }
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage() {
      return this.privSpeechRecognitionLanguage;
    }
    /**
     * Return the properties for the recognizer
     */
    get properties() {
      return this.privProperties;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(u, p, d) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfNullOrWhitespace(u, "token"), this.privReco.conversationTranslatorToken = u, this.resetConversationTimeout(), this.privReco.connectAsync(p, d);
      } catch (l) {
        if (d)
          if (l instanceof Error) {
            const h = l;
            d(h.name + ": " + h.message);
          } else
            d(l);
      }
    }
    /**
     * Disconnect from the recognizer
     */
    disconnect(u, p) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privReco.disconnect().then(() => {
          u && u();
        }, (d) => {
          p && p(d);
        });
      } catch (d) {
        if (p)
          if (d instanceof Error) {
            const l = d;
            p(l.name + ": " + l.message);
          } else
            p(d);
        this.dispose(!0).catch((l) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(l));
        });
      }
    }
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendRequest(u, p, d) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), this.sendMessage(u, p, d);
      } catch (l) {
        if (d)
          if (l instanceof Error) {
            const h = l;
            d(h.name + ": " + h.message);
          } else
            d(l);
        this.dispose(!0).catch((h) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(h));
        });
      }
    }
    /**
     * Handle update of service auth token (#694)
     */
    onToken(u) {
      this.privConversation.onToken(u);
    }
    /**
     * Close and dispose the recognizer
     */
    async close() {
      this.privIsDisposed || (this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close()), this.privConnection = void 0, await this.dispose(!0));
    }
    /**
     * Dispose the recognizer
     * @param disposing
     */
    async dispose(u) {
      this.privIsDisposed || u && (this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privIsDisposed = !0, this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close(), this.privConnection = void 0), await super.dispose(u));
    }
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    createRecognizerConfig(u) {
      return new t.RecognizerConfig(u, this.privProperties);
    }
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    createServiceRecognizer(u, p, d, l) {
      const h = d;
      return new o.ConversationServiceAdapter(u, p, h, l, this);
    }
    sendMessage(u, p, d) {
      const l = this.privReco;
      ((v, g, f) => {
        v !== void 0 ? v.then(() => {
          try {
            g && g();
          } catch (m) {
            f && f(`'Unhandled error on promise callback: ${m}'`);
          }
        }, (m) => {
          try {
            f && f(m);
          } catch {
          }
        }) : f && f("Null promise");
      })(l.sendMessageAsync(u), p, d), this.resetConversationTimeout();
    }
    resetConversationTimeout() {
      this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privTimeoutToken = this.privSetTimeout(() => {
        this.sendRequest(this.privConversation.getKeepAlive());
      }, 6e4);
    }
  };
  return an.ConversationTranslatorRecognizer = i, an;
}
var Bi = {}, jl;
function dP() {
  if (jl)
    return Bi;
  jl = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.TranscriberRecognizer = void 0;
  const t = O(), e = D, n = P(), r = b();
  let s = class extends n.Recognizer {
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */
    constructor(a, i) {
      const c = a;
      e.Contracts.throwIfNull(c, "speechTranslationConfig");
      const u = i;
      e.Contracts.throwIfNull(u, "audioConfigImpl"), e.Contracts.throwIfNullOrWhitespace(c.speechRecognitionLanguage, n.PropertyId[n.PropertyId.SpeechServiceConnection_RecoLanguage]), super(i, c.properties, new r.TranscriberConnectionFactory()), this.privDisposedRecognizer = !1, this.isMeetingRecognizer = !1;
    }
    get speechRecognitionLanguage() {
      return e.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    get properties() {
      return this.privProperties;
    }
    get authorizationToken() {
      return this.properties.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    set conversation(a) {
      e.Contracts.throwIfNullOrUndefined(a, "Conversation"), this.isMeetingRecognizer = !1, this.privConversation = a;
    }
    getConversationInfo() {
      return e.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation"), this.privConversation.conversationInfo;
    }
    set meeting(a) {
      e.Contracts.throwIfNullOrUndefined(a, "Meeting"), this.isMeetingRecognizer = !0, this.privMeeting = a;
    }
    getMeetingInfo() {
      return e.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting"), this.privMeeting.meetingInfo;
    }
    IsMeetingRecognizer() {
      return this.isMeetingRecognizer;
    }
    startContinuousRecognitionAsync(a, i) {
      t.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(r.RecognitionMode.Conversation), a, i);
    }
    stopContinuousRecognitionAsync(a, i) {
      t.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    async close() {
      this.privDisposedRecognizer || await this.dispose(!0);
    }
    // Push async join/leave conversation message via serviceRecognizer
    async pushConversationEvent(a, i) {
      const c = this.privReco;
      e.Contracts.throwIfNullOrUndefined(c, "serviceRecognizer"), await c.sendSpeechEventAsync(a, i);
    }
    // Push async join/leave meeting message via serviceRecognizer
    async pushMeetingEvent(a, i) {
      const c = this.privReco;
      e.Contracts.throwIfNullOrUndefined(c, "serviceRecognizer"), await c.sendMeetingSpeechEventAsync(a, i);
    }
    async enforceAudioGating() {
      const c = (await this.audioConfig.format).channels;
      if (c === 1) {
        if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true")
          throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
      } else if (c !== 8)
        throw new Error(`Unsupported audio configuration: Detected ${c}-channel audio`);
    }
    connectMeetingCallbacks(a) {
      this.isMeetingRecognizer = !0, this.canceled = (i, c) => {
        a.canceled && a.canceled(a, c);
      }, this.recognizing = (i, c) => {
        a.transcribing && a.transcribing(a, c);
      }, this.recognized = (i, c) => {
        a.transcribed && a.transcribed(a, c);
      }, this.sessionStarted = (i, c) => {
        a.sessionStarted && a.sessionStarted(a, c);
      }, this.sessionStopped = (i, c) => {
        a.sessionStopped && a.sessionStopped(a, c);
      };
    }
    disconnectCallbacks() {
      this.canceled = void 0, this.recognizing = void 0, this.recognized = void 0, this.sessionStarted = void 0, this.sessionStopped = void 0;
    }
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(a) {
      this.privDisposedRecognizer || (a && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new r.RecognizerConfig(a, this.properties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new r.TranscriptionServiceRecognizer(a, i, p, u, this);
    }
  };
  return Bi.TranscriberRecognizer = s, Bi;
}
var xl;
function lP() {
  return xl || (xl = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = YR();
    Object.defineProperty(t, "ConversationManager", { enumerable: !0, get: function() {
      return e.ConversationManager;
    } });
    var n = tr;
    Object.defineProperty(t, "ConversationConnectionConfig", { enumerable: !0, get: function() {
      return n.ConversationConnectionConfig;
    } });
    var r = pP();
    Object.defineProperty(t, "ConversationRecognizerFactory", { enumerable: !0, get: function() {
      return r.ConversationRecognizerFactory;
    } });
    var s = dP();
    Object.defineProperty(t, "TranscriberRecognizer", { enumerable: !0, get: function() {
      return s.TranscriberRecognizer;
    } });
    var o = eg();
    Object.defineProperty(t, "ConversationReceivedTranslationEventArgs", { enumerable: !0, get: function() {
      return o.ConversationReceivedTranslationEventArgs;
    } }), Object.defineProperty(t, "LockRoomEventArgs", { enumerable: !0, get: function() {
      return o.LockRoomEventArgs;
    } }), Object.defineProperty(t, "MuteAllEventArgs", { enumerable: !0, get: function() {
      return o.MuteAllEventArgs;
    } }), Object.defineProperty(t, "ParticipantAttributeEventArgs", { enumerable: !0, get: function() {
      return o.ParticipantAttributeEventArgs;
    } }), Object.defineProperty(t, "ParticipantEventArgs", { enumerable: !0, get: function() {
      return o.ParticipantEventArgs;
    } }), Object.defineProperty(t, "ParticipantsListEventArgs", { enumerable: !0, get: function() {
      return o.ParticipantsListEventArgs;
    } });
    var a = _t;
    Object.defineProperty(t, "ConversationTranslatorCommandTypes", { enumerable: !0, get: function() {
      return a.ConversationTranslatorCommandTypes;
    } }), Object.defineProperty(t, "ConversationTranslatorMessageTypes", { enumerable: !0, get: function() {
      return a.ConversationTranslatorMessageTypes;
    } }), Object.defineProperty(t, "InternalParticipants", { enumerable: !0, get: function() {
      return a.InternalParticipants;
    } });
  }(mc)), mc;
}
var Uu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.SynthesisAudioMetadata = t.MetadataType = void 0, function(n) {
    n.WordBoundary = "WordBoundary", n.Bookmark = "Bookmark", n.Viseme = "Viseme", n.SentenceBoundary = "SentenceBoundary", n.SessionEnd = "SessionEnd", n.AvatarSignal = "TalkingAvatarSignal";
  }(t.MetadataType || (t.MetadataType = {}));
  class e {
    constructor(r) {
      this.privSynthesisAudioMetadata = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get Metadata() {
      return this.privSynthesisAudioMetadata.Metadata;
    }
  }
  t.SynthesisAudioMetadata = e;
})(Uu);
var qi = {}, dt = {};
Object.defineProperty(dt, "__esModule", { value: !0 });
dt.SynthesisStartedEvent = dt.ConnectingToSynthesisServiceEvent = dt.SynthesisTriggeredEvent = dt.SpeechSynthesisEvent = void 0;
const Bl = O();
class za extends Bl.PlatformEvent {
  constructor(e, n, r = Bl.EventType.Info) {
    super(e, r), this.privRequestId = n;
  }
  get requestId() {
    return this.privRequestId;
  }
}
dt.SpeechSynthesisEvent = za;
class hP extends za {
  constructor(e, n, r) {
    super("SynthesisTriggeredEvent", e), this.privSessionAudioDestinationId = n, this.privTurnAudioDestinationId = r;
  }
  get audioSessionDestinationId() {
    return this.privSessionAudioDestinationId;
  }
  get audioTurnDestinationId() {
    return this.privTurnAudioDestinationId;
  }
}
dt.SynthesisTriggeredEvent = hP;
class vP extends za {
  constructor(e, n) {
    super("ConnectingToSynthesisServiceEvent", e), this.privAuthFetchEventId = n;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
dt.ConnectingToSynthesisServiceEvent = vP;
class fP extends za {
  constructor(e, n) {
    super("SynthesisStartedEvent", e), this.privAuthFetchEventId = n;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
dt.SynthesisStartedEvent = fP;
var ql;
function gP() {
  if (ql)
    return qi;
  ql = 1, Object.defineProperty(qi, "__esModule", { value: !0 }), qi.SynthesisTurn = void 0;
  const t = O(), e = Re, n = P(), r = Uu, s = dt;
  let o = class Fc {
    constructor() {
      this.privIsDisposed = !1, this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !1, this.privBytesReceived = 0, this.privInTurn = !1, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privRequestId = t.createNoDashGuid(), this.privTurnDeferral = new t.Deferred(), this.privTurnDeferral.resolve();
    }
    get requestId() {
      return this.privRequestId;
    }
    get streamId() {
      return this.privStreamId;
    }
    set streamId(i) {
      this.privStreamId = i;
    }
    get audioOutputFormat() {
      return this.privAudioOutputFormat;
    }
    set audioOutputFormat(i) {
      this.privAudioOutputFormat = i;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSynthesisEnded() {
      return this.privIsSynthesisEnded;
    }
    get isSynthesizing() {
      return this.privIsSynthesizing;
    }
    get currentTextOffset() {
      return this.privTextOffset;
    }
    get currentSentenceOffset() {
      return this.privSentenceOffset;
    }
    // The number of bytes received for current turn
    get bytesReceived() {
      return this.privBytesReceived;
    }
    get audioDuration() {
      return this.privAudioDuration;
    }
    get extraProperties() {
      if (this.privWebRTCSDP) {
        const i = new n.PropertyCollection();
        return i.setProperty(n.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP), i;
      }
    }
    async getAllReceivedAudio() {
      return this.privReceivedAudio ? Promise.resolve(this.privReceivedAudio) : this.privIsSynthesisEnded ? (await this.readAllAudioFromStream(), Promise.resolve(this.privReceivedAudio)) : null;
    }
    async getAllReceivedAudioWithHeader() {
      if (this.privReceivedAudioWithHeader)
        return this.privReceivedAudioWithHeader;
      if (!this.privIsSynthesisEnded)
        return null;
      if (this.audioOutputFormat.hasHeader) {
        const i = await this.getAllReceivedAudio();
        return this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(i), this.privReceivedAudioWithHeader;
      } else
        return this.getAllReceivedAudio();
    }
    startNewSynthesis(i, c, u, p) {
      this.privIsSynthesisEnded = !1, this.privIsSynthesizing = !0, this.privRequestId = i, this.privRawText = c, this.privIsSSML = u, this.privAudioOutputStream = new e.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privAudioOutputFormat, this.privReceivedAudio = null, this.privReceivedAudioWithHeader = null, this.privBytesReceived = 0, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privPartialVisemeAnimation = "", this.privWebRTCSDP = "", p !== void 0 && (this.privTurnAudioDestination = p, this.privTurnAudioDestination.format = this.privAudioOutputFormat), this.onEvent(new s.SynthesisTriggeredEvent(this.requestId, void 0, p === void 0 ? void 0 : p.id()));
    }
    onPreConnectionStart(i) {
      this.privAuthFetchEventId = i, this.onEvent(new s.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    }
    onAuthCompleted(i) {
      i && this.onComplete();
    }
    onConnectionEstablishCompleted(i) {
      if (i === 200) {
        this.onEvent(new s.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId)), this.privBytesReceived = 0;
        return;
      } else
        i === 403 && this.onComplete();
    }
    onServiceResponseMessage(i) {
      const c = JSON.parse(i);
      this.streamId = c.audio.streamId;
    }
    onServiceTurnEndResponse() {
      this.privInTurn = !1, this.privTurnDeferral.resolve(), this.onComplete();
    }
    onServiceTurnStartResponse(i) {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new t.Deferred();
      const c = JSON.parse(i);
      c.webrtc && (this.privWebRTCSDP = c.webrtc.connectionString);
    }
    onAudioChunkReceived(i) {
      this.isSynthesizing && (this.privAudioOutputStream.write(i), this.privBytesReceived += i.byteLength, this.privTurnAudioDestination !== void 0 && this.privTurnAudioDestination.write(i));
    }
    onTextBoundaryEvent(i) {
      this.updateTextOffset(i.Data.text.Text, i.Type);
    }
    onVisemeMetadataReceived(i) {
      i.Data.AnimationChunk !== void 0 && (this.privPartialVisemeAnimation += i.Data.AnimationChunk);
    }
    onSessionEnd(i) {
      this.privAudioDuration = i.Data.Offset;
    }
    async constructSynthesisResult() {
      const i = await this.getAllReceivedAudioWithHeader();
      return new n.SpeechSynthesisResult(this.requestId, n.ResultReason.SynthesizingAudioCompleted, i, void 0, this.extraProperties, this.audioDuration);
    }
    dispose() {
      this.privIsDisposed || (this.privIsDisposed = !0);
    }
    onStopSynthesizing() {
      this.onComplete();
    }
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */
    getAndClearVisemeAnimation() {
      const i = this.privPartialVisemeAnimation;
      return this.privPartialVisemeAnimation = "", i;
    }
    onEvent(i) {
      t.Events.instance.onEvent(i);
    }
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */
    static isXmlTag(i) {
      return i.length >= 2 && i[0] === "<" && i[i.length - 1] === ">";
    }
    updateTextOffset(i, c) {
      c === r.MetadataType.WordBoundary ? (this.privTextOffset = this.privRawText.indexOf(i, this.privNextSearchTextIndex), this.privTextOffset >= 0 && (this.privNextSearchTextIndex = this.privTextOffset + i.length, this.privIsSSML && this.withinXmlTag(this.privTextOffset) && !Fc.isXmlTag(i) && this.updateTextOffset(i, c))) : (this.privSentenceOffset = this.privRawText.indexOf(i, this.privNextSearchSentenceIndex), this.privSentenceOffset >= 0 && (this.privNextSearchSentenceIndex = this.privSentenceOffset + i.length, this.privIsSSML && this.withinXmlTag(this.privSentenceOffset) && !Fc.isXmlTag(i) && this.updateTextOffset(i, c)));
    }
    onComplete() {
      this.privIsSynthesizing && (this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !0, this.privAudioOutputStream.close(), this.privInTurn = !1, this.privTurnAudioDestination !== void 0 && (this.privTurnAudioDestination.close(), this.privTurnAudioDestination = void 0));
    }
    async readAllAudioFromStream() {
      if (this.privIsSynthesisEnded) {
        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
        try {
          await this.privAudioOutputStream.read(this.privReceivedAudio);
        } catch {
          this.privReceivedAudio = new ArrayBuffer(0);
        }
      }
    }
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */
    withinXmlTag(i) {
      return this.privRawText.indexOf("<", i + 1) > this.privRawText.indexOf(">", i + 1);
    }
  };
  return qi.SynthesisTurn = o, qi;
}
var Fi = {}, Fl;
function mP() {
  if (Fl)
    return Fi;
  Fl = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.SynthesisAdapterBase = void 0;
  const t = O(), e = P(), n = b(), r = Tt;
  let s = class {
    constructor(a, i, c, u) {
      if (this.speakOverride = void 0, this.receiveMessageOverride = void 0, this.connectImplOverride = void 0, this.configConnectionOverride = void 0, this.privConnectionConfigurationPromise = void 0, !a)
        throw new t.ArgumentNullError("authentication");
      if (!i)
        throw new t.ArgumentNullError("connectionFactory");
      if (!c)
        throw new t.ArgumentNullError("synthesizerConfig");
      this.privAuthentication = a, this.privConnectionFactory = i, this.privSynthesizerConfig = c, this.privIsDisposed = !1, this.privSessionAudioDestination = u, this.privSynthesisTurn = new n.SynthesisTurn(), this.privConnectionEvents = new t.EventSource(), this.privServiceEvents = new t.EventSource(), this.privSynthesisContext = new n.SynthesisContext(), this.privAgentConfig = new n.AgentConfig(), this.connectionEvents.attach((p) => {
        if (p.name === "ConnectionClosedEvent") {
          const d = p;
          d.statusCode !== 1e3 && this.cancelSynthesisLocal(e.CancellationReason.Error, d.statusCode === 1007 ? e.CancellationErrorCode.BadRequestParameters : e.CancellationErrorCode.ConnectionFailure, `${d.reason} websocket error code: ${d.statusCode}`);
        }
      });
    }
    get synthesisContext() {
      return this.privSynthesisContext;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    set activityTemplate(a) {
      this.privActivityTemplate = a;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set audioOutputFormat(a) {
      this.privAudioOutputFormat = a, this.privSynthesisTurn.audioOutputFormat = a, this.privSessionAudioDestination !== void 0 && (this.privSessionAudioDestination.format = a), this.synthesisContext !== void 0 && (this.synthesisContext.audioOutputFormat = a);
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(a) {
      this.privIsDisposed = !0, this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.close(), this.privConnectionConfigurationPromise !== void 0 && await (await this.privConnectionConfigurationPromise).dispose(a);
    }
    async connect() {
      await this.connectImpl();
    }
    async sendNetworkMessage(a, i) {
      const c = typeof i == "string" ? t.MessageType.Text : t.MessageType.Binary, u = typeof i == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new r.SpeechConnectionMessage(c, a, this.privSynthesisTurn.requestId, u, i));
    }
    async Speak(a, i, c, u, p, d) {
      let l;
      if (i ? l = a : l = this.privSynthesizer.buildSsml(a), this.speakOverride !== void 0)
        return this.speakOverride(l, c, u, p);
      this.privSuccessCallback = u, this.privErrorCallback = p, this.privSynthesisTurn.startNewSynthesis(c, a, i, d);
      try {
        await this.connectImpl();
        const h = await this.fetchConnection();
        await this.sendSynthesisContext(h), await this.sendSsmlMessage(h, l, c), this.onSynthesisStarted(c), this.receiveMessage();
      } catch (h) {
        return this.cancelSynthesisLocal(e.CancellationReason.Error, e.CancellationErrorCode.ConnectionFailure, h), Promise.reject(h);
      }
    }
    async stopSpeaking() {
      return await this.connectImpl(), (await this.fetchConnection()).send(new r.SpeechConnectionMessage(t.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
        action: "stop"
      })));
    }
    // Cancels synthesis.
    cancelSynthesis(a, i, c, u) {
      const p = new e.PropertyCollection();
      p.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[c]);
      const d = new e.SpeechSynthesisResult(a, e.ResultReason.Canceled, void 0, u, p);
      if (this.onSynthesisCancelled(d), this.privSuccessCallback)
        try {
          this.privSuccessCallback(d);
        } catch {
        }
    }
    // Cancels synthesis.
    cancelSynthesisLocal(a, i, c) {
      this.privSynthesisTurn.isSynthesizing && (this.privSynthesisTurn.onStopSynthesizing(), this.cancelSynthesis(this.privSynthesisTurn.requestId, a, i, c));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processTypeSpecificMessages(a) {
      return !0;
    }
    async receiveMessage() {
      try {
        const i = await (await this.fetchConnection()).read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (this.privIsDisposed)
          return;
        if (!i)
          return this.privSynthesisTurn.isSynthesizing ? this.receiveMessage() : void 0;
        const c = r.SpeechConnectionMessage.fromConnectionMessage(i);
        if (c.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase())
          switch (c.path.toLowerCase()) {
            case "turn.start":
              this.privSynthesisTurn.onServiceTurnStartResponse(c.textBody);
              break;
            case "response":
              this.privSynthesisTurn.onServiceResponseMessage(c.textBody);
              break;
            case "audio":
              this.privSynthesisTurn.streamId.toLowerCase() === c.streamId.toLowerCase() && c.binaryBody && (this.privSynthesisTurn.onAudioChunkReceived(c.binaryBody), this.onSynthesizing(c.binaryBody), this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.write(c.binaryBody));
              break;
            case "audio.metadata":
              const u = n.SynthesisAudioMetadata.fromJSON(c.textBody).Metadata;
              for (const d of u)
                switch (d.Type) {
                  case n.MetadataType.WordBoundary:
                  case n.MetadataType.SentenceBoundary:
                    this.privSynthesisTurn.onTextBoundaryEvent(d);
                    const l = new e.SpeechSynthesisWordBoundaryEventArgs(d.Data.Offset, d.Data.Duration, d.Data.text.Text, d.Data.text.Length, d.Type === n.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, d.Data.text.BoundaryType);
                    this.onWordBoundary(l);
                    break;
                  case n.MetadataType.Bookmark:
                    const h = new e.SpeechSynthesisBookmarkEventArgs(d.Data.Offset, d.Data.Bookmark);
                    this.onBookmarkReached(h);
                    break;
                  case n.MetadataType.Viseme:
                    if (this.privSynthesisTurn.onVisemeMetadataReceived(d), d.Data.IsLastAnimation) {
                      const v = new e.SpeechSynthesisVisemeEventArgs(d.Data.Offset, d.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                      this.onVisemeReceived(v);
                    }
                    break;
                  case n.MetadataType.AvatarSignal:
                    this.onAvatarEvent(d);
                    break;
                  case n.MetadataType.SessionEnd:
                    this.privSynthesisTurn.onSessionEnd(d);
                    break;
                }
              break;
            case "turn.end":
              this.privSynthesisTurn.onServiceTurnEndResponse();
              let p;
              try {
                p = await this.privSynthesisTurn.constructSynthesisResult(), this.privSuccessCallback && this.privSuccessCallback(p);
              } catch (d) {
                this.privErrorCallback && this.privErrorCallback(d);
              }
              this.onSynthesisCompleted(p);
              break;
            default:
              this.processTypeSpecificMessages(c) || this.privServiceEvents && this.serviceEvents.onEvent(new t.ServiceEvent(c.path.toLowerCase(), c.textBody));
          }
        return this.receiveMessage();
      } catch {
      }
    }
    sendSynthesisContext(a) {
      this.setSynthesisContextSynthesisSection();
      const i = this.synthesisContext.toJSON();
      if (i)
        return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", i));
    }
    setSpeechConfigSynthesisSection() {
    }
    connectImpl(a = !1) {
      if (this.privConnectionPromise != null)
        return this.privConnectionPromise.then((c) => c.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()));
      this.privAuthFetchEventId = t.createNoDashGuid(), this.privConnectionId = t.createNoDashGuid(), this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
      const i = a ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      return this.privConnectionPromise = i.then(async (c) => {
        this.privSynthesisTurn.onAuthCompleted(!1);
        const u = this.privConnectionFactory.create(this.privSynthesizerConfig, c, this.privConnectionId);
        u.events.attach((d) => {
          this.connectionEvents.onEvent(d);
        });
        const p = await u.open();
        return p.statusCode === 200 ? (this.privSynthesisTurn.onConnectionEstablishCompleted(p.statusCode), Promise.resolve(u)) : p.statusCode === 403 && !a ? this.connectImpl(!0) : (this.privSynthesisTurn.onConnectionEstablishCompleted(p.statusCode), Promise.reject(`Unable to contact server. StatusCode: ${p.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Url)} Reason: ${p.reason}`));
      }, (c) => {
        throw this.privSynthesisTurn.onAuthCompleted(!0), new Error(c);
      }), this.privConnectionPromise.catch(() => {
      }), this.privConnectionPromise;
    }
    sendSpeechServiceConfig(a, i) {
      if (i)
        return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", i));
    }
    sendSsmlMessage(a, i, c) {
      return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "ssml", c, "application/ssml+xml", i));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((a) => a.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const a = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(a) : (this.setSpeechConfigSynthesisSection(), await this.sendSpeechServiceConfig(a, this.privSynthesizerConfig.SpeechServiceConfig.serialize()), a);
    }
    onAvatarEvent(a) {
    }
    onSynthesisStarted(a) {
    }
    onSynthesizing(a) {
    }
    onSynthesisCancelled(a) {
    }
    onSynthesisCompleted(a) {
    }
    onWordBoundary(a) {
    }
    onVisemeReceived(a) {
    }
    onBookmarkReached(a) {
    }
  };
  return Fi.SynthesisAdapterBase = s, s.telemetryDataEnabled = !0, Fi;
}
var $i = {}, $l;
function SP() {
  if ($l)
    return $i;
  $l = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.AvatarSynthesisAdapter = void 0;
  const t = P(), e = b();
  let n = class extends e.SynthesisAdapterBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, void 0), this.privAvatarSynthesizer = i, this.privSynthesizer = i, this.privAvatarConfig = c;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(void 0);
    }
    setSpeechConfigSynthesisSection() {
      var s, o, a, i, c, u, p, d, l, h, v, g, f, m, S, y, E;
      this.privSynthesizerConfig.synthesisVideoSection = {
        format: {
          bitrate: (s = this.privAvatarConfig.videoFormat) == null ? void 0 : s.bitrate,
          codec: (o = this.privAvatarConfig.videoFormat) == null ? void 0 : o.codec,
          crop: {
            bottomRight: {
              x: (c = (i = (a = this.privAvatarConfig.videoFormat) == null ? void 0 : a.cropRange) == null ? void 0 : i.bottomRight) == null ? void 0 : c.x,
              y: (d = (p = (u = this.privAvatarConfig.videoFormat) == null ? void 0 : u.cropRange) == null ? void 0 : p.bottomRight) == null ? void 0 : d.y
            },
            topLeft: {
              x: (v = (h = (l = this.privAvatarConfig.videoFormat) == null ? void 0 : l.cropRange) == null ? void 0 : h.topLeft) == null ? void 0 : v.x,
              y: (m = (f = (g = this.privAvatarConfig.videoFormat) == null ? void 0 : g.cropRange) == null ? void 0 : f.topLeft) == null ? void 0 : m.y
            }
          },
          resolution: {
            height: (S = this.privAvatarConfig.videoFormat) == null ? void 0 : S.height,
            width: (y = this.privAvatarConfig.videoFormat) == null ? void 0 : y.width
          }
        },
        protocol: {
          name: "WebRTC",
          webrtcConfig: {
            clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(t.PropertyId.TalkingAvatarService_WebRTC_SDP)),
            iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
          }
        },
        talkingAvatar: {
          background: {
            color: this.privAvatarConfig.backgroundColor,
            image: {
              url: (E = this.privAvatarConfig.backgroundImage) == null ? void 0 : E.toString()
            }
          },
          character: this.privAvatarConfig.character,
          customized: this.privAvatarConfig.customized,
          style: this.privAvatarConfig.style
        }
      };
    }
    onAvatarEvent(s) {
      if (this.privAvatarSynthesizer.avatarEventReceived) {
        const o = new t.AvatarEventArgs(s.Data.Offset, s.Data.Name);
        try {
          this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, o);
        } catch {
        }
      }
    }
  };
  return $i.AvatarSynthesisAdapter = n, $i;
}
var Ui = {}, Ul;
function yP() {
  if (Ul)
    return Ui;
  Ul = 1, Object.defineProperty(Ui, "__esModule", { value: !0 }), Ui.SpeechSynthesisAdapter = void 0;
  const t = P(), e = b();
  let n = class extends e.SynthesisAdapterBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, c), this.privSpeechSynthesizer = i, this.privSynthesizer = i;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
    }
    onSynthesisStarted(s) {
      const o = new t.SpeechSynthesisEventArgs(new t.SpeechSynthesisResult(s, t.ResultReason.SynthesizingAudioStarted));
      this.privSpeechSynthesizer.synthesisStarted && this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, o);
    }
    onSynthesizing(s) {
      if (this.privSpeechSynthesizer.synthesizing)
        try {
          const o = this.privSynthesisTurn.audioOutputFormat.addHeader(s), a = new t.SpeechSynthesisEventArgs(new t.SpeechSynthesisResult(this.privSynthesisTurn.requestId, t.ResultReason.SynthesizingAudio, o));
          this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, a);
        } catch {
        }
    }
    onSynthesisCancelled(s) {
      if (this.privSpeechSynthesizer.SynthesisCanceled) {
        const o = new t.SpeechSynthesisEventArgs(s);
        try {
          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, o);
        } catch {
        }
      }
    }
    onSynthesisCompleted(s) {
      if (this.privSpeechSynthesizer.synthesisCompleted)
        try {
          this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new t.SpeechSynthesisEventArgs(s));
        } catch {
        }
    }
    onWordBoundary(s) {
      if (this.privSpeechSynthesizer.wordBoundary)
        try {
          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
    onVisemeReceived(s) {
      if (this.privSpeechSynthesizer.visemeReceived)
        try {
          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
    onBookmarkReached(s) {
      if (this.privSpeechSynthesizer.bookmarkReached)
        try {
          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
  };
  return Ui.SpeechSynthesisAdapter = n, Ui;
}
var Hi = {}, Hl;
function CP() {
  if (Hl)
    return Hi;
  Hl = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.SynthesisRestAdapter = void 0;
  const t = Se(), e = P(), n = ot(), r = me;
  let s = class {
    constructor(a, i) {
      let c = a.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!c) {
        const p = a.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, "westus"), d = n.ConnectionFactoryBase.getHostSuffix(p);
        c = a.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, `https://${p}.tts.speech${d}`);
      }
      this.privUri = `${c}/cognitiveservices/voices/list`;
      const u = t.RestConfigBase.requestOptions;
      this.privRestAdapter = new t.RestMessageAdapter(u), this.privAuthentication = i;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */
    getVoicesList(a) {
      return this.privRestAdapter.setHeaders(r.HeaderNames.ConnectionId, a), this.privAuthentication.fetch(a).then((i) => (this.privRestAdapter.setHeaders(i.headerName, i.token), this.privRestAdapter.request(t.RestRequestType.Get, this.privUri)));
    }
  };
  return Hi.SynthesisRestAdapter = s, Hi;
}
var yc = {}, Wl;
function _P() {
  return Wl || (Wl = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SynthesizerConfig = t.SynthesisServiceType = void 0;
    const e = b();
    var n;
    (function(s) {
      s[s.Standard = 0] = "Standard", s[s.Custom = 1] = "Custom";
    })(n = t.SynthesisServiceType || (t.SynthesisServiceType = {}));
    class r {
      constructor(o, a) {
        this.privSynthesisServiceType = n.Standard, this.avatarEnabled = !1, this.privSpeechServiceConfig = o || new e.SpeechServiceConfig(new e.Context(null)), this.privParameters = a;
      }
      get parameters() {
        return this.privParameters;
      }
      get synthesisServiceType() {
        return this.privSynthesisServiceType;
      }
      set synthesisServiceType(o) {
        this.privSynthesisServiceType = o;
      }
      set synthesisVideoSection(o) {
        this.privSpeechServiceConfig.Context.synthesis = {
          video: o
        };
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
    }
    t.SynthesizerConfig = r;
  }(yc)), yc;
}
var Wi = {}, Vl;
function RP() {
  if (Vl)
    return Wi;
  Vl = 1, Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.SynthesisContext = void 0;
  const t = P();
  let e = class {
    constructor() {
      this.privContext = {};
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */
    setSection(r, s) {
      this.privContext[r] = s;
    }
    /**
     * Sets the audio output format for synthesis context generation.
     * @param format {AudioOutputFormatImpl} the output format
     */
    set audioOutputFormat(r) {
      this.privAudioOutputFormat = r;
    }
    toJSON() {
      return JSON.stringify(this.privContext);
    }
    setSynthesisSection(r) {
      const s = this.buildSynthesisContext(r);
      this.setSection("synthesis", s);
    }
    buildSynthesisContext(r) {
      return {
        audio: {
          metadataOptions: {
            bookmarkEnabled: !!(r != null && r.bookmarkReached),
            punctuationBoundaryEnabled: r == null ? void 0 : r.properties.getProperty(t.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!(r != null && r.wordBoundary)),
            sentenceBoundaryEnabled: r == null ? void 0 : r.properties.getProperty(t.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, !1),
            sessionEndEnabled: !0,
            visemeEnabled: !!(r != null && r.visemeReceived),
            wordBoundaryEnabled: r == null ? void 0 : r.properties.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!(r != null && r.wordBoundary))
          },
          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
        },
        language: {
          autoDetection: r == null ? void 0 : r.autoDetectSourceLanguage
        }
      };
    }
  };
  return Wi.SynthesisContext = e, Wi;
}
var Vi = {}, Kl;
function PP() {
  if (Kl)
    return Vi;
  Kl = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.SpeakerRecognitionConfig = void 0;
  const t = b();
  let e = class {
    constructor(r, s) {
      this.privContext = r || new t.Context(null), this.privParameters = s;
    }
    get parameters() {
      return this.privParameters;
    }
    get Context() {
      return this.privContext;
    }
  };
  return Vi.SpeakerRecognitionConfig = e, Vi;
}
var Ki = {}, Jl;
function EP() {
  if (Jl)
    return Ki;
  Jl = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.SpeakerServiceRecognizer = void 0;
  const t = Se(), e = O(), n = P(), r = b(), s = Tt;
  let o = class extends r.ServiceRecognizerBase {
    constructor(i, c, u, p, d) {
      super(i, c, u, p, d), this.privSpeakerRecognizer = d, this.privSpeakerAudioSource = u, this.recognizeSpeaker = (l) => this.recognizeSpeakerOnce(l), this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    processTypeSpecificMessages(i) {
      let c = !1;
      const u = new n.PropertyCollection();
      switch (i.messageType === e.MessageType.Text && u.setProperty(n.PropertyId.SpeechServiceResponse_JsonResult, i.textBody), i.path.toLowerCase()) {
        case "speaker.response":
          const d = JSON.parse(i.textBody);
          let l;
          d.status.statusCode.toLowerCase() !== "success" ? l = new n.SpeakerRecognitionResult(d, n.ResultReason.Canceled, n.CancellationErrorCode.ServiceError, d.status.reason) : l = new n.SpeakerRecognitionResult(d, n.ResultReason.RecognizedSpeaker), this.privResultDeferral && this.privResultDeferral.resolve(l), c = !0;
          break;
      }
      const p = new e.Deferred();
      return p.resolve(c), p.promise;
    }
    // Cancels recognition.
    cancelRecognition(i, c, u, p, d) {
      if (new n.PropertyCollection().setProperty(r.CancellationErrorCodePropertyName, n.CancellationErrorCode[p]), this.privResultDeferral) {
        const h = new n.SpeakerRecognitionResult({
          scenario: this.privSpeakerModel.scenario,
          status: { statusCode: d, reason: d }
        }, n.ResultReason.Canceled, p, d);
        try {
          this.privResultDeferral.resolve(h);
        } catch (v) {
          this.privResultDeferral.reject(v);
        }
      }
    }
    async recognizeSpeakerOnce(i) {
      this.privSpeakerModel = i, this.voiceProfileType = i.scenario, this.privResultDeferral || (this.privResultDeferral = new e.Deferred()), this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(n.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const c = this.connectImpl(), u = this.sendPreAudioMessages(this.extractSpeakerContext(i)), p = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), d = await this.privSpeakerAudioSource.format, l = await this.privSpeakerAudioSource.deviceInfo, h = new t.ReplayableAudioNode(p, d.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(h, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: l };
      try {
        await c, await u;
      } catch (f) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.ConnectionFailure, f);
      }
      const v = new n.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, v), this.receiveMessage(), this.sendAudio(h).then(() => {
      }, (f) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.RuntimeError, f);
      }), this.privResultDeferral.promise;
    }
    async sendPreAudioMessages(i) {
      const c = await this.fetchConnection();
      await this.sendSpeakerRecognition(c, i);
    }
    async sendSpeakerRecognition(i, c) {
      const u = JSON.stringify(c);
      return i.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", u));
    }
    extractSpeakerContext(i) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: i.profileIds,
        scenario: i.scenario
      };
    }
  };
  return Ki.SpeakerServiceRecognizer = o, Ki;
}
var Ji = {}, Gl;
function TP() {
  if (Gl)
    return Ji;
  Gl = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.VoiceServiceRecognizer = void 0;
  const t = Se(), e = O(), n = P(), r = b(), s = Tt;
  let o = class extends r.ServiceRecognizerBase {
    constructor(i, c, u, p, d) {
      super(i, c, u, p, d), this.privDeferralMap = new e.DeferralMap(), this.privSpeakerAudioSource = u, this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    set SpeakerAudioSource(i) {
      this.privSpeakerAudioSource = i;
    }
    processTypeSpecificMessages(i) {
      let c = !1;
      const u = new n.PropertyCollection();
      switch (i.messageType === e.MessageType.Text && u.setProperty(n.PropertyId.SpeechServiceResponse_JsonResult, i.textBody), i.path.toLowerCase()) {
        case "speaker.profiles":
          const d = JSON.parse(i.textBody);
          switch (d.operation.toLowerCase()) {
            case "create":
              this.handleCreateResponse(d, i.requestId);
              break;
            case "delete":
            case "reset":
              this.handleResultResponse(d, i.requestId);
              break;
            case "fetch":
              const g = JSON.parse(i.textBody);
              this.handleFetchResponse(g, i.requestId);
              break;
          }
          c = !0;
          break;
        case "speaker.phrases":
          const l = JSON.parse(i.textBody);
          this.handlePhrasesResponse(l, i.requestId), c = !0;
          break;
        case "speaker.profile.enrollment":
          const h = JSON.parse(i.textBody), v = new n.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(h.enrollment ? h.enrollment.enrollmentStatus : h.status.statusCode), h.enrollment ? JSON.stringify(h.enrollment) : void 0, h.status.reason);
          this.privDeferralMap.getId(i.requestId) && this.privDeferralMap.complete(i.requestId, v), this.privRequestSession.onSpeechEnded(), c = !0;
          break;
      }
      const p = new e.Deferred();
      return p.resolve(c), p.promise;
    }
    // Cancels recognition.
    cancelRecognition(i, c, u, p, d) {
      new n.PropertyCollection().setProperty(r.CancellationErrorCodePropertyName, n.CancellationErrorCode[p]);
      const h = new n.VoiceProfileEnrollmentResult(n.ResultReason.Canceled, d, d);
      this.privDeferralMap.getId(c) && this.privDeferralMap.complete(c, h);
    }
    async createProfile(i, c) {
      this.voiceProfileType = i.toString();
      const u = this.connectImpl();
      try {
        const p = new e.Deferred();
        return await u, await this.sendCreateProfile(p, i, c), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async resetProfile(i) {
      return this.voiceProfileType = i.profileType.toString(), this.sendCommonRequest("reset", i.profileType, i);
    }
    async deleteProfile(i) {
      return this.voiceProfileType = i.profileType.toString(), this.sendCommonRequest("delete", i.profileType, i);
    }
    async retrieveEnrollmentResult(i) {
      return this.voiceProfileType = i.profileType.toString(), this.privExpectedProfileId = i.profileId, this.sendCommonRequest("fetch", i.profileType, i);
    }
    async getAllProfiles(i) {
      return this.voiceProfileType = i.toString(), this.sendCommonRequest("fetch", i);
    }
    async getActivationPhrases(i, c) {
      this.voiceProfileType = i.toString();
      const u = this.connectImpl();
      try {
        const p = new e.Deferred();
        return await u, await this.sendPhrasesRequest(p, i, c), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async enrollProfile(i) {
      this.voiceProfileType = i.profileType.toString();
      const c = new e.Deferred();
      this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(n.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const u = this.connectImpl(), p = this.sendPreAudioMessages(i, c), d = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), l = await this.privSpeakerAudioSource.format, h = await this.privSpeakerAudioSource.deviceInfo, v = new t.ReplayableAudioNode(d, l.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(v, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: h };
      try {
        await u, await p;
      } catch (m) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.ConnectionFailure, m);
      }
      const g = new n.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, g), this.receiveMessage(), this.sendAudio(v).then(() => {
      }, (m) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.RuntimeError, m);
      }), c.promise;
    }
    async sendPreAudioMessages(i, c) {
      const u = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, c), await this.sendBaseRequest(u, "enroll", this.scenarioFrom(i.profileType), i);
    }
    async sendPhrasesRequest(i, c, u) {
      const p = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, i);
      const d = this.scenarioFrom(c), l = {
        locale: u,
        scenario: d
      };
      return p.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(l)));
    }
    async sendCreateProfile(i, c, u) {
      const p = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, i);
      const d = c === n.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : c === n.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification", l = {
        locale: u,
        number: "1",
        scenario: d
      };
      return p.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(l)));
    }
    async sendCommonRequest(i, c, u = void 0) {
      const p = this.connectImpl();
      try {
        const d = new e.Deferred();
        this.privRequestSession.onSpeechContext(), await p;
        const l = await this.fetchConnection();
        return this.privDeferralMap.add(this.privRequestSession.requestId, d), await this.sendBaseRequest(l, i, this.scenarioFrom(c), u), this.receiveMessage(), d.promise;
      } catch (d) {
        throw d;
      }
    }
    async sendBaseRequest(i, c, u, p) {
      const d = {
        scenario: u
      };
      return p ? d.profileIds = [p.profileId] : d.maxPageSize = -1, i.send(new s.SpeechConnectionMessage(e.MessageType.Text, `speaker.profile.${c}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(d)));
    }
    extractSpeakerContext(i) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: i.profileIds,
        scenario: i.scenario
      };
    }
    handlePhrasesResponse(i, c) {
      if (this.privDeferralMap.getId(c))
        if (i.status.statusCode.toLowerCase() !== "success") {
          const u = n.ResultReason.Canceled, p = new n.VoiceProfilePhraseResult(u, i.status.statusCode, i.passPhraseType, []);
          this.privDeferralMap.complete(c, p);
        } else if (i.phrases && i.phrases.length > 0) {
          const u = n.ResultReason.EnrollingVoiceProfile, p = new n.VoiceProfilePhraseResult(u, i.status.statusCode, i.passPhraseType, i.phrases);
          this.privDeferralMap.complete(c, p);
        } else
          throw new Error("Voice Profile get activation phrases failed, no phrases received");
      else
        throw new Error(`Voice Profile get activation phrases request for requestID ${c} not found`);
    }
    handleCreateResponse(i, c) {
      if (i.profiles && i.profiles.length > 0)
        if (this.privDeferralMap.getId(c)) {
          const u = i.profiles.map((p) => p.profileId);
          this.privDeferralMap.complete(c, u);
        } else
          throw new Error(`Voice Profile create request for requestID ${c} not found`);
      else
        throw new Error("Voice Profile create failed, no profile id received");
    }
    handleResultResponse(i, c) {
      if (this.privDeferralMap.getId(c)) {
        const u = i.operation.toLowerCase() === "delete" ? n.ResultReason.DeletedVoiceProfile : n.ResultReason.ResetVoiceProfile, p = i.status.statusCode.toLowerCase() === "success" ? u : n.ResultReason.Canceled, d = new n.VoiceProfileResult(p, `statusCode: ${i.status.statusCode}, errorDetails: ${i.status.reason}`);
        this.privDeferralMap.complete(c, d);
      } else
        throw new Error(`Voice Profile create request for requestID ${c} not found`);
    }
    handleFetchResponse(i, c) {
      if (this.privDeferralMap.getId(c) && i.profiles[0]) {
        if (this.privExpectedProfileId && i.profiles.length === 1 && i.profiles[0].profileId === this.privExpectedProfileId) {
          this.privExpectedProfileId = void 0;
          const u = i.profiles[0], p = new n.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(u.enrollmentStatus), JSON.stringify(u), i.status.reason);
          this.privDeferralMap.complete(c, p);
        } else if (i.profiles.length > 0) {
          const u = i.profiles, p = [];
          for (const d of u)
            p.push(new n.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(d.enrollmentStatus), JSON.stringify(d), i.status.reason));
          this.privDeferralMap.complete(c, p);
        }
      } else
        throw new Error(`Voice Profile fetch request for requestID ${c} not found`);
    }
    enrollmentReasonFrom(i) {
      switch (i.toLowerCase()) {
        case "enrolled":
          return n.ResultReason.EnrolledVoiceProfile;
        case "invalidlocale":
        case "invalidphrase":
        case "invalidaudioformat":
        case "invalidscenario":
        case "invalidprofilecount":
        case "invalidoperation":
        case "audiotooshort":
        case "audiotoolong":
        case "toomanyenrollments":
        case "storageconflict":
        case "profilenotfound":
        case "incompatibleprofiles":
        case "incompleteenrollment":
          return n.ResultReason.Canceled;
        default:
          return n.ResultReason.EnrollingVoiceProfile;
      }
    }
    scenarioFrom(i) {
      return i === n.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : i === n.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    }
  };
  return Ji.VoiceServiceRecognizer = o, Ji;
}
var ng = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.type = t.connectivity = t.Device = t.OS = t.System = t.Context = t.SpeechServiceConfig = void 0;
  class e {
    constructor(i) {
      this.context = i;
    }
    serialize() {
      return JSON.stringify(this, (i, c) => {
        if (c && typeof c == "object" && !Array.isArray(c)) {
          const u = {};
          for (const p in c)
            Object.hasOwnProperty.call(c, p) && (u[p && p.charAt(0).toLowerCase() + p.substring(1)] = c[p]);
          return u;
        }
        return c;
      });
    }
    get Context() {
      return this.context;
    }
    get Recognition() {
      return this.recognition;
    }
    set Recognition(i) {
      this.recognition = i.toLowerCase();
    }
  }
  t.SpeechServiceConfig = e;
  class n {
    constructor(i) {
      this.system = new r(), this.os = i;
    }
  }
  t.Context = n;
  class r {
    constructor() {
      const i = "1.42.0";
      this.name = "SpeechSDK", this.version = i, this.build = "JavaScript", this.lang = "JavaScript";
    }
  }
  t.System = r;
  class s {
    constructor(i, c, u) {
      this.platform = i, this.name = c, this.version = u;
    }
  }
  t.OS = s;
  class o {
    constructor(i, c, u) {
      this.manufacturer = i, this.model = c, this.version = u;
    }
  }
  t.Device = o, function(a) {
    a.Bluetooth = "Bluetooth", a.Wired = "Wired", a.WiFi = "WiFi", a.Cellular = "Cellular", a.InBuilt = "InBuilt", a.Unknown = "Unknown";
  }(t.connectivity || (t.connectivity = {})), function(a) {
    a.Phone = "Phone", a.Speaker = "Speaker", a.Car = "Car", a.Headset = "Headset", a.Thermostat = "Thermostat", a.Microphones = "Microphones", a.Deskphone = "Deskphone", a.RemoteControl = "RemoteControl", a.Unknown = "Unknown", a.File = "File", a.Stream = "Stream";
  }(t.type || (t.type = {}));
})(ng);
var Ql;
function b() {
  return Ql || (Ql = 1, function(t) {
    var e = $ && $.__createBinding || (Object.create ? function(o, a, i, c) {
      c === void 0 && (c = i), Object.defineProperty(o, c, { enumerable: !0, get: function() {
        return a[i];
      } });
    } : function(o, a, i, c) {
      c === void 0 && (c = i), o[c] = a[i];
    }), n = $ && $.__exportStar || function(o, a) {
      for (var i in o)
        i !== "default" && !a.hasOwnProperty(i) && e(a, o, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AutoDetectSourceLanguagesOpenRangeOptionName = t.ForceDictationPropertyName = t.ServicePropertiesPropertyName = t.CancellationErrorCodePropertyName = t.OutputFormatPropertyName = void 0, n(Po, t), n(Ho, t), n(er, t), n(Xv, t), n(ef, t), n(fR(), t), n(gR(), t), n(Sa, t), n(mR(), t), n(SR(), t), n(yR(), t), n(Kf, t), n(ya, t), n(_R(), t), n(RR(), t), n(PR(), t), n(ER(), t), n(Hf(), t), n(TR(), t), n(Jf, t), n(wR(), t), n(Ca, t), n(bR(), t), n(AR(), t), n(_a, t), n(Ra, t), n(Pa, t), n(MR(), t), n(OR(), t), n(kR(), t), n(DR(), t), n(NR(), t), n(Ea, t), n(zR(), t), n(Ta, t), n(Zf, t), n(wa, t), n(ba, t), n(Aa, t), n(Xf, t), n(JR(), t), n(ka, t), n(lP(), t), n(Uu, t), n(gP(), t), n(mP(), t);
    var r = SP();
    Object.defineProperty(t, "AvatarSynthesisAdapter", { enumerable: !0, get: function() {
      return r.AvatarSynthesisAdapter;
    } });
    var s = yP();
    Object.defineProperty(t, "SpeechSynthesisAdapter", { enumerable: !0, get: function() {
      return s.SpeechSynthesisAdapter;
    } }), n(CP(), t), n(_P(), t), n(RP(), t), n(PP(), t), n(EP(), t), n(TP(), t), n(ng, t), t.OutputFormatPropertyName = "OutputFormat", t.CancellationErrorCodePropertyName = "CancellationErrorCode", t.ServicePropertiesPropertyName = "ServiceProperties", t.ForceDictationPropertyName = "ForceDictation", t.AutoDetectSourceLanguagesOpenRangeOptionName = "OpenRange";
  }(Xa)), Xa;
}
(function(t) {
  var e = $ && $.__createBinding || (Object.create ? function(s, o, a, i) {
    i === void 0 && (i = a), Object.defineProperty(s, i, { enumerable: !0, get: function() {
      return o[a];
    } });
  } : function(s, o, a, i) {
    i === void 0 && (i = a), s[i] = o[a];
  }), n = $ && $.__exportStar || function(s, o) {
    for (var a in s)
      a !== "default" && !o.hasOwnProperty(a) && e(o, s, a);
  };
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = b();
  new r.AgentConfig(), n(P(), t);
})(Ln);
const Yl = "DID_AGENT_STT_TOKEN", rg = 1e3 * 60 * 9, wP = () => {
  const {
    agentManager: t
  } = Ue(Yn);
  return mn(async () => {
    const e = JSON.parse(localStorage.getItem(Yl) ?? "null"), n = (/* @__PURE__ */ new Date()).getTime();
    if (e && n < e.expiry)
      return e;
    const r = await (t == null ? void 0 : t.getSTTToken()), s = {
      token: r,
      expiry: n + rg
    };
    return r && localStorage.setItem(Yl, JSON.stringify(s)), s;
  }, [t == null ? void 0 : t.getSTTToken]);
}, IP = "en-US";
class bP {
  constructor({
    events: e,
    getSTTToken: n
  }) {
    Le(this, "events");
    Le(this, "getSTTToken");
    Le(this, "recognizer");
    Le(this, "intervalId");
    Le(this, "isCancelled");
    Le(this, "isDestroyed");
    Le(this, "initEvents", () => {
      this.recognizer && (this.recognizer.recognized = (e, n) => {
        var r, s, o;
        this.isCancelled || (this.events.onresult(n), (r = this.recognizer) == null || r.stopContinuousRecognitionAsync()), this.isCancelled = !1, (o = (s = this.events).onend) == null || o.call(s);
      }, this.recognizer.canceled = (e, n) => {
        var r, s;
        (s = (r = this.events).onerror) == null || s.call(r, n);
      });
    });
    Le(this, "refreshToken", async () => {
      var n, r;
      if (this.isDestroyed)
        return;
      const e = await this.getSTTToken();
      e.token && ((n = this.recognizer) == null || n.properties.setProperty(Ln.PropertyId.SpeechServiceConnection_Region, e.token.token), (r = this.recognizer) == null || r.properties.setProperty(Ln.PropertyId.SpeechServiceAuthorization_Token, e.token.region));
    });
    Le(this, "initTokenRefreshInterval", (e) => {
      const n = (/* @__PURE__ */ new Date()).getTime();
      window.setTimeout(() => {
        this.isDestroyed || (this.refreshToken(), this.intervalId = window.setInterval(this.refreshToken, rg));
      }, e - n + 1);
    });
    Le(this, "init", async () => {
      const e = await this.getSTTToken();
      if (!(e != null && e.token))
        return;
      const n = Ln.AudioConfig.fromDefaultMicrophoneInput(), r = Ln.SpeechConfig.fromAuthorizationToken(e.token.token, e.token.region);
      r.speechRecognitionLanguage = navigator.language || IP, this.recognizer = new Ln.SpeechRecognizer(r, n), this.initEvents(), this.initTokenRefreshInterval(e.expiry);
    });
    Le(this, "start", () => {
      var e, n, r;
      this.isCancelled = !1, (n = (e = this.events).onstart) == null || n.call(e), (r = this.recognizer) == null || r.startContinuousRecognitionAsync();
    });
    Le(this, "stop", () => {
      var e;
      (e = this.recognizer) == null || e.stopContinuousRecognitionAsync();
    });
    Le(this, "abort", () => {
      var e;
      this.isCancelled = !0, (e = this.recognizer) == null || e.stopContinuousRecognitionAsync();
    });
    /**
     * Destroy the recognizer. This is needed to avoid memory leaks.
     * If you need to use the recognizer again, you need to create a new instance.
     */
    Le(this, "destroy", () => {
      var e, n;
      this.isDestroyed = !0, (e = this.recognizer) == null || e.stopContinuousRecognitionAsync(), (n = this.recognizer) == null || n.close(), this.recognizer = void 0, window.clearInterval(this.intervalId);
    });
    this.events = e, this.getSTTToken = n, this.isCancelled = !1, this.isDestroyed = !1;
  }
}
function AP({
  text: t,
  onSend: e,
  onTranscript: n,
  isSttSendDisabled: r,
  isMessageSendDisabled: s,
  className: o
}) {
  const [a, i] = F(!1), {
    connectionState: c,
    reconnect: u,
    agentManager: p,
    enabled: d
  } = Ue(Yn), {
    isAuthenticated: l
  } = Ue(ps), h = pt(), v = wP();
  if (oe(() => ((() => {
    var f;
    if (!(!(p != null && p.getSTTToken) || !d))
      return (f = h.current) == null || f.destroy(), h.current = new bP({
        getSTTToken: v,
        events: {
          onresult(m) {
            n(m.result.text);
          },
          onstart: () => {
            zt("agent-stt", {
              event: "start",
              engine: "azure"
            }), i(!0);
          },
          onend: () => {
            var m;
            (m = document.activeElement) == null || m.blur(), i(!1);
          },
          onerror: (m) => zt("agent-stt", {
            event: "error",
            error: m.errorDetails,
            errorCode: m.errorCode,
            engine: "azure"
          })
        }
      }), h.current.init();
  })(), () => {
    var f;
    return (f = h.current) == null ? void 0 : f.destroy();
  }), [p == null ? void 0 : p.getSTTToken, d]), oe(() => {
    h.current && (h.current.events.onresult = (g) => n(g.result.text));
  }, [n]), l && !a && c === G.Connecting)
    return w("button", {
      className: "didagaent__send__button didagaent__send__button__loader " + o,
      disabled: !0,
      "data-testid": "send_loader",
      children: w(Ye, {
        src: Av,
        size: "60%",
        color: "var(--did-primary-black-700)"
      })
    });
  if (t.length === 0) {
    const g = async () => {
      if (h.current) {
        const f = a ? "stop" : "start";
        Lc.includes(c) && await u(), setTimeout(() => {
          var m;
          return (m = h.current) == null ? void 0 : m[f]();
        }), zt("agent-stt", {
          event: f,
          engine: "azure"
        });
      }
    };
    return w(xt, {
      children: [a && w("button", {
        disabled: r,
        className: "didagaent__send__button didagaent__send__button__record " + o,
        onClick: () => {
          var f;
          (f = h.current) == null || f.abort(), i(!1);
        },
        children: w(Ye, {
          src: Ov,
          size: "60%",
          color: "var(--did-primary-black-700)"
        })
      }), w("button", {
        className: `didagaent__send__button ${a ? "" : "didagaent__send__button__record"} ${o}`,
        onClick: g,
        disabled: r,
        "data-testid": "send_record",
        children: w(Ye, {
          src: a ? ZS : QS,
          size: "60%",
          color: a ? "white" : "var(--did-primary-black-700)"
        })
      })]
    });
  }
  return w("button", {
    className: "didagaent__send__button  didagaent__send__button_actions " + o + (s ? " didagent__send__button__disabled" : ""),
    onClick: e,
    disabled: s,
    "data-testid": "send_text",
    children: w(Ye, {
      src: YS,
      size: "60%",
      color: "white"
    })
  });
}
const MP = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.3035%206.70851L14.7142%206.11925C12.1107%203.51576%207.88961%203.51576%205.28612%206.11925C2.68262%208.72275%202.68262%2012.9438%205.28612%2015.5473C7.88961%2018.1508%2012.1107%2018.1508%2014.7142%2015.5473C16.2282%2014.0333%2016.8618%2011.9723%2016.6149%2010.0004M15.3035%206.70851H11.7679M15.3035%206.70851V3.17297'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", OP = "data:image/svg+xml,%3csvg%20width='20'%20height='21'%20viewBox='0%200%2020%2021'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M13.5417%2010.2484C13.5417%209.90318%2013.2618%209.62336%2012.9167%209.62336C12.5715%209.62336%2012.2917%209.90318%2012.2917%2010.2484H13.5417ZM5.84683%206.04679L5.9509%206.66307L5.84683%206.04679ZM7.1661%205.43188L6.82206%204.91009L6.82206%204.91009L7.1661%205.43188ZM6.43996%205.86885L6.69231%206.44064L6.43996%205.86885ZM2.78323%2014.184L2.5208%2014.7512L2.78323%2014.184ZM1.27899%2011.1054L0.655149%2011.1434L1.27899%2011.1054ZM1.63212%2013.1009L2.18233%2012.8044L1.63212%2013.1009ZM11.4167%2016.9775L11.2149%2016.3859L11.4167%2016.9775ZM12.8439%2012.4195L13.4683%2012.4485L12.8439%2012.4195ZM11.8997%2016.7317L12.2591%2017.243L11.8997%2016.7317ZM7.34855%205.31159L7.69258%205.83338L7.69258%205.83338L7.34855%205.31159ZM11.4167%203.51926L11.2149%204.11077L11.4167%203.51926ZM11.8997%203.76506L12.2591%203.25371L11.8997%203.76506ZM2.78323%206.31276L2.5208%205.74553L2.78323%206.31276ZM1.27899%209.39136L0.655149%209.35333L1.27899%209.39136ZM1.63212%207.39586L2.18233%207.69232L1.63212%207.39586ZM8.25923%2015.0362C7.97052%2014.847%207.5831%2014.9277%207.39391%2015.2164C7.20472%2015.5051%207.28539%2015.8926%207.57411%2016.0817L8.25923%2015.0362ZM7.51013%205.95367L7.69258%205.83338L7.00451%204.7898L6.82206%204.91009L7.51013%205.95367ZM1.90283%2011.0673C1.88521%2010.7782%201.875%2010.501%201.875%2010.2484H0.625C0.625%2010.533%200.636444%2010.8365%200.655149%2011.1434L1.90283%2011.0673ZM1.875%2010.2484C1.875%209.99567%201.88521%209.71852%201.90283%209.42938L0.655149%209.35333C0.636444%209.66022%200.625%209.96371%200.625%2010.2484H1.875ZM12.2917%2010.2484C12.2917%2010.6748%2012.263%2011.4575%2012.2196%2012.3905L13.4683%2012.4485C13.5114%2011.5194%2013.5417%2010.7084%2013.5417%2010.2484H12.2917ZM5.00007%206.70669C5.40642%206.70669%205.68068%206.7087%205.9509%206.66307L5.74276%205.43052C5.59964%205.45469%205.44717%205.45669%205.00007%205.45669V6.70669ZM6.82206%204.91009C6.4488%205.1562%206.3204%205.23846%206.18761%205.29706L6.69231%206.44064C6.94302%206.32999%207.17089%206.17735%207.51014%205.95367L6.82206%204.91009ZM5.9509%206.66307C6.2063%206.61994%206.45534%206.54522%206.69231%206.44064L6.18761%205.29706C6.04543%205.35981%205.896%205.40464%205.74276%205.43052L5.9509%206.66307ZM5.00007%2015.04C5.44717%2015.04%205.59964%2015.042%205.74276%2015.0662L5.9509%2013.8337C5.68068%2013.788%205.40642%2013.79%205.00007%2013.79V15.04ZM5.00007%2013.79C3.79701%2013.79%203.39093%2013.7765%203.04567%2013.6167L2.5208%2014.7512C3.17442%2015.0536%203.91327%2015.04%205.00007%2015.04V13.79ZM0.655149%2011.1434C0.713737%2012.1046%200.741742%2012.766%201.0819%2013.3973L2.18233%2012.8044C2.00044%2012.4668%201.96704%2012.1208%201.90283%2011.0673L0.655149%2011.1434ZM3.04567%2013.6167C2.71204%2013.4624%202.3567%2013.128%202.18233%2012.8044L1.0819%2013.3973C1.38451%2013.959%201.9418%2014.4833%202.5208%2014.7512L3.04567%2013.6167ZM12.2196%2012.3905C12.1603%2013.6661%2012.1175%2014.5594%2012.0013%2015.2051C11.8855%2015.848%2011.7209%2016.0934%2011.5404%2016.2203L12.2591%2017.243C12.8475%2016.8295%2013.0965%2016.1762%2013.2315%2015.4266C13.3659%2014.68%2013.4107%2013.6874%2013.4683%2012.4485L12.2196%2012.3905ZM11.6186%2017.569C11.8451%2017.4916%2012.0632%2017.3807%2012.2591%2017.243L11.5404%2016.2203C11.4414%2016.2899%2011.3294%2016.3469%2011.2149%2016.3859L11.6186%2017.569ZM7.69258%205.83338C8.76742%205.1247%209.52165%204.62895%2010.1169%204.33981C10.7104%204.05147%2011.0072%204.03991%2011.2149%204.11077L11.6186%202.92775C10.9368%202.69508%2010.259%202.88107%209.57067%203.21546C8.88394%203.54906%208.04882%204.10124%207.00451%204.7898L7.69258%205.83338ZM11.2149%204.11077C11.3294%204.14984%2011.4414%204.20686%2011.5404%204.27642L12.2591%203.25371C12.0632%203.11606%2011.8451%203.00507%2011.6186%202.92775L11.2149%204.11077ZM5.00007%205.45669C3.91327%205.45669%203.17442%205.44313%202.5208%205.74553L3.04567%206.88C3.39093%206.72026%203.79701%206.70669%205.00007%206.70669V5.45669ZM1.90283%209.42938C1.96704%208.37591%202.00044%208.02991%202.18233%207.69232L1.0819%207.0994C0.741742%207.73072%200.713737%208.39208%200.655149%209.35333L1.90283%209.42938ZM2.5208%205.74553C1.9418%206.01341%201.38451%206.53777%201.0819%207.0994L2.18233%207.69232C2.3567%207.36869%202.71204%207.03435%203.04567%206.88L2.5208%205.74553ZM7.57411%2016.0817C8.43976%2016.649%209.15622%2017.1023%209.76703%2017.3725C10.3856%2017.6461%2011.0002%2017.78%2011.6186%2017.569L11.2149%2016.3859C11.027%2016.45%2010.7656%2016.4474%2010.2727%2016.2293C9.77201%2016.0079%209.14153%2015.6144%208.25923%2015.0362L7.57411%2016.0817ZM13.4359%207.36502C13.3854%206.3424%2013.3303%205.50424%2013.1891%204.85648C13.046%204.19945%2012.792%203.62818%2012.2591%203.25371L11.5404%204.27642C11.7036%204.39113%2011.8545%204.60276%2011.9678%205.1226C12.0831%205.65169%2012.1359%206.38434%2012.1874%207.42669L13.4359%207.36502Z'%20fill='%23090604'/%3e%3cpath%20d='M16.6665%2015.2487C16.6665%2015.2487%2017.9165%2013.7487%2017.9165%2010.2487C17.9165%208.22085%2017.4969%206.86438%2017.1439%206.08203'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3cpath%20d='M15%2012.7487C15%2012.7487%2015.4167%2011.9987%2015.4167%2010.2487C15.4167%209.53046%2015.3465%208.98066%2015.2637%208.58203'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3cpath%20d='M18.3332%201.91797L1.6665%2018.5846'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3c/svg%3e", kP = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M1.27899%209.14136C1.34039%208.134%201.37109%207.63031%201.63212%207.14586C1.87061%206.70323%202.32692%206.27388%202.78323%206.06276C3.28268%205.83169%203.85514%205.83169%205.00007%205.83169C5.4268%205.83169%205.64016%205.83169%205.84683%205.79679C6.05115%205.76229%206.25039%205.70252%206.43996%205.61885C6.63171%205.53423%206.80984%205.41678%207.1661%205.18188L7.34855%205.06159C9.46769%203.66435%2010.5273%202.96573%2011.4167%203.26926C11.5872%203.32746%2011.7523%203.41146%2011.8997%203.51506C12.6687%204.05544%2012.7271%205.3127%2012.8439%207.8272C12.8872%208.75826%2012.9167%209.55512%2012.9167%209.99836C12.9167%2010.4416%2012.8872%2011.2385%2012.8439%2012.1695C12.7271%2014.684%2012.6687%2015.9413%2011.8997%2016.4817C11.7523%2016.5853%2011.5872%2016.6693%2011.4167%2016.7275C10.5273%2017.031%209.46769%2016.3324%207.34854%2014.9351L7.1661%2014.8148C6.80984%2014.5799%206.63171%2014.4625%206.43996%2014.3779C6.25039%2014.2942%206.05115%2014.2344%205.84683%2014.1999C5.64016%2014.165%205.4268%2014.165%205.00007%2014.165C3.85514%2014.165%203.28268%2014.165%202.78323%2013.934C2.32692%2013.7228%201.87061%2013.2935%201.63212%2012.8509C1.37109%2012.3664%201.34039%2011.8627%201.27899%2010.8554C1.26083%2010.5573%201.25%2010.267%201.25%209.99836C1.25%209.72969%201.26083%209.43937%201.27899%209.14136Z'%20stroke='white'%20stroke-width='1.5'/%3e%3cpath%20d='M15%207.5C15%207.5%2015.4167%208.25%2015.4167%2010C15.4167%2011.75%2015%2012.5%2015%2012.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'/%3e%3c/svg%3e";
function DP({
  show: t,
  muted: e,
  onClick: n,
  className: r
}) {
  return t ? w("button", {
    onClick: n,
    title: "Mute Sound",
    className: `${r}`,
    children: w(Ye, {
      src: e ? OP : kP,
      size: "20px"
    })
  }) : null;
}
function NP({
  name: t,
  icon: e,
  displayRestart: n,
  displayMuteButton: r,
  onRestart: s,
  restartDisabled: o,
  onMute: a,
  muted: i,
  isRestarting: c,
  onClose: u,
  onEasterEgg: p,
  closeClassName: d
}) {
  const l = pt(0), {
    error: h
  } = Ue(Yn), {
    configurations: v
  } = Ue($t);
  function g() {
    l.current += 1, l.current === 5 && (p == null || p(), l.current = 0);
  }
  const f = [M.Maintenance].includes(v.chatMode);
  return w("header", {
    className: "didagent__header",
    children: [w("div", {
      className: "didagent__header-left",
      children: [v.mode === "fabio" && w("button", {
        onClick: u,
        className: `didagent__close__button didagent__header-bg ${d}`,
        children: w(Ye, {
          src: Ov,
          size: "20px"
        })
      }), !f && w("div", {
        "data-testid": "didagent__header__name",
        className: `didagent__header__name ${e ? "" : "didagent__header-bg"}`,
        onClick: g,
        children: e ? w("img", {
          src: e,
          alt: "Agent Logo"
        }) : t
      }), n && w("button", {
        onClick: s,
        disabled: o,
        title: "Restart conversation",
        className: `didagent__header__menu__item ${c ? "didagent__header__menu__item-rotate" : ""} didagent__header-bg`,
        children: w(Ye, {
          src: MP,
          size: "20px"
        })
      }), w(DP, {
        show: r,
        muted: i,
        onClick: a,
        className: `${i ? "didagent__header__menu__item-active" : ""} didagent__header-bg`
      })]
    }), w("div", {
      className: "didagent__header-center",
      children: w(KS, {
        hide: !h,
        text: h
      })
    })]
  });
}
const LP = "data:image/svg+xml,%3csvg%20version='1.1'%20id='L5'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%2052%2042'%20enable-background='new%200%200%200%200'%20xml:space='preserve'%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='6'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%2015%20;%200%20-15;%200%2015'%20repeatCount='indefinite'%20begin='0.1'/%3e%3c/circle%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='25'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%2010%20;%200%20-10;%200%2010'%20repeatCount='indefinite'%20begin='0.2'/%3e%3c/circle%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='44'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%205%20;%200%20-5;%200%205'%20repeatCount='indefinite'%20begin='0.3'/%3e%3c/circle%3e%3c/svg%3e";
function ig(t, e) {
  for (var n in e)
    t[n] = e[n];
  return t;
}
function Zl(t, e) {
  for (var n in t)
    if (n !== "__source" && !(n in e))
      return !0;
  for (var r in e)
    if (r !== "__source" && t[r] !== e[r])
      return !0;
  return !1;
}
function Xl(t, e) {
  this.props = t, this.context = e;
}
(Xl.prototype = new Ct()).isPureReactComponent = !0, Xl.prototype.shouldComponentUpdate = function(t, e) {
  return Zl(this.props, t) || Zl(this.state, e);
};
var eh = q.__b;
q.__b = function(t) {
  t.type && t.type.__f && t.ref && (t.props.ref = t.ref, t.ref = null), eh && eh(t);
};
var zP = typeof Symbol < "u" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function jP(t) {
  function e(n) {
    var r = ig({}, n);
    return delete r.ref, t(r, n.ref || null);
  }
  return e.$$typeof = zP, e.render = e, e.prototype.isReactComponent = e.__f = !0, e.displayName = "ForwardRef(" + (t.displayName || t.name) + ")", e;
}
var xP = q.__e;
q.__e = function(t, e, n, r) {
  if (t.then) {
    for (var s, o = e; o = o.__; )
      if ((s = o.__c) && s.__c)
        return e.__e == null && (e.__e = n.__e, e.__k = n.__k), s.__c(t, e);
  }
  xP(t, e, n, r);
};
var th = q.unmount;
function sg(t, e, n) {
  return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function(r) {
    typeof r.__c == "function" && r.__c();
  }), t.__c.__H = null), (t = ig({}, t)).__c != null && (t.__c.__P === n && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function(r) {
    return sg(r, e, n);
  })), t;
}
function og(t, e, n) {
  return t && n && (t.__v = null, t.__k = t.__k && t.__k.map(function(r) {
    return og(r, e, n);
  }), t.__c && t.__c.__P === e && (t.__e && n.appendChild(t.__e), t.__c.__e = !0, t.__c.__P = n)), t;
}
function Cc() {
  this.__u = 0, this.t = null, this.__b = null;
}
function ag(t) {
  var e = t.__.__c;
  return e && e.__a && e.__a(t);
}
function Us() {
  this.u = null, this.o = null;
}
q.unmount = function(t) {
  var e = t.__c;
  e && e.__R && e.__R(), e && 32 & t.__u && (t.type = null), th && th(t);
}, (Cc.prototype = new Ct()).__c = function(t, e) {
  var n = e.__c, r = this;
  r.t == null && (r.t = []), r.t.push(n);
  var s = ag(r.__v), o = !1, a = function() {
    o || (o = !0, n.__R = null, s ? s(i) : i());
  };
  n.__R = a;
  var i = function() {
    if (!--r.__u) {
      if (r.state.__a) {
        var c = r.state.__a;
        r.__v.__k[0] = og(c, c.__c.__P, c.__c.__O);
      }
      var u;
      for (r.setState({ __a: r.__b = null }); u = r.t.pop(); )
        u.forceUpdate();
    }
  };
  r.__u++ || 32 & e.__u || r.setState({ __a: r.__b = r.__v.__k[0] }), t.then(a, a);
}, Cc.prototype.componentWillUnmount = function() {
  this.t = [];
}, Cc.prototype.render = function(t, e) {
  if (this.__b) {
    if (this.__v.__k) {
      var n = document.createElement("div"), r = this.__v.__k[0].__c;
      this.__v.__k[0] = sg(this.__b, n, r.__O = r.__P);
    }
    this.__b = null;
  }
  var s = e.__a && ts(xt, null, t.fallback);
  return s && (s.__u &= -33), [ts(xt, null, e.__a ? null : t.children), s];
};
var nh = function(t, e, n) {
  if (++n[1] === n[0] && t.o.delete(e), t.props.revealOrder && (t.props.revealOrder[0] !== "t" || !t.o.size))
    for (n = t.u; n; ) {
      for (; n.length > 3; )
        n.pop()();
      if (n[1] < n[0])
        break;
      t.u = n = n[2];
    }
};
function BP(t) {
  return this.getChildContext = function() {
    return t.context;
  }, t.children;
}
function qP(t) {
  var e = this, n = t.i;
  e.componentWillUnmount = function() {
    uo(null, e.l), e.l = null, e.i = null;
  }, e.i && e.i !== n && e.componentWillUnmount(), e.l || (e.i = n, e.l = { nodeType: 1, parentNode: n, childNodes: [], appendChild: function(r) {
    this.childNodes.push(r), e.i.appendChild(r);
  }, insertBefore: function(r, s) {
    this.childNodes.push(r), e.i.appendChild(r);
  }, removeChild: function(r) {
    this.childNodes.splice(this.childNodes.indexOf(r) >>> 1, 1), e.i.removeChild(r);
  } }), uo(ts(BP, { context: e.context }, t.__v), e.l);
}
function rh(t, e) {
  var n = ts(qP, { __v: t, i: e });
  return n.containerInfo = e, n;
}
(Us.prototype = new Ct()).__a = function(t) {
  var e = this, n = ag(e.__v), r = e.o.get(t);
  return r[0]++, function(s) {
    var o = function() {
      e.props.revealOrder ? (r.push(s), nh(e, t, r)) : s();
    };
    n ? n(o) : o();
  };
}, Us.prototype.render = function(t) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var e = co(t.children);
  t.revealOrder && t.revealOrder[0] === "b" && e.reverse();
  for (var n = e.length; n--; )
    this.o.set(e[n], this.u = [1, 0, this.u]);
  return t.children;
}, Us.prototype.componentDidUpdate = Us.prototype.componentDidMount = function() {
  var t = this;
  this.o.forEach(function(e, n) {
    nh(t, n, e);
  });
};
var FP = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, $P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, UP = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, HP = /[A-Z0-9]/g, WP = typeof document < "u", VP = function(t) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/ : /fil|che|ra/).test(t);
};
Ct.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t) {
  Object.defineProperty(Ct.prototype, t, { configurable: !0, get: function() {
    return this["UNSAFE_" + t];
  }, set: function(e) {
    Object.defineProperty(this, t, { configurable: !0, writable: !0, value: e });
  } });
});
var ih = q.event;
function KP() {
}
function JP() {
  return this.cancelBubble;
}
function GP() {
  return this.defaultPrevented;
}
q.event = function(t) {
  return ih && (t = ih(t)), t.persist = KP, t.isPropagationStopped = JP, t.isDefaultPrevented = GP, t.nativeEvent = t;
};
var QP = { enumerable: !1, configurable: !0, get: function() {
  return this.class;
} }, sh = q.vnode;
q.vnode = function(t) {
  typeof t.type == "string" && function(e) {
    var n = e.props, r = e.type, s = {};
    for (var o in n) {
      var a = n[o];
      if (!(o === "value" && "defaultValue" in n && a == null || WP && o === "children" && r === "noscript" || o === "class" || o === "className")) {
        var i = o.toLowerCase();
        o === "defaultValue" && "value" in n && n.value == null ? o = "value" : o === "download" && a === !0 ? a = "" : i === "translate" && a === "no" ? a = !1 : i === "ondoubleclick" ? o = "ondblclick" : i !== "onchange" || r !== "input" && r !== "textarea" || VP(n.type) ? i === "onfocus" ? o = "onfocusin" : i === "onblur" ? o = "onfocusout" : UP.test(o) ? o = i : r.indexOf("-") === -1 && $P.test(o) ? o = o.replace(HP, "-$&").toLowerCase() : a === null && (a = void 0) : i = o = "oninput", i === "oninput" && s[o = i] && (o = "oninputCapture"), s[o] = a;
      }
    }
    r == "select" && s.multiple && Array.isArray(s.value) && (s.value = co(n.children).forEach(function(c) {
      c.props.selected = s.value.indexOf(c.props.value) != -1;
    })), r == "select" && s.defaultValue != null && (s.value = co(n.children).forEach(function(c) {
      c.props.selected = s.multiple ? s.defaultValue.indexOf(c.props.value) != -1 : s.defaultValue == c.props.value;
    })), n.class && !n.className ? (s.class = n.class, Object.defineProperty(s, "className", QP)) : (n.className && !n.class || n.class && n.className) && (s.class = s.className = n.className), e.props = s;
  }(t), t.$$typeof = FP, sh && sh(t);
};
var oh = q.__r;
q.__r = function(t) {
  oh && oh(t), t.__c;
};
var ah = q.diffed;
q.diffed = function(t) {
  ah && ah(t);
  var e = t.props, n = t.__e;
  n != null && t.type === "textarea" && "value" in e && e.value !== n.value && (n.value = e.value == null ? "" : e.value);
};
function YP(t, e, n) {
  return t ? "var(--did-primary-black-9080)" : "var(--did-primary-black-9060)";
}
function ch({
  negative: t,
  toggled: e,
  onClick: n,
  disabled: r
}) {
  if (!e && r)
    return null;
  const s = t === !0, o = {
    "--hover-color": "var(--did-primary-black-9080)",
    "--color": YP(e, s, r === !0),
    "--cursor": r === !0 ? "default" : "pointer"
  };
  return w("div", {
    className: "didagent__thumb__container",
    style: o,
    onClick: () => !r && (n == null ? void 0 : n(!e)),
    children: s ? "" : ""
  });
}
const ZP = (t, e) => t === "up" ? e === tt.Positive ? tt.Unrated : tt.Positive : e === tt.Negative ? tt.Unrated : tt.Negative;
function XP({
  className: t,
  show: e,
  onRate: n,
  message: r,
  style: s
}) {
  const [o, a] = F(tt.Unrated), [i, c] = F(), [u, p] = F(!1);
  if (!e)
    return null;
  function d(l) {
    return async () => {
      var g;
      const h = ZP(l, o);
      a(h), p(!0);
      const v = await (n == null ? void 0 : n(h, r, i));
      c(v), (g = window.dataLayer) == null || g.push({
        event: "rated_reply",
        rating: h,
        message: r
      });
    };
  }
  return w("div", {
    className: `${t} didagent__rating`,
    style: s,
    children: [w(ch, {
      disabled: u,
      toggled: o === tt.Positive,
      onClick: d("up")
    }), w(ch, {
      disabled: u,
      negative: !0,
      toggled: o === tt.Negative,
      onClick: d("down")
    })]
  });
}
const eE = /(https?:\/\/[^\s]+)/g, uh = {
  "#general#": 280,
  ".": 620,
  ",": 500,
  "?": 500,
  "!": 500
};
function tE({
  text: t,
  role: e,
  onTypingStatusChange: n,
  scrollToBottom: r
}) {
  const [s, o] = F([]), [a, i] = F(0), [c, u] = F([]);
  return oe(() => u(t.split(" ")), [t]), oe(() => {
    if (a < c.length) {
      const p = c[a], d = uh[p.split("").pop() ?? ""] || uh["#general#"], h = eE.test(p) ? w("a", {
        href: p,
        target: "_blank",
        rel: "noreferrer",
        className: "didagent__message__url",
        children: p
      }) : w("span", {
        children: p
      }), v = setTimeout(() => {
        o((g) => [...g, g.length ? " " : "", h]), i((g) => g + 1), r();
      }, d);
      return () => clearTimeout(v);
    }
  }, [a, c]), oe(() => {
    a === 0 ? n("start", e) : a >= c.length && n("done", e);
  }, [a, c]), e === "user" ? w("span", {
    children: t
  }) : w("span", {
    className: "appear-animation",
    children: s
  });
}
const nE = ["Juggling thoughts and data...", "Processing, just a moment...", "Cooking up a response...", "Brainstorming potential answers...", "Let me look this up..."], ph = ["Pondering the best reply...", "Processing, just a moment...", "Convincing my electrons to run faster...", "This is interesting..."], rE = [{
  text: [""],
  duration: 2e3
}, {
  text: ["Thinking..."],
  duration: 3e3
}, {
  text: nE,
  duration: 4e3
}, {
  text: ph,
  duration: 4e3
}, {
  text: ph,
  duration: 4e3
}];
function iE(t) {
  return t[Math.floor(Math.random() * t.length)];
}
function sE(t) {
  const [e, n] = F(t[0].text[0]), r = pt(), s = (a = 0) => {
    a < t.length && !r.current && (r.current = setTimeout(() => {
      r.current = void 0;
      const i = (a + 1) % t.length;
      n(iE(t[i].text)), s(i);
    }, t[a].duration));
  };
  return {
    text: e,
    doStep: s,
    clear: () => {
      clearTimeout(r.current), n(t[0].text[0]), r.current = void 0;
    }
  };
}
const oE = "#b8b8b8", aE = jP(({
  messages: t,
  isLoading: e,
  onRate: n,
  scrollToBottom: r,
  onScroll: s
}, o) => {
  const [a, i] = F(!1), {
    doStep: c,
    text: u,
    clear: p
  } = sE(rE);
  oe(() => e ? c() : p(), [e]);
  const d = mn((v, g) => {
    i(v === "start" ? !1 : g === "assistant");
  }, [i]), l = t[t.length - 1], h = e && l.role === "assistant" ? t.slice(0, t.length - 1) : t;
  return w("div", {
    className: "didagent__messages__container",
    ref: o,
    "data-testid": "didagent_messages",
    onScroll: s,
    children: [h.filter(({
      content: v
    }) => !!v).map((v, g) => w("div", {
      className: `didagent__message__container didagent__message__container__${v.role}`,
      children: [w("pre", {
        className: `didagent__message didagent__message__${v.role}`,
        children: w(tE, {
          text: v.content,
          role: v.role,
          onTypingStatusChange: d,
          scrollToBottom: r
        }, v.id)
      }), g > 0 && v.role === "assistant" && w(XP, {
        className: "didagent__message__rating",
        message: v,
        show: a,
        onRate: n,
        style: {
          opacity: g === t.length - 1 ? 1 : void 0
        }
      })]
    }, v.id)), e && w("div", {
      className: "didagent__message__container didagent__message__container__assistant",
      "data-testid": "didagent_message_loader",
      children: w("pre", {
        className: "didagent__message didagent__message__assistant didagent__message__assistant__loader",
        children: [w(Ye, {
          src: LP,
          color: oE,
          size: "22px"
        }), u]
      })
    })]
  });
}), cE = "data:image/svg+xml,%3csvg%20width='22'%20height='12'%20viewBox='0%200%2022%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.7997%201.79923L10.9997%2010.1992L1.19971%201.79922'%20stroke='%23FFFEFD'%20stroke-width='2.1'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function uE(t) {
  return t ? {
    maxHeight: "180px",
    paddingbottom: "8px",
    marginBottom: "-8px"
  } : {
    maxHeight: "0",
    paddingBottom: "0",
    marginBottom: "0"
  };
}
function pE({
  messages: t,
  onClick: e,
  show: n,
  enabled: r
}) {
  const [s, o] = F(!1);
  oe(() => {
    n && t.length > 0 && setTimeout(() => {
      o(!0);
    }, 2e3);
  }, [n, t]);
  const a = (i) => {
    var c;
    r && e(i), (c = window.dataLayer) == null || c.push({
      event: "clicked_starter_message",
      message: i
    });
  };
  return w("div", {
    className: "didagent__starter_messages__container",
    style: uE(s && n),
    children: t.map((i) => w("div", {
      className: `didagent__starter_message__container ${r ? "" : "disabled"}`,
      onClick: () => a(i),
      children: [w("div", {
        className: "didagent__starter_message__container_text",
        children: i
      }), w(Ye, {
        src: cE,
        size: "16px",
        color: "rgba(255, 255, 255, 0.7)",
        className: "didagent__starter_message__arrow"
      })]
    }, i))
  });
}
const dE = (t) => {
  t.style.display = "none", t.offsetHeight, t.offsetWidth, t.style.display = "";
};
function lE({
  streamState: t,
  connectionState: e,
  srcObject: n,
  idleVideo: r,
  isBlur: s,
  muted: o,
  posterImg: a,
  onVideoPlay: i,
  onVideoStop: c,
  onIdleLoad: u
}) {
  const p = pt(null), d = pt(), {
    configurations: l
  } = Ue($t), [h, v] = F(!1), g = e === G.Connected, f = HS();
  return oe(() => {
    n && p.current && (d.current = n);
  }, [n, p.current]), oe(() => {
    if (p.current)
      if (t === de.Start) {
        if (p.current.srcObject = d.current, f) {
          const m = WS();
          m && m >= 17 && (p.current.volume = 1), p.current.play().catch(() => {
          });
        }
      } else
        t === de.New && (v(!1), setTimeout(() => {
          p.current && (dE(p.current), p.current.srcObject = null);
        }, 500));
  }, [t]), w("div", {
    className: "didagent__embedded__video__container",
    "data-orientation": l.orientation,
    "data-blur": s,
    children: [w("video", {
      className: "didagent__embedded__video__idle",
      "data-testid": "didagent__video_idle",
      autoPlay: !0,
      playsInline: !0,
      poster: a,
      onLoadedData: u,
      src: r,
      muted: !0,
      loop: !0
    }), w("video", {
      "data-active": h,
      "data-testid": "didagent__video_stream",
      className: "didagent__embedded__video__stream",
      onPlay: () => {
        g && (v(!0), i == null || i());
      },
      muted: o || !g,
      ref: p,
      autoPlay: !0,
      playsInline: !0,
      onAbort: (m) => c == null ? void 0 : c(m),
      onPause: (m) => c == null ? void 0 : c(m)
    })]
  });
}
function hE({
  enabled: t,
  offline: e,
  styles: n,
  onClose: r,
  onError: s
}) {
  var Ns, Ls, zs, js;
  const {
    isAuthenticated: o
  } = Ue(ps), {
    disconnect: a,
    setStreamState: i,
    streamedMessage: c,
    streamState: u,
    connectionState: p,
    agentManager: d,
    setError: l,
    srcObject: h,
    connect: v,
    messages: g,
    reconnect: f,
    terminating: m
  } = Ue(Yn), {
    configurations: S,
    configure: y
  } = Ue($t), E = pt(!0), _ = pt(null), C = pt(null), R = pt(null), [T, A] = F(""), [U, K] = F(!1), [Y, J] = F(!1), [he, ve] = F(!1), [re, N] = F(!1), [X, Z] = F(!1), [ye, Ie] = F(0), [Ve, As] = F(!1);
  function Ms(V = !1) {
    C.current && (V || E.current) && C.current.scrollTo({
      top: C.current.scrollHeight,
      behavior: "smooth"
    });
  }
  const Os = S.chatMode && [M.TextOnly, M.Playground].includes(S.chatMode);
  oe(() => {
    (async () => {
      var xs;
      if (S.posterSrc)
        return;
      const Ne = (xs = d == null ? void 0 : d.agent) == null ? void 0 : xs.presenter;
      if (!Ne)
        return;
      const {
        type: lt,
        poster: Ce,
        source_url: ht,
        thumbnail: It
      } = Ne;
      let pr;
      if (lt === "clip")
        pr = It || Ce;
      else if (lt === "talk")
        pr = ht || It || Ce;
      else {
        y({
          chatMode: M.Maintenance
        });
        return;
      }
      const Ga = await VS(pr, $S);
      y({
        posterSrc: Ga
      });
    })();
  }, [(Ns = d == null ? void 0 : d.agent) == null ? void 0 : Ns.id, y]), oe(() => {
    h && _.current && (_.current.srcObject = h);
  }, [h]), DS(() => Ms(!0), [g, he]), oe(() => {
    [de.Buffering, de.Loading].includes(u) ? ve(!0) : [de.New, de.Fail].includes(u) && ve(!1);
  }, [u]), oe(() => {
    var V;
    re ? ve(!1) : (V = R.current) == null || V.focus();
  }, [re, c]), oe(() => {
    (Y || [M.Maintenance].includes(S.chatMode)) && y({
      loaderConfig: {
        ...S.loaderConfig,
        show: !1
      }
    });
  }, [y, Y, S.chatMode]), oe(() => {
    S.chatMode === M.Maintenance && (l(`${(d == null ? void 0 : d.agent.preview_name) || "Agent"} is not available at the moment`), a());
  }, [d, S.chatMode]);
  async function kn(V) {
    var lt;
    if (V = V.trim(), V === "")
      return;
    let Ne = !1;
    if (Lc.includes(p) && (await f(), Ne = !0), o) {
      if (![M.TextOnly, M.Playground].includes(S.chatMode) && (!C.current || V.trim().length === 0 || ![de.New].includes(u) || !([G.Connected].includes(p) || Ne)))
        return;
    } else
      return zt("agent-offline-onsend", {
        event: "click"
      }), e == null ? void 0 : e.onSend(T);
    d != null && d.starterMessages && d.starterMessages.indexOf(V) > -1 && zt("agent-starter-question", {
      event: "click",
      question: V
    }), A(""), i(de.Loading);
    try {
      if (!d)
        throw new Error("AgentManager is not available");
      const Ce = await d.chat(V).catch(async (ht) => {
        var It;
        if ((It = ht == null ? void 0 : ht.message) != null && It.includes("Playground chat limit exceeded"))
          throw new Error("Playground chat limit exceeded");
        return console.error("Error in sending message", ht), {
          chatMode: M.Maintenance,
          result: "Sorry, I am not available right now",
          matches: []
        };
      });
      if (Ce.chatMode && (d.changeMode(Ce.chatMode), Ce.chatMode === M.Maintenance))
        return s == null || s(new Error("Agent is in maintenance mode"), Ce), a();
      i([M.TextOnly, M.Playground].includes(Ce.chatMode) ? de.New : de.Buffering);
    } catch (Ce) {
      throw i(de.New), Ce;
    } finally {
      (lt = R.current) == null || lt.focus();
    }
  }
  async function Wa(V, Ne, lt) {
    if (!d)
      throw new Error("AgentManager is not available");
    return d.rate(Ne.id, V === tt.Positive ? 1 : -1, lt).then((Ce) => Ce.id).catch((Ce) => {
      throw console.error("Error in rating", Ce), new Error("Error in rating " + Ce.message);
    });
  }
  const Va = mn(async () => {
    var V;
    await a(), await v(), zt("agent-new-chat", {
      event: "click",
      agentId: (V = d == null ? void 0 : d.agent) == null ? void 0 : V.id
    });
  }, [d, v, a]), Ka = mn(() => {
    var Ne;
    const V = {
      opacity: +!!((Ne = S.loaderConfig) != null && Ne.show)
    };
    return S.loaderConfig.style === "opaque" ? {
      ...V,
      "--background-color": "var(--did-primary-black-90)"
    } : {
      ...V,
      "--background-color": "var(--did-primary-black-00030)",
      "--backdrop-filter": "blur(4px)"
    };
  }, [S.loaderConfig]), Ja = fu(() => {
    var V, Ne;
    return t && !!((Ne = (V = d == null ? void 0 : d.agent.knowledge) == null ? void 0 : V.embedder) != null && Ne.is_limited_language);
  }, [t, d == null ? void 0 : d.agent]), ks = S.loaderConfig.show || [de.Start, de.Loading, de.Buffering].includes(u) && !Os, Ds = ks || T.trim() === "";
  return w("div", {
    className: `didagent__embedded__container ${X ? "didagent__fullscreen" : ""}`,
    children: [w("div", {
      className: "didagent__embedded__container__loading",
      style: Ka(),
      children: [w(Ye, {
        src: Av,
        size: "64px",
        color: "var(--did-secondary-60)"
      }), w("span", {
        children: S.loaderConfig.text || ""
      })]
    }), w(lE, {
      posterImg: S.posterSrc,
      connectionState: p,
      streamState: u,
      srcObject: h,
      idleVideo: S.chatMode === M.Playground || (Ls = d == null ? void 0 : d.agent.presenter) == null ? void 0 : Ls.idle_video,
      muted: U,
      isBlur: S.chatMode === M.Maintenance,
      onVideoPlay: () => N(!0),
      onVideoStop: () => N(!1),
      onIdleLoad: () => J(!0)
    }), w(GS, {
      hide: ![M.TextOnly, M.Playground].includes(S.chatMode),
      content: `${S.chatMode === M.TextOnly && ((zs = d == null ? void 0 : d.agent) == null ? void 0 : zs.status) === "done" ? "Performance mode" : "Youre in preview mode"}, sound and face animations wont show`
    }), w(NP, {
      name: (d == null ? void 0 : d.agent.preview_name) ?? "Agent",
      icon: d == null ? void 0 : d.agent.logo,
      displayRestart: g.length > 1 || S.chatMode === M.Maintenance,
      onRestart: Va,
      restartDisabled: ![G.Connected, G.New, G.Disconnected, G.Fail].includes(p),
      displayMuteButton: !Os,
      onMute: () => K((V) => !V),
      muted: U,
      isRestarting: m,
      closeClassName: n == null ? void 0 : n.closeClassName,
      onClose: r,
      onEasterEgg: () => {
        console.log("onEaster"), Z(!X);
      }
    }), w("div", {
      className: "didagent__filler"
    }), S.chatMode !== M.Maintenance && w("div", {
      className: "didagent__main__container",
      children: [w(aE, {
        messages: g,
        isLoading: he,
        ref: C,
        onRate: Wa,
        onScroll: () => {
          C.current && (E.current = C.current.scrollHeight - C.current.scrollTop <= C.current.clientHeight + 20);
        },
        scrollToBottom: Ms
      }), w(JS, {
        display: Ja,
        content: `This agent only interacts in ${(js = d == null ? void 0 : d.agent.presenter.voice) == null ? void 0 : js.language}`
      }), w(pE, {
        show: g.length <= 1 && !S.loaderConfig.show,
        enabled: p === G.Connected || [M.TextOnly, M.Playground].includes(S.chatMode),
        messages: (d == null ? void 0 : d.starterMessages) ?? [],
        onClick: kn
      }), w("div", {
        className: "didagent__main__input",
        style: {
          height: ye > 1 ? "68px" : "52px",
          "--focus": Ve ? "white" : void 0
        },
        children: [w("textarea", {
          disabled: [M.Maintenance, M.DirectPlayback].includes(S.chatMode) || S.loaderConfig.show,
          ref: R,
          placeholder: "Type here...",
          value: T,
          maxLength: 790,
          onFocus: () => As(!0),
          onBlur: () => As(!1),
          onInput: (V) => {
            Ie(US(V.currentTarget)), A(V.currentTarget.value), Lc.includes(p) && f();
          },
          onKeyPress: async (V) => {
            !V.shiftKey && V.key === "Enter" && (V.preventDefault(), Ds || kn(T));
          }
        }), w(AP, {
          onSend: () => kn(T),
          onTranscript: kn,
          text: T,
          isSttSendDisabled: ks,
          isMessageSendDisabled: Ds,
          className: "didagent__main__input-send"
        })]
      })]
    })]
  });
}
function cg({
  offline: t,
  isOwner: e,
  didApiUrl: n,
  didSocketApiUrl: r,
  onError: s,
  customMixpanelKey: o,
  onAgentReady: a,
  styles: i,
  onClose: c,
  enabled: u = !0
}) {
  const {
    configurations: p
  } = Ue($t);
  return window.localStorage.setItem("track_enabled", (p.track ?? !0).toString()), Dc.mixpanelKey = o || Dc.mixpanelKey, NS((d) => s == null ? void 0 : s(d, {})), w(BS, {
    auth: p.auth,
    didApiUrl: n ?? bS,
    didSocketApiUrl: r ?? AS,
    children: w(FS, {
      agentId: p.agentId,
      enabled: u,
      onAgentReady: a,
      onError: s,
      children: w(hE, {
        enabled: u,
        offline: t,
        isOwner: e,
        styles: i,
        onClose: c,
        onError: s
      })
    })
  });
}
function vE(t, e) {
  return {
    cursor: t ? "pointer" : "progress",
    opacity: e || !t ? "0" : "1",
    pointerEvents: t ? "auto" : "none",
    border: e ? "none" : "3px solid var(--did-primary-black-300)",
    bottom: t ? "0" : "-50%"
  };
}
function fE(t) {
  const e = {
    opacity: +t,
    translate: t ? "0px -50%" : "0px -60%"
  };
  return t || (e.background = "transparent"), e;
}
function gE(t) {
  var h;
  const {
    configurations: e
  } = Ue($t), [n, r] = F(), [s, o] = F(!1), [a, i] = F(!1), [c, u] = F(!1), p = a && !c;
  if (oe(() => {
    var v;
    n && !((v = n.presenter) != null && v.idle_video) && n.preview_thumbnail && o(!0);
  }, [n]), oe(() => {
    s && setTimeout(() => {
      i(!0), setTimeout(() => {
        i(!1);
      }, 3e3);
    }, 3e3);
  }, [s]), !e.visible)
    return null;
  const d = (v) => {
    var g;
    r(v), (g = t.onAgentReady) == null || g.call(t, v);
  }, l = () => {
    var v;
    u(!1), (v = window.dataLayer) == null || v.push({
      event: "close_widget"
    });
  };
  return w("span", {
    className: "didagent__fabio",
    "data-position": e.position,
    "data-enabled": c,
    children: [w("button", {
      "data-testid": "didagent__fabio__button",
      style: vE(s, c),
      onClick: () => {
        var v;
        (v = window.dataLayer) == null || v.push({
          event: "open_widget"
        }), s && (u(!c), zt("agent-fab", {
          event: "click"
        }));
      },
      children: [w("div", {
        className: `didagent__fabio__speak_with ${c ? "didagent__transition_out" : ""}`,
        style: fE(p),
        children: w("div", {
          children: "Let's chat"
        })
      }), w("video", {
        src: (n == null ? void 0 : n.preview_url) ?? ((h = n == null ? void 0 : n.presenter) == null ? void 0 : h.idle_video),
        poster: n == null ? void 0 : n.preview_thumbnail,
        alt: "toggle fabio",
        autoPlay: !0,
        playsInline: !0,
        loop: !0,
        muted: !0,
        onLoadedData: () => {
          o(!0), zt("agent-fab", {
            event: "view"
          });
        }
      })]
    }), w("div", {
      onClick: (v) => v.stopPropagation(),
      className: "didagent__fabio__container",
      "data-enabled": c,
      "data-position": e.position,
      "data-orientation": e.orientation,
      children: w(cg, {
        ...t,
        onClose: l,
        enabled: c,
        onAgentReady: d
      })
    })]
  });
}
let _c = [];
function mE() {
  if (_c.length === 0) {
    const t = document.getElementById("d-id-agent-style");
    _c = t ? [t] : [];
  }
  return _c;
}
function SE(t) {
  const e = pt(null), {
    configurations: n
  } = Ue($t), [r, s] = F();
  return oe(() => {
    const o = mE();
    if (n.agentId) {
      if (!n.auth)
        throw new Error("No auth provider");
    } else
      throw new Error("No agent provider");
    if (n.mode === "fabio") {
      if (e.current) {
        const a = e.current.shadowRoot ? e.current.shadowRoot : e.current.attachShadow({
          mode: "open"
        });
        o.forEach((i) => a.appendChild(i)), s(rh(w(gE, {
          ...t
        }), a));
      }
    } else if (n.mode === "full") {
      const a = typeof n.targetElement == "string" ? document.getElementById(n.targetElement) : n.targetElement;
      if (n.targetElement) {
        if (!a)
          throw new Error(`No target element for id: ${n.targetElement}`);
      } else
        throw new Error("No target element id");
      const i = a.shadowRoot ? a.shadowRoot : a.attachShadow({
        mode: "open"
      });
      o.forEach((c) => i.appendChild(c)), s(rh(w(cg, {
        ...t
      }), i));
    } else
      throw new Error("Invalid mode");
  }, [n.mode, n.targetElement, n.agentId, n.auth]), w(xt, {
    children: [w("div", {
      ref: e,
      "data-testid": "didagent_root"
    }), r]
  });
}
const ug = Object.prototype.toString;
function pg(t) {
  switch (ug.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Pt(t, Error);
  }
}
function nr(t, e) {
  return ug.call(t) === `[object ${e}]`;
}
function dg(t) {
  return nr(t, "ErrorEvent");
}
function dh(t) {
  return nr(t, "DOMError");
}
function yE(t) {
  return nr(t, "DOMException");
}
function Rt(t) {
  return nr(t, "String");
}
function Hu(t) {
  return typeof t == "object" && t !== null && "__sentry_template_string__" in t && "__sentry_template_values__" in t;
}
function Wu(t) {
  return t === null || Hu(t) || typeof t != "object" && typeof t != "function";
}
function Hn(t) {
  return nr(t, "Object");
}
function ja(t) {
  return typeof Event < "u" && Pt(t, Event);
}
function CE(t) {
  return typeof Element < "u" && Pt(t, Element);
}
function _E(t) {
  return nr(t, "RegExp");
}
function xa(t) {
  return !!(t && t.then && typeof t.then == "function");
}
function RE(t) {
  return Hn(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t;
}
function Pt(t, e) {
  try {
    return t instanceof e;
  } catch {
    return !1;
  }
}
function lg(t) {
  return !!(typeof t == "object" && t !== null && (t.__isVue || t._isVue));
}
function xn(t, e = 0) {
  return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0, e)}...`;
}
function lh(t, e) {
  if (!Array.isArray(t))
    return "";
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    try {
      lg(s) ? n.push("[VueViewModel]") : n.push(String(s));
    } catch {
      n.push("[value cannot be serialized]");
    }
  }
  return n.join(e);
}
function PE(t, e, n = !1) {
  return Rt(t) ? _E(e) ? e.test(t) : Rt(e) ? n ? t === e : t.includes(e) : !1 : !1;
}
function ln(t, e = [], n = !1) {
  return e.some((r) => PE(t, r, n));
}
function EE(t, e, n = 250, r, s, o, a) {
  if (!o.exception || !o.exception.values || !a || !Pt(a.originalException, Error))
    return;
  const i = o.exception.values.length > 0 ? o.exception.values[o.exception.values.length - 1] : void 0;
  i && (o.exception.values = TE(
    $c(
      t,
      e,
      s,
      a.originalException,
      r,
      o.exception.values,
      i,
      0
    ),
    n
  ));
}
function $c(t, e, n, r, s, o, a, i) {
  if (o.length >= n + 1)
    return o;
  let c = [...o];
  if (Pt(r[s], Error)) {
    hh(a, i);
    const u = t(e, r[s]), p = c.length;
    vh(u, s, p, i), c = $c(
      t,
      e,
      n,
      r[s],
      s,
      [u, ...c],
      u,
      p
    );
  }
  return Array.isArray(r.errors) && r.errors.forEach((u, p) => {
    if (Pt(u, Error)) {
      hh(a, i);
      const d = t(e, u), l = c.length;
      vh(d, `errors[${p}]`, l, i), c = $c(
        t,
        e,
        n,
        u,
        s,
        [d, ...c],
        d,
        l
      );
    }
  }), c;
}
function hh(t, e) {
  t.mechanism = t.mechanism || { type: "generic", handled: !0 }, t.mechanism = {
    ...t.mechanism,
    ...t.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: e
  };
}
function vh(t, e, n, r) {
  t.mechanism = t.mechanism || { type: "generic", handled: !0 }, t.mechanism = {
    ...t.mechanism,
    type: "chained",
    source: e,
    exception_id: n,
    parent_id: r
  };
}
function TE(t, e) {
  return t.map((n) => (n.value && (n.value = xn(n.value, e)), n));
}
const Q = globalThis;
function Vu(t, e, n) {
  const r = Q, s = r.__SENTRY__ = r.__SENTRY__ || {};
  return s[t] || (s[t] = e());
}
const Bn = Q, wE = 80;
function Wn(t, e = {}) {
  if (!t)
    return "<unknown>";
  try {
    let n = t;
    const r = 5, s = [];
    let o = 0, a = 0;
    const i = " > ", c = i.length;
    let u;
    const p = Array.isArray(e) ? e : e.keyAttrs, d = !Array.isArray(e) && e.maxStringLength || wE;
    for (; n && o++ < r && (u = IE(n, p), !(u === "html" || o > 1 && a + s.length * c + u.length >= d)); )
      s.push(u), a += u.length, n = n.parentNode;
    return s.reverse().join(i);
  } catch {
    return "<unknown>";
  }
}
function IE(t, e) {
  const n = t, r = [];
  let s, o, a, i, c;
  if (!n || !n.tagName)
    return "";
  if (Bn.HTMLElement && n instanceof HTMLElement && n.dataset) {
    if (n.dataset.sentryComponent)
      return n.dataset.sentryComponent;
    if (n.dataset.sentryElement)
      return n.dataset.sentryElement;
  }
  r.push(n.tagName.toLowerCase());
  const u = e && e.length ? e.filter((d) => n.getAttribute(d)).map((d) => [d, n.getAttribute(d)]) : null;
  if (u && u.length)
    u.forEach((d) => {
      r.push(`[${d[0]}="${d[1]}"]`);
    });
  else if (n.id && r.push(`#${n.id}`), s = n.className, s && Rt(s))
    for (o = s.split(/\s+/), c = 0; c < o.length; c++)
      r.push(`.${o[c]}`);
  const p = ["aria-label", "type", "name", "title", "alt"];
  for (c = 0; c < p.length; c++)
    a = p[c], i = n.getAttribute(a), i && r.push(`[${a}="${i}"]`);
  return r.join("");
}
function bE() {
  try {
    return Bn.document.location.href;
  } catch {
    return "";
  }
}
function AE(t) {
  return Bn.document && Bn.document.querySelector ? Bn.document.querySelector(t) : null;
}
function hg(t) {
  if (!Bn.HTMLElement)
    return null;
  let e = t;
  const n = 5;
  for (let r = 0; r < n; r++) {
    if (!e)
      return null;
    if (e instanceof HTMLElement) {
      if (e.dataset.sentryComponent)
        return e.dataset.sentryComponent;
      if (e.dataset.sentryElement)
        return e.dataset.sentryElement;
    }
    e = e.parentNode;
  }
  return null;
}
const rr = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, ME = "Sentry Logger ", Uc = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
], ho = {};
function Ps(t) {
  if (!("console" in Q))
    return t();
  const e = Q.console, n = {}, r = Object.keys(ho);
  r.forEach((s) => {
    const o = ho[s];
    n[s] = e[s], e[s] = o;
  });
  try {
    return t();
  } finally {
    r.forEach((s) => {
      e[s] = n[s];
    });
  }
}
function OE() {
  let t = !1;
  const e = {
    enable: () => {
      t = !0;
    },
    disable: () => {
      t = !1;
    },
    isEnabled: () => t
  };
  return rr ? Uc.forEach((n) => {
    e[n] = (...r) => {
      t && Ps(() => {
        Q.console[n](`${ME}[${n}]:`, ...r);
      });
    };
  }) : Uc.forEach((n) => {
    e[n] = () => {
    };
  }), e;
}
const I = OE(), kE = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function DE(t) {
  return t === "http" || t === "https";
}
function Es(t, e = !1) {
  const { host: n, path: r, pass: s, port: o, projectId: a, protocol: i, publicKey: c } = t;
  return `${i}://${c}${e && s ? `:${s}` : ""}@${n}${o ? `:${o}` : ""}/${r && `${r}/`}${a}`;
}
function NE(t) {
  const e = kE.exec(t);
  if (!e) {
    Ps(() => {
      console.error(`Invalid Sentry Dsn: ${t}`);
    });
    return;
  }
  const [n, r, s = "", o, a = "", i] = e.slice(1);
  let c = "", u = i;
  const p = u.split("/");
  if (p.length > 1 && (c = p.slice(0, -1).join("/"), u = p.pop()), u) {
    const d = u.match(/^\d+/);
    d && (u = d[0]);
  }
  return vg({ host: o, pass: s, path: c, projectId: u, port: a, protocol: n, publicKey: r });
}
function vg(t) {
  return {
    protocol: t.protocol,
    publicKey: t.publicKey || "",
    pass: t.pass || "",
    host: t.host,
    port: t.port || "",
    path: t.path || "",
    projectId: t.projectId
  };
}
function LE(t) {
  if (!rr)
    return !0;
  const { port: e, projectId: n, protocol: r } = t;
  return ["protocol", "publicKey", "host", "projectId"].find((a) => t[a] ? !1 : (I.error(`Invalid Sentry Dsn: ${a} missing`), !0)) ? !1 : n.match(/^\d+$/) ? DE(r) ? e && isNaN(parseInt(e, 10)) ? (I.error(`Invalid Sentry Dsn: Invalid port ${e}`), !1) : !0 : (I.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1) : (I.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1);
}
function zE(t) {
  const e = typeof t == "string" ? NE(t) : vg(t);
  if (!(!e || !LE(e)))
    return e;
}
class ut extends Error {
  /** Display name of this error instance. */
  constructor(e, n = "warn") {
    super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n;
  }
}
function Pe(t, e, n) {
  if (!(e in t))
    return;
  const r = t[e], s = n(r);
  typeof s == "function" && fg(s, r), t[e] = s;
}
function rt(t, e, n) {
  try {
    Object.defineProperty(t, e, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value: n,
      writable: !0,
      configurable: !0
    });
  } catch {
    rr && I.log(`Failed to add non-enumerable property "${e}" to object`, t);
  }
}
function fg(t, e) {
  try {
    const n = e.prototype || {};
    t.prototype = e.prototype = n, rt(t, "__sentry_original__", e);
  } catch {
  }
}
function Ku(t) {
  return t.__sentry_original__;
}
function jE(t) {
  return Object.keys(t).map((e) => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&");
}
function gg(t) {
  if (pg(t))
    return {
      message: t.message,
      name: t.name,
      stack: t.stack,
      ...gh(t)
    };
  if (ja(t)) {
    const e = {
      type: t.type,
      target: fh(t.target),
      currentTarget: fh(t.currentTarget),
      ...gh(t)
    };
    return typeof CustomEvent < "u" && Pt(t, CustomEvent) && (e.detail = t.detail), e;
  } else
    return t;
}
function fh(t) {
  try {
    return CE(t) ? Wn(t) : Object.prototype.toString.call(t);
  } catch {
    return "<unknown>";
  }
}
function gh(t) {
  if (typeof t == "object" && t !== null) {
    const e = {};
    for (const n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e;
  } else
    return {};
}
function xE(t, e = 40) {
  const n = Object.keys(gg(t));
  if (n.sort(), !n.length)
    return "[object has no keys]";
  if (n[0].length >= e)
    return xn(n[0], e);
  for (let r = n.length; r > 0; r--) {
    const s = n.slice(0, r).join(", ");
    if (!(s.length > e))
      return r === n.length ? s : xn(s, e);
  }
  return "";
}
function je(t) {
  return Hc(t, /* @__PURE__ */ new Map());
}
function Hc(t, e) {
  if (BE(t)) {
    const n = e.get(t);
    if (n !== void 0)
      return n;
    const r = {};
    e.set(t, r);
    for (const s of Object.keys(t))
      typeof t[s] < "u" && (r[s] = Hc(t[s], e));
    return r;
  }
  if (Array.isArray(t)) {
    const n = e.get(t);
    if (n !== void 0)
      return n;
    const r = [];
    return e.set(t, r), t.forEach((s) => {
      r.push(Hc(s, e));
    }), r;
  }
  return t;
}
function BE(t) {
  if (!Hn(t))
    return !1;
  try {
    const e = Object.getPrototypeOf(t).constructor.name;
    return !e || e === "Object";
  } catch {
    return !0;
  }
}
const mg = 50, ir = "?", mh = /\(error: (.*)\)/, Sh = /captureMessage|captureException/;
function Sg(...t) {
  const e = t.sort((n, r) => n[0] - r[0]).map((n) => n[1]);
  return (n, r = 0, s = 0) => {
    const o = [], a = n.split(`
`);
    for (let i = r; i < a.length; i++) {
      const c = a[i];
      if (c.length > 1024)
        continue;
      const u = mh.test(c) ? c.replace(mh, "$1") : c;
      if (!u.match(/\S*Error: /)) {
        for (const p of e) {
          const d = p(u);
          if (d) {
            o.push(d);
            break;
          }
        }
        if (o.length >= mg + s)
          break;
      }
    }
    return FE(o.slice(s));
  };
}
function qE(t) {
  return Array.isArray(t) ? Sg(...t) : t;
}
function FE(t) {
  if (!t.length)
    return [];
  const e = Array.from(t);
  return /sentryWrapped/.test(e[e.length - 1].function || "") && e.pop(), e.reverse(), Sh.test(e[e.length - 1].function || "") && (e.pop(), Sh.test(e[e.length - 1].function || "") && e.pop()), e.slice(0, mg).map((n) => ({
    ...n,
    filename: n.filename || e[e.length - 1].filename,
    function: n.function || ir
  }));
}
const Rc = "<anonymous>";
function Et(t) {
  try {
    return !t || typeof t != "function" ? Rc : t.name || Rc;
  } catch {
    return Rc;
  }
}
const no = {}, yh = {};
function Tn(t, e) {
  no[t] = no[t] || [], no[t].push(e);
}
function wn(t, e) {
  yh[t] || (e(), yh[t] = !0);
}
function nt(t, e) {
  const n = t && no[t];
  if (n)
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        rr && I.error(
          `Error while triggering instrumentation handler.
Type: ${t}
Name: ${Et(r)}
Error:`,
          s
        );
      }
}
function $E(t) {
  const e = "console";
  Tn(e, t), wn(e, UE);
}
function UE() {
  "console" in Q && Uc.forEach(function(t) {
    t in Q.console && Pe(Q.console, t, function(e) {
      return ho[t] = e, function(...n) {
        nt("console", { args: n, level: t });
        const s = ho[t];
        s && s.apply(Q.console, n);
      };
    });
  });
}
const Wc = Q;
function yg() {
  if (!("fetch" in Wc))
    return !1;
  try {
    return new Headers(), new Request("http://www.example.com"), new Response(), !0;
  } catch {
    return !1;
  }
}
function Vc(t) {
  return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString());
}
function HE() {
  if (typeof EdgeRuntime == "string")
    return !0;
  if (!yg())
    return !1;
  if (Vc(Wc.fetch))
    return !0;
  let t = !1;
  const e = Wc.document;
  if (e && typeof e.createElement == "function")
    try {
      const n = e.createElement("iframe");
      n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = Vc(n.contentWindow.fetch)), e.head.removeChild(n);
    } catch (n) {
      rr && I.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n);
    }
  return t;
}
const Cg = 1e3;
function Ts() {
  return Date.now() / Cg;
}
function WE() {
  const { performance: t } = Q;
  if (!t || !t.now)
    return Ts;
  const e = Date.now() - t.now(), n = t.timeOrigin == null ? e : t.timeOrigin;
  return () => (n + t.now()) / Cg;
}
const He = WE(), Xe = (() => {
  const { performance: t } = Q;
  if (!t || !t.now)
    return;
  const e = 3600 * 1e3, n = t.now(), r = Date.now(), s = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e, o = s < e, a = t.timing && t.timing.navigationStart, c = typeof a == "number" ? Math.abs(a + n - r) : e, u = c < e;
  return o || u ? s <= c ? t.timeOrigin : a : r;
})();
function _g(t) {
  const e = "fetch";
  Tn(e, t), wn(e, VE);
}
function VE() {
  HE() && Pe(Q, "fetch", function(t) {
    return function(...e) {
      const { method: n, url: r } = KE(e), s = {
        args: e,
        fetchData: {
          method: n,
          url: r
        },
        startTimestamp: He() * 1e3
      };
      return nt("fetch", {
        ...s
      }), t.apply(Q, e).then(
        (o) => {
          const a = {
            ...s,
            endTimestamp: He() * 1e3,
            response: o
          };
          return nt("fetch", a), o;
        },
        (o) => {
          const a = {
            ...s,
            endTimestamp: He() * 1e3,
            error: o
          };
          throw nt("fetch", a), o;
        }
      );
    };
  });
}
function Kc(t, e) {
  return !!t && typeof t == "object" && !!t[e];
}
function Ch(t) {
  return typeof t == "string" ? t : t ? Kc(t, "url") ? t.url : t.toString ? t.toString() : "" : "";
}
function KE(t) {
  if (t.length === 0)
    return { method: "GET", url: "" };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: Ch(n),
      method: Kc(r, "method") ? String(r.method).toUpperCase() : "GET"
    };
  }
  const e = t[0];
  return {
    url: Ch(e),
    method: Kc(e, "method") ? String(e.method).toUpperCase() : "GET"
  };
}
let Hs = null;
function Rg(t) {
  const e = "error";
  Tn(e, t), wn(e, JE);
}
function JE() {
  Hs = Q.onerror, Q.onerror = function(t, e, n, r, s) {
    return nt("error", {
      column: r,
      error: s,
      line: n,
      msg: t,
      url: e
    }), Hs && !Hs.__SENTRY_LOADER__ ? Hs.apply(this, arguments) : !1;
  }, Q.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let Ws = null;
function Pg(t) {
  const e = "unhandledrejection";
  Tn(e, t), wn(e, GE);
}
function GE() {
  Ws = Q.onunhandledrejection, Q.onunhandledrejection = function(t) {
    return nt("unhandledrejection", t), Ws && !Ws.__SENTRY_LOADER__ ? Ws.apply(this, arguments) : !0;
  }, Q.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
function QE() {
  return "npm";
}
function YE() {
  const t = typeof WeakSet == "function", e = t ? /* @__PURE__ */ new WeakSet() : [];
  function n(s) {
    if (t)
      return e.has(s) ? !0 : (e.add(s), !1);
    for (let o = 0; o < e.length; o++)
      if (e[o] === s)
        return !0;
    return e.push(s), !1;
  }
  function r(s) {
    if (t)
      e.delete(s);
    else
      for (let o = 0; o < e.length; o++)
        if (e[o] === s) {
          e.splice(o, 1);
          break;
        }
  }
  return [n, r];
}
function ie() {
  const t = Q, e = t.crypto || t.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (e && e.randomUUID)
      return e.randomUUID().replace(/-/g, "");
    e && e.getRandomValues && (n = () => {
      const r = new Uint8Array(1);
      return e.getRandomValues(r), r[0];
    });
  } catch {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (r) => (
      // eslint-disable-next-line no-bitwise
      (r ^ (n() & 15) >> r / 4).toString(16)
    )
  );
}
function Eg(t) {
  return t.exception && t.exception.values ? t.exception.values[0] : void 0;
}
function pn(t) {
  const { message: e, event_id: n } = t;
  if (e)
    return e;
  const r = Eg(t);
  return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>";
}
function Jc(t, e, n) {
  const r = t.exception = t.exception || {}, s = r.values = r.values || [], o = s[0] = s[0] || {};
  o.value || (o.value = e || ""), o.type || (o.type = "Error");
}
function os(t, e) {
  const n = Eg(t);
  if (!n)
    return;
  const r = { type: "generic", handled: !0 }, s = n.mechanism;
  if (n.mechanism = { ...r, ...s, ...e }, e && "data" in e) {
    const o = { ...s && s.data, ...e.data };
    n.mechanism.data = o;
  }
}
function _h(t) {
  if (t && t.__sentry_captured__)
    return !0;
  try {
    rt(t, "__sentry_captured__", !0);
  } catch {
  }
  return !1;
}
function Tg(t) {
  return Array.isArray(t) ? t : [t];
}
function Ot(t, e = 100, n = 1 / 0) {
  try {
    return Gc("", t, e, n);
  } catch (r) {
    return { ERROR: `**non-serializable** (${r})` };
  }
}
function wg(t, e = 3, n = 100 * 1024) {
  const r = Ot(t, e);
  return tT(r) > n ? wg(t, e - 1, n) : r;
}
function Gc(t, e, n = 1 / 0, r = 1 / 0, s = YE()) {
  const [o, a] = s;
  if (e == null || // this matches null and undefined -> eqeq not eqeqeq
  ["number", "boolean", "string"].includes(typeof e) && !Number.isNaN(e))
    return e;
  const i = ZE(t, e);
  if (!i.startsWith("[object "))
    return i;
  if (e.__sentry_skip_normalization__)
    return e;
  const c = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
  if (c === 0)
    return i.replace("object ", "");
  if (o(e))
    return "[Circular ~]";
  const u = e;
  if (u && typeof u.toJSON == "function")
    try {
      const h = u.toJSON();
      return Gc("", h, c - 1, r, s);
    } catch {
    }
  const p = Array.isArray(e) ? [] : {};
  let d = 0;
  const l = gg(e);
  for (const h in l) {
    if (!Object.prototype.hasOwnProperty.call(l, h))
      continue;
    if (d >= r) {
      p[h] = "[MaxProperties ~]";
      break;
    }
    const v = l[h];
    p[h] = Gc(h, v, c - 1, r, s), d++;
  }
  return a(e), p;
}
function ZE(t, e) {
  try {
    if (t === "domain" && e && typeof e == "object" && e._events)
      return "[Domain]";
    if (t === "domainEmitter")
      return "[DomainEmitter]";
    if (typeof global < "u" && e === global)
      return "[Global]";
    if (typeof window < "u" && e === window)
      return "[Window]";
    if (typeof document < "u" && e === document)
      return "[Document]";
    if (lg(e))
      return "[VueViewModel]";
    if (RE(e))
      return "[SyntheticEvent]";
    if (typeof e == "number" && e !== e)
      return "[NaN]";
    if (typeof e == "function")
      return `[Function: ${Et(e)}]`;
    if (typeof e == "symbol")
      return `[${String(e)}]`;
    if (typeof e == "bigint")
      return `[BigInt: ${String(e)}]`;
    const n = XE(e);
    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`;
  } catch (n) {
    return `**non-serializable** (${n})`;
  }
}
function XE(t) {
  const e = Object.getPrototypeOf(t);
  return e ? e.constructor.name : "null prototype";
}
function eT(t) {
  return ~-encodeURI(t).split(/%..|./).length;
}
function tT(t) {
  return eT(JSON.stringify(t));
}
var St;
(function(t) {
  t[t.PENDING = 0] = "PENDING";
  const n = 1;
  t[t.RESOLVED = n] = "RESOLVED";
  const r = 2;
  t[t.REJECTED = r] = "REJECTED";
})(St || (St = {}));
function Cn(t) {
  return new Qe((e) => {
    e(t);
  });
}
function vo(t) {
  return new Qe((e, n) => {
    n(t);
  });
}
class Qe {
  constructor(e) {
    Qe.prototype.__init.call(this), Qe.prototype.__init2.call(this), Qe.prototype.__init3.call(this), Qe.prototype.__init4.call(this), this._state = St.PENDING, this._handlers = [];
    try {
      e(this._resolve, this._reject);
    } catch (n) {
      this._reject(n);
    }
  }
  /** JSDoc */
  then(e, n) {
    return new Qe((r, s) => {
      this._handlers.push([
        !1,
        (o) => {
          if (!e)
            r(o);
          else
            try {
              r(e(o));
            } catch (a) {
              s(a);
            }
        },
        (o) => {
          if (!n)
            s(o);
          else
            try {
              r(n(o));
            } catch (a) {
              s(a);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(e) {
    return this.then((n) => n, e);
  }
  /** JSDoc */
  finally(e) {
    return new Qe((n, r) => {
      let s, o;
      return this.then(
        (a) => {
          o = !1, s = a, e && e();
        },
        (a) => {
          o = !0, s = a, e && e();
        }
      ).then(() => {
        if (o) {
          r(s);
          return;
        }
        n(s);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (e) => {
      this._setResult(St.RESOLVED, e);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (e) => {
      this._setResult(St.REJECTED, e);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (e, n) => {
      if (this._state === St.PENDING) {
        if (xa(n)) {
          n.then(this._resolve, this._reject);
          return;
        }
        this._state = e, this._value = n, this._executeHandlers();
      }
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === St.PENDING)
        return;
      const e = this._handlers.slice();
      this._handlers = [], e.forEach((n) => {
        n[0] || (this._state === St.RESOLVED && n[1](this._value), this._state === St.REJECTED && n[2](this._value), n[0] = !0);
      });
    };
  }
}
function nT(t) {
  const e = [];
  function n() {
    return t === void 0 || e.length < t;
  }
  function r(a) {
    return e.splice(e.indexOf(a), 1)[0];
  }
  function s(a) {
    if (!n())
      return vo(new ut("Not adding Promise because buffer limit was reached."));
    const i = a();
    return e.indexOf(i) === -1 && e.push(i), i.then(() => r(i)).then(
      null,
      () => r(i).then(null, () => {
      })
    ), i;
  }
  function o(a) {
    return new Qe((i, c) => {
      let u = e.length;
      if (!u)
        return i(!0);
      const p = setTimeout(() => {
        a && a > 0 && i(!1);
      }, a);
      e.forEach((d) => {
        Cn(d).then(() => {
          --u || (clearTimeout(p), i(!0));
        }, c);
      });
    });
  }
  return {
    $: e,
    add: s,
    drain: o
  };
}
function hn(t) {
  if (!t)
    return {};
  const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!e)
    return {};
  const n = e[6] || "", r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r
    // everything minus origin
  };
}
const rT = ["fatal", "error", "warning", "log", "info", "debug"];
function iT(t) {
  return t === "warn" ? "warning" : rT.includes(t) ? t : "log";
}
const Qc = "baggage", Ig = "sentry-", sT = /^sentry-/, oT = 8192;
function aT(t) {
  const e = cT(t);
  if (!e)
    return;
  const n = Object.entries(e).reduce((r, [s, o]) => {
    if (s.match(sT)) {
      const a = s.slice(Ig.length);
      r[a] = o;
    }
    return r;
  }, {});
  if (Object.keys(n).length > 0)
    return n;
}
function bg(t) {
  if (!t)
    return;
  const e = Object.entries(t).reduce(
    (n, [r, s]) => (s && (n[`${Ig}${r}`] = s), n),
    {}
  );
  return uT(e);
}
function cT(t) {
  if (!(!t || !Rt(t) && !Array.isArray(t)))
    return Array.isArray(t) ? t.reduce((e, n) => {
      const r = Rh(n);
      for (const s of Object.keys(r))
        e[s] = r[s];
      return e;
    }, {}) : Rh(t);
}
function Rh(t) {
  return t.split(",").map((e) => e.split("=").map((n) => decodeURIComponent(n.trim()))).reduce((e, [n, r]) => (e[n] = r, e), {});
}
function uT(t) {
  if (Object.keys(t).length !== 0)
    return Object.entries(t).reduce((e, [n, r], s) => {
      const o = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`, a = s === 0 ? o : `${e},${o}`;
      return a.length > oT ? (rr && I.warn(
        `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`
      ), e) : a;
    }, "");
}
const pT = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
  // whitespace
);
function dT(t) {
  if (!t)
    return;
  const e = t.match(pT);
  if (!e)
    return;
  let n;
  return e[3] === "1" ? n = !0 : e[3] === "0" && (n = !1), {
    traceId: e[1],
    parentSampled: n,
    parentSpanId: e[2]
  };
}
function lT(t, e) {
  const n = dT(t), r = aT(e), { traceId: s, parentSpanId: o, parentSampled: a } = n || {};
  return n ? {
    traceId: s || ie(),
    parentSpanId: o || ie().substring(16),
    spanId: ie().substring(16),
    sampled: a,
    dsc: r || {}
    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
  } : {
    traceId: s || ie(),
    spanId: ie().substring(16)
  };
}
function Ju(t = ie(), e = ie().substring(16), n) {
  let r = "";
  return n !== void 0 && (r = n ? "-1" : "-0"), `${t}-${e}${r}`;
}
function sr(t, e = []) {
  return [t, e];
}
function hT(t, e) {
  const [n, r] = t;
  return [n, [...r, e]];
}
function Ph(t, e) {
  const n = t[1];
  for (const r of n) {
    const s = r[0].type;
    if (e(r, s))
      return !0;
  }
  return !1;
}
function Yc(t) {
  return Q.__SENTRY__ && Q.__SENTRY__.encodePolyfill ? Q.__SENTRY__.encodePolyfill(t) : new TextEncoder().encode(t);
}
function vT(t) {
  const [e, n] = t;
  let r = JSON.stringify(e);
  function s(o) {
    typeof r == "string" ? r = typeof o == "string" ? r + o : [Yc(r), o] : r.push(typeof o == "string" ? Yc(o) : o);
  }
  for (const o of n) {
    const [a, i] = o;
    if (s(`
${JSON.stringify(a)}
`), typeof i == "string" || i instanceof Uint8Array)
      s(i);
    else {
      let c;
      try {
        c = JSON.stringify(i);
      } catch {
        c = JSON.stringify(Ot(i));
      }
      s(c);
    }
  }
  return typeof r == "string" ? r : fT(r);
}
function fT(t) {
  const e = t.reduce((s, o) => s + o.length, 0), n = new Uint8Array(e);
  let r = 0;
  for (const s of t)
    n.set(s, r), r += s.length;
  return n;
}
function gT(t) {
  return [{
    type: "span"
  }, t];
}
function mT(t) {
  const e = typeof t.data == "string" ? Yc(t.data) : t.data;
  return [
    je({
      type: "attachment",
      length: e.length,
      filename: t.filename,
      content_type: t.contentType,
      attachment_type: t.attachmentType
    }),
    e
  ];
}
const ST = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket"
};
function Eh(t) {
  return ST[t];
}
function Ag(t) {
  if (!t || !t.sdk)
    return;
  const { name: e, version: n } = t.sdk;
  return { name: e, version: n };
}
function yT(t, e, n, r) {
  const s = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...e && { sdk: e },
    ...!!n && r && { dsn: Es(r) },
    ...s && {
      trace: je({ ...s })
    }
  };
}
function CT(t, e, n) {
  const r = [
    { type: "client_report" },
    {
      timestamp: Ts(),
      discarded_events: t
    }
  ];
  return sr(e ? { dsn: e } : {}, [r]);
}
const _T = 60 * 1e3;
function RT(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n))
    return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? _T : r - e;
}
function PT(t, e) {
  return t[e] || t.all || 0;
}
function ET(t, e, n = Date.now()) {
  return PT(t, e) > n;
}
function TT(t, { statusCode: e, headers: n }, r = Date.now()) {
  const s = {
    ...t
  }, o = n && n["x-sentry-rate-limits"], a = n && n["retry-after"];
  if (o)
    for (const i of o.trim().split(",")) {
      const [c, u, , , p] = i.split(":", 5), d = parseInt(c, 10), l = (isNaN(d) ? 60 : d) * 1e3;
      if (!u)
        s.all = r + l;
      else
        for (const h of u.split(";"))
          h === "metric_bucket" ? (!p || p.split(";").includes("custom")) && (s[h] = r + l) : s[h] = r + l;
    }
  else
    a ? s.all = r + RT(a, r) : e === 429 && (s.all = r + 60 * 1e3);
  return s;
}
function wT(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], o = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = o(n)) : (s === "call" || s === "optionalCall") && (n = o((...a) => n.call(e, ...a)), e = void 0);
  }
  return n;
}
const Vs = Q;
function IT() {
  const t = Vs.chrome, e = t && t.app && t.app.runtime, n = "history" in Vs && !!Vs.history.pushState && !!Vs.history.replaceState;
  return !e && n;
}
const W = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function In() {
  return Ba(Q), Q;
}
function Ba(t) {
  return t.__SENTRY__ || (t.__SENTRY__ = {
    extensions: {}
  }), t.__SENTRY__;
}
function bT(t) {
  const e = He(), n = {
    sid: ie(),
    init: !0,
    timestamp: e,
    started: e,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: !1,
    toJSON: () => MT(n)
  };
  return t && Vn(n, t), n;
}
function Vn(t, e = {}) {
  if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || He(), e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : ie()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration)
    t.duration = void 0;
  else if (typeof e.duration == "number")
    t.duration = e.duration;
  else {
    const n = t.timestamp - t.started;
    t.duration = n >= 0 ? n : 0;
  }
  e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status);
}
function AT(t, e) {
  let n = {};
  t.status === "ok" && (n = { status: "exited" }), Vn(t, n);
}
function MT(t) {
  return je({
    sid: `${t.sid}`,
    init: t.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(t.started * 1e3).toISOString(),
    timestamp: new Date(t.timestamp * 1e3).toISOString(),
    status: t.status,
    errors: t.errors,
    did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
    duration: t.duration,
    abnormal_mechanism: t.abnormal_mechanism,
    attrs: {
      release: t.release,
      environment: t.environment,
      ip_address: t.ipAddress,
      user_agent: t.userAgent
    }
  });
}
const Zc = "_sentrySpan";
function as(t, e) {
  e ? rt(t, Zc, e) : delete t[Zc];
}
function fo(t) {
  return t[Zc];
}
const OT = 100;
class Gu {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = Th();
  }
  /**
   * @inheritDoc
   */
  clone() {
    const e = new Gu();
    return e._breadcrumbs = [...this._breadcrumbs], e._tags = { ...this._tags }, e._extra = { ...this._extra }, e._contexts = { ...this._contexts }, e._user = this._user, e._level = this._level, e._session = this._session, e._transactionName = this._transactionName, e._fingerprint = this._fingerprint, e._eventProcessors = [...this._eventProcessors], e._requestSession = this._requestSession, e._attachments = [...this._attachments], e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, e._propagationContext = { ...this._propagationContext }, e._client = this._client, e._lastEventId = this._lastEventId, as(e, fo(this)), e;
  }
  /**
   * @inheritDoc
   */
  setClient(e) {
    this._client = e;
  }
  /**
   * @inheritDoc
   */
  setLastEventId(e) {
    this._lastEventId = e;
  }
  /**
   * @inheritDoc
   */
  getClient() {
    return this._client;
  }
  /**
   * @inheritDoc
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(e) {
    this._scopeListeners.push(e);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(e) {
    return this._eventProcessors.push(e), this;
  }
  /**
   * @inheritDoc
   */
  setUser(e) {
    return this._user = e || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    }, this._session && Vn(this._session, { user: e }), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(e) {
    return this._requestSession = e, this;
  }
  /**
   * @inheritDoc
   */
  setTags(e) {
    return this._tags = {
      ...this._tags,
      ...e
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTag(e, n) {
    return this._tags = { ...this._tags, [e]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtras(e) {
    return this._extra = {
      ...this._extra,
      ...e
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtra(e, n) {
    return this._extra = { ...this._extra, [e]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(e) {
    return this._fingerprint = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setLevel(e) {
    return this._level = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTransactionName(e) {
    return this._transactionName = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setContext(e, n) {
    return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setSession(e) {
    return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(e) {
    if (!e)
      return this;
    const n = typeof e == "function" ? e(this) : e, [r, s] = n instanceof _n ? [n.getScopeData(), n.getRequestSession()] : Hn(n) ? [e, e.requestSession] : [], { tags: o, extra: a, user: i, contexts: c, level: u, fingerprint: p = [], propagationContext: d } = r || {};
    return this._tags = { ...this._tags, ...o }, this._extra = { ...this._extra, ...a }, this._contexts = { ...this._contexts, ...c }, i && Object.keys(i).length && (this._user = i), u && (this._level = u), p.length && (this._fingerprint = p), d && (this._propagationContext = d), s && (this._requestSession = s), this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, as(this, void 0), this._attachments = [], this._propagationContext = Th(), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(e, n) {
    const r = typeof n == "number" ? n : OT;
    if (r <= 0)
      return this;
    const s = {
      timestamp: Ts(),
      ...e
    }, o = this._breadcrumbs;
    return o.push(s), this._breadcrumbs = o.length > r ? o.slice(-r) : o, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(e) {
    return this._attachments.push(e), this;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    return this._attachments = [], this;
  }
  /** @inheritDoc */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: fo(this)
    };
  }
  /**
   * @inheritDoc
   */
  setSDKProcessingMetadata(e) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...e }, this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(e) {
    return this._propagationContext = e, this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * @inheritDoc
   */
  captureException(e, n) {
    const r = n && n.event_id ? n.event_id : ie();
    if (!this._client)
      return I.warn("No client configured on scope - will not capture exception!"), r;
    const s = new Error("Sentry syntheticException");
    return this._client.captureException(
      e,
      {
        originalException: e,
        syntheticException: s,
        ...n,
        event_id: r
      },
      this
    ), r;
  }
  /**
   * @inheritDoc
   */
  captureMessage(e, n, r) {
    const s = r && r.event_id ? r.event_id : ie();
    if (!this._client)
      return I.warn("No client configured on scope - will not capture message!"), s;
    const o = new Error(e);
    return this._client.captureMessage(
      e,
      n,
      {
        originalException: e,
        syntheticException: o,
        ...r,
        event_id: s
      },
      this
    ), s;
  }
  /**
   * @inheritDoc
   */
  captureEvent(e, n) {
    const r = n && n.event_id ? n.event_id : ie();
    return this._client ? (this._client.captureEvent(e, { ...n, event_id: r }, this), r) : (I.warn("No client configured on scope - will not capture event!"), r);
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((e) => {
      e(this);
    }), this._notifyingListeners = !1);
  }
}
const _n = Gu;
function Th() {
  return {
    traceId: ie(),
    spanId: ie().substring(16)
  };
}
function kT() {
  return Vu("defaultCurrentScope", () => new _n());
}
function DT() {
  return Vu("defaultIsolationScope", () => new _n());
}
class NT {
  constructor(e, n) {
    let r;
    e ? r = e : r = new _n();
    let s;
    n ? s = n : s = new _n(), this._stack = [{ scope: r }], this._isolationScope = s;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(e) {
    const n = this._pushScope();
    let r;
    try {
      r = e(n);
    } catch (s) {
      throw this._popScope(), s;
    }
    return xa(r) ? r.then(
      (s) => (this._popScope(), s),
      (s) => {
        throw this._popScope(), s;
      }
    ) : (this._popScope(), r);
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the scope stack for domains or the process.
   */
  getStack() {
    return this._stack;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const e = this.getScope().clone();
    return this.getStack().push({
      client: this.getClient(),
      scope: e
    }), e;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop();
  }
}
function Kn() {
  const t = In(), e = Ba(t);
  return e.hub || (e.hub = new NT(kT(), DT())), e.hub;
}
function LT(t) {
  return Kn().withScope(t);
}
function zT(t, e) {
  const n = Kn();
  return n.withScope(() => (n.getStackTop().scope = t, e(t)));
}
function wh(t) {
  return Kn().withScope(() => t(Kn().getIsolationScope()));
}
function jT() {
  return {
    withIsolationScope: wh,
    withScope: LT,
    withSetScope: zT,
    withSetIsolationScope: (t, e) => wh(e),
    getCurrentScope: () => Kn().getScope(),
    getIsolationScope: () => Kn().getIsolationScope()
  };
}
function ws(t) {
  const e = Ba(t);
  return e.acs ? e.acs : jT();
}
function ae() {
  const t = In();
  return ws(t).getCurrentScope();
}
function wt() {
  const t = In();
  return ws(t).getIsolationScope();
}
function Mg() {
  return Vu("globalScope", () => new _n());
}
function Qu(...t) {
  const e = In(), n = ws(e);
  if (t.length === 2) {
    const [r, s] = t;
    return r ? n.withSetScope(r, s) : n.withScope(s);
  }
  return n.withScope(t[0]);
}
function te() {
  return ae().getClient();
}
const Nt = "sentry.source", Og = "sentry.sample_rate", cs = "sentry.op", xe = "sentry.origin", Xc = "sentry.idle_span_finish_reason", Yu = "sentry.measurement_unit", Zu = "sentry.measurement_value", xT = "sentry.profile_id", kg = "sentry.exclusive_time", BT = 0, Dg = 1, ge = 2;
function qT(t) {
  if (t < 400 && t >= 100)
    return { code: Dg };
  if (t >= 400 && t < 500)
    switch (t) {
      case 401:
        return { code: ge, message: "unauthenticated" };
      case 403:
        return { code: ge, message: "permission_denied" };
      case 404:
        return { code: ge, message: "not_found" };
      case 409:
        return { code: ge, message: "already_exists" };
      case 413:
        return { code: ge, message: "failed_precondition" };
      case 429:
        return { code: ge, message: "resource_exhausted" };
      case 499:
        return { code: ge, message: "cancelled" };
      default:
        return { code: ge, message: "invalid_argument" };
    }
  if (t >= 500 && t < 600)
    switch (t) {
      case 501:
        return { code: ge, message: "unimplemented" };
      case 503:
        return { code: ge, message: "unavailable" };
      case 504:
        return { code: ge, message: "deadline_exceeded" };
      default:
        return { code: ge, message: "internal_error" };
    }
  return { code: ge, message: "unknown_error" };
}
function Ng(t, e) {
  t.setAttribute("http.response.status_code", e);
  const n = qT(e);
  n.message !== "unknown_error" && t.setStatus(n);
}
const Lg = 0, zg = 1;
function FT(t) {
  const { spanId: e, traceId: n } = t.spanContext(), { data: r, op: s, parent_span_id: o, status: a, origin: i } = ee(t);
  return je({
    parent_span_id: o,
    span_id: e,
    trace_id: n,
    data: r,
    op: s,
    status: a,
    origin: i
  });
}
function $T(t) {
  const { spanId: e, traceId: n } = t.spanContext(), { parent_span_id: r } = ee(t);
  return je({ parent_span_id: r, span_id: e, trace_id: n });
}
function jg(t) {
  const { traceId: e, spanId: n } = t.spanContext(), r = bn(t);
  return Ju(e, n, r);
}
function vn(t) {
  return typeof t == "number" ? Ih(t) : Array.isArray(t) ? t[0] + t[1] / 1e9 : t instanceof Date ? Ih(t.getTime()) : He();
}
function Ih(t) {
  return t > 9999999999 ? t / 1e3 : t;
}
function ee(t) {
  if (HT(t))
    return t.getSpanJSON();
  try {
    const { spanId: e, traceId: n } = t.spanContext();
    if (UT(t)) {
      const { attributes: r, startTime: s, name: o, endTime: a, parentSpanId: i, status: c } = t;
      return je({
        span_id: e,
        trace_id: n,
        data: r,
        description: o,
        parent_span_id: i,
        start_timestamp: vn(s),
        // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
        timestamp: vn(a) || void 0,
        status: xg(c),
        op: r[cs],
        origin: r[xe],
        _metrics_summary: void 0
      });
    }
    return {
      span_id: e,
      trace_id: n
    };
  } catch {
    return {};
  }
}
function UT(t) {
  const e = t;
  return !!e.attributes && !!e.startTime && !!e.name && !!e.endTime && !!e.status;
}
function HT(t) {
  return typeof t.getSpanJSON == "function";
}
function bn(t) {
  const { traceFlags: e } = t.spanContext();
  return e === zg;
}
function xg(t) {
  if (!(!t || t.code === BT))
    return t.code === Dg ? "ok" : t.message || "unknown_error";
}
const Lt = "_sentryChildSpans", eu = "_sentryRootSpan";
function Bg(t, e) {
  const n = t[eu] || t;
  rt(e, eu, n), t[Lt] && t[Lt].size < 1e3 ? t[Lt].add(e) : rt(t, Lt, /* @__PURE__ */ new Set([e]));
}
function WT(t, e) {
  t[Lt] && t[Lt].delete(e);
}
function ro(t) {
  const e = /* @__PURE__ */ new Set();
  function n(r) {
    if (!e.has(r) && bn(r)) {
      e.add(r);
      const s = r[Lt] ? Array.from(r[Lt]) : [];
      for (const o of s)
        n(o);
    }
  }
  return n(t), Array.from(e);
}
function We(t) {
  return t[eu] || t;
}
function et() {
  const t = In(), e = ws(t);
  return e.getActiveSpan ? e.getActiveSpan() : fo(ae());
}
let bh = !1;
function VT() {
  bh || (bh = !0, Rg(tu), Pg(tu));
}
function tu() {
  const t = et(), e = t && We(t);
  if (e) {
    const n = "internal_error";
    W && I.log(`[Tracing] Root span: ${n} -> Global error occured`), e.setStatus({ code: ge, message: n });
  }
}
tu.tag = "sentry_tracingErrorCallback";
const qg = "_sentryScope", Fg = "_sentryIsolationScope";
function KT(t, e, n) {
  t && (rt(t, Fg, n), rt(t, qg, e));
}
function Ah(t) {
  return {
    scope: t[qg],
    isolationScope: t[Fg]
  };
}
function Ft(t) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
    return !1;
  const e = t || JT();
  return !!e && (e.enableTracing || "tracesSampleRate" in e || "tracesSampler" in e);
}
function JT() {
  const t = te();
  return t && t.getOptions();
}
class or {
  constructor(e = {}) {
    this._traceId = e.traceId || ie(), this._spanId = e.spanId || ie().substring(16);
  }
  /** @inheritdoc */
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: Lg
    };
  }
  /** @inheritdoc */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  end(e) {
  }
  /** @inheritdoc */
  setAttribute(e, n) {
    return this;
  }
  /** @inheritdoc */
  setAttributes(e) {
    return this;
  }
  /** @inheritdoc */
  setStatus(e) {
    return this;
  }
  /** @inheritdoc */
  updateName(e) {
    return this;
  }
  /** @inheritdoc */
  isRecording() {
    return !1;
  }
  /** @inheritdoc */
  addEvent(e, n, r) {
    return this;
  }
}
const Xu = "production", $g = "_frozenDsc";
function Mh(t, e) {
  rt(t, $g, e);
}
function qa(t, e) {
  const n = e.getOptions(), { publicKey: r } = e.getDsn() || {}, s = je({
    environment: n.environment || Xu,
    release: n.release,
    public_key: r,
    trace_id: t
  });
  return e.emit("createDsc", s), s;
}
function An(t) {
  const e = te();
  if (!e)
    return {};
  const n = qa(ee(t).trace_id || "", e), r = We(t);
  if (!r)
    return n;
  const s = r[$g];
  if (s)
    return s;
  const o = ee(r), a = o.data || {}, i = a[Og];
  i != null && (n.sample_rate = `${i}`);
  const c = a[Nt];
  return c && c !== "url" && (n.transaction = o.description), n.sampled = String(bn(r)), e.emit("createDsc", n), n;
}
function GT(t) {
  if (!W)
    return;
  const { description: e = "< unknown name >", op: n = "< unknown op >", parent_span_id: r } = ee(t), { spanId: s } = t.spanContext(), o = bn(t), a = We(t), i = a === t, c = `[Tracing] Starting ${o ? "sampled" : "unsampled"} ${i ? "root " : ""}span`, u = [`op: ${n}`, `name: ${e}`, `ID: ${s}`];
  if (r && u.push(`parent ID: ${r}`), !i) {
    const { op: p, description: d } = ee(a);
    u.push(`root ID: ${a.spanContext().spanId}`), p && u.push(`root op: ${p}`), d && u.push(`root description: ${d}`);
  }
  I.log(`${c}
  ${u.join(`
  `)}`);
}
function QT(t) {
  if (!W)
    return;
  const { description: e = "< unknown name >", op: n = "< unknown op >" } = ee(t), { spanId: r } = t.spanContext(), o = We(t) === t, a = `[Tracing] Finishing "${n}" ${o ? "root " : ""}span "${e}" with ID ${r}`;
  I.log(a);
}
function Ug(t) {
  if (typeof t == "boolean")
    return Number(t);
  const e = typeof t == "string" ? parseFloat(t) : t;
  if (typeof e != "number" || isNaN(e) || e < 0 || e > 1) {
    W && I.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        t
      )} of type ${JSON.stringify(typeof t)}.`
    );
    return;
  }
  return e;
}
function YT(t, e) {
  if (!Ft(t))
    return [!1];
  let n;
  typeof t.tracesSampler == "function" ? n = t.tracesSampler(e) : e.parentSampled !== void 0 ? n = e.parentSampled : typeof t.tracesSampleRate < "u" ? n = t.tracesSampleRate : n = 1;
  const r = Ug(n);
  return r === void 0 ? (W && I.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]) : r ? Math.random() < r ? [!0, r] : (W && I.log(
    `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
      n
    )})`
  ), [!1, r]) : (W && I.log(
    `[Tracing] Discarding transaction because ${typeof t.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
  ), [!1, r]);
}
function ZT(t, e) {
  return e && (t.sdk = t.sdk || {}, t.sdk.name = t.sdk.name || e.name, t.sdk.version = t.sdk.version || e.version, t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []], t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]), t;
}
function XT(t, e, n, r) {
  const s = Ag(n), o = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...s && { sdk: s },
    ...!!r && e && { dsn: Es(e) }
  }, a = "aggregates" in t ? [{ type: "sessions" }, t] : [{ type: "session" }, t.toJSON()];
  return sr(o, [a]);
}
function ew(t, e, n, r) {
  const s = Ag(n), o = t.type && t.type !== "replay_event" ? t.type : "event";
  ZT(t, n && n.sdk);
  const a = yT(t, s, r, e);
  return delete t.sdkProcessingMetadata, sr(a, [[{ type: o }, t]]);
}
function tw(t, e) {
  function n(p) {
    return !!p.trace_id && !!p.public_key;
  }
  const r = An(t[0]), s = e && e.getDsn(), o = e && e.getOptions().tunnel, a = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...n(r) && { trace: r },
    ...!!o && s && { dsn: Es(s) }
  }, i = e && e.getOptions().beforeSendSpan, c = i ? (p) => i(ee(p)) : (p) => ee(p), u = [];
  for (const p of t) {
    const d = c(p);
    d && u.push(gT(d));
  }
  return sr(a, u);
}
function nw(t, e, n) {
  const r = et(), s = r && We(r);
  s && s.addEvent(t, {
    [Zu]: e,
    [Yu]: n
  });
}
function Oh(t) {
  if (!t || t.length === 0)
    return;
  const e = {};
  return t.forEach((n) => {
    const r = n.attributes || {}, s = r[Yu], o = r[Zu];
    typeof s == "string" && typeof o == "number" && (e[n.name] = { value: o, unit: s });
  }), e;
}
class ep {
  /** Epoch timestamp in seconds when the span started. */
  /** Epoch timestamp in seconds when the span ended. */
  /** Internal keeper of the status */
  /** The timed events added to this span. */
  /** if true, treat span as a standalone span (not part of a transaction) */
  /**
   * You should never call the constructor manually, always use `Sentry.startSpan()`
   * or other span methods.
   * @internal
   * @hideconstructor
   * @hidden
   */
  constructor(e = {}) {
    this._traceId = e.traceId || ie(), this._spanId = e.spanId || ie().substring(16), this._startTime = e.startTimestamp || He(), this._attributes = {}, this.setAttributes({
      [xe]: "manual",
      [cs]: e.op,
      ...e.attributes
    }), this._name = e.name, e.parentSpanId && (this._parentSpanId = e.parentSpanId), "sampled" in e && (this._sampled = e.sampled), e.endTimestamp && (this._endTime = e.endTimestamp), this._events = [], this._isStandaloneSpan = e.isStandalone, this._endTime && this._onSpanEnded();
  }
  /** @inheritdoc */
  spanContext() {
    const { _spanId: e, _traceId: n, _sampled: r } = this;
    return {
      spanId: e,
      traceId: n,
      traceFlags: r ? zg : Lg
    };
  }
  /** @inheritdoc */
  setAttribute(e, n) {
    n === void 0 ? delete this._attributes[e] : this._attributes[e] = n;
  }
  /** @inheritdoc */
  setAttributes(e) {
    Object.keys(e).forEach((n) => this.setAttribute(n, e[n]));
  }
  /**
   * This should generally not be used,
   * but we need it for browser tracing where we want to adjust the start time afterwards.
   * USE THIS WITH CAUTION!
   *
   * @hidden
   * @internal
   */
  updateStartTime(e) {
    this._startTime = vn(e);
  }
  /**
   * @inheritDoc
   */
  setStatus(e) {
    return this._status = e, this;
  }
  /**
   * @inheritDoc
   */
  updateName(e) {
    return this._name = e, this;
  }
  /** @inheritdoc */
  end(e) {
    this._endTime || (this._endTime = vn(e), QT(this), this._onSpanEnded());
  }
  /**
   * Get JSON representation of this span.
   *
   * @hidden
   * @internal This method is purely for internal purposes and should not be used outside
   * of SDK code. If you need to get a JSON representation of a span,
   * use `spanToJSON(span)` instead.
   */
  getSpanJSON() {
    return je({
      data: this._attributes,
      description: this._name,
      op: this._attributes[cs],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: xg(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[xe],
      _metrics_summary: void 0,
      profile_id: this._attributes[xT],
      exclusive_time: this._attributes[kg],
      measurements: Oh(this._events),
      is_segment: this._isStandaloneSpan && We(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? We(this).spanContext().spanId : void 0
    });
  }
  /** @inheritdoc */
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  /**
   * @inheritdoc
   */
  addEvent(e, n, r) {
    W && I.log("[Tracing] Adding an event to span:", e);
    const s = kh(n) ? n : r || He(), o = kh(n) ? {} : n || {}, a = {
      name: e,
      time: vn(s),
      attributes: o
    };
    return this._events.push(a), this;
  }
  /**
   * This method should generally not be used,
   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.
   * USE THIS WITH CAUTION!
   * @internal
   * @hidden
   * @experimental
   */
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  /** Emit `spanEnd` when the span is ended. */
  _onSpanEnded() {
    const e = te();
    if (e && e.emit("spanEnd", this), !(this._isStandaloneSpan || this === We(this)))
      return;
    if (this._isStandaloneSpan) {
      iw(tw([this], e));
      return;
    }
    const r = this._convertSpanToTransaction();
    r && (Ah(this).scope || ae()).captureEvent(r);
  }
  /**
   * Finish the transaction & prepare the event to send to Sentry.
   */
  _convertSpanToTransaction() {
    if (!Dh(ee(this)))
      return;
    this._name || (W && I.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
    const { scope: e, isolationScope: n } = Ah(this), s = (e || ae()).getClient() || te();
    if (this._sampled !== !0) {
      W && I.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), s && s.recordDroppedEvent("sample_rate", "transaction");
      return;
    }
    const a = ro(this).filter((d) => d !== this && !rw(d)).map((d) => ee(d)).filter(Dh), i = this._attributes[Nt], c = {
      contexts: {
        trace: FT(this)
      },
      spans: a,
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope: e,
        capturedSpanIsolationScope: n,
        ...je({
          dynamicSamplingContext: An(this)
        })
      },
      _metrics_summary: void 0,
      ...i && {
        transaction_info: {
          source: i
        }
      }
    }, u = Oh(this._events);
    return u && Object.keys(u).length && (W && I.log("[Measurements] Adding measurements to transaction", JSON.stringify(u, void 0, 2)), c.measurements = u), c;
  }
}
function kh(t) {
  return t && typeof t == "number" || t instanceof Date || Array.isArray(t);
}
function Dh(t) {
  return !!t.start_timestamp && !!t.timestamp && !!t.span_id && !!t.trace_id;
}
function rw(t) {
  return t instanceof ep && t.isStandaloneSpan();
}
function iw(t) {
  const e = te();
  if (!e)
    return;
  const n = t[1];
  if (!n || n.length === 0) {
    e.recordDroppedEvent("before_send", "span");
    return;
  }
  const r = e.getTransport();
  r && r.send(t).then(null, (s) => {
    W && I.error("Error while sending span:", s);
  });
}
const Hg = "__SENTRY_SUPPRESS_TRACING__";
function Mn(t) {
  const e = Wg();
  if (e.startInactiveSpan)
    return e.startInactiveSpan(t);
  const n = aw(t), r = t.scope || ae(), s = uw(r);
  return t.onlyIfParent && !s ? new or() : ow({
    parentSpan: s,
    spanContext: n,
    forceTransaction: t.forceTransaction,
    scope: r
  });
}
function sw(t, e) {
  const n = Wg();
  return n.withActiveSpan ? n.withActiveSpan(t, e) : Qu((r) => (as(r, t || void 0), e(r)));
}
function ow({
  parentSpan: t,
  spanContext: e,
  forceTransaction: n,
  scope: r
}) {
  if (!Ft())
    return new or();
  const s = wt();
  let o;
  if (t && !n)
    o = cw(t, r, e), Bg(t, o);
  else if (t) {
    const a = An(t), { traceId: i, spanId: c } = t.spanContext(), u = bn(t);
    o = Nh(
      {
        traceId: i,
        parentSpanId: c,
        ...e
      },
      r,
      u
    ), Mh(o, a);
  } else {
    const {
      traceId: a,
      dsc: i,
      parentSpanId: c,
      sampled: u
    } = {
      ...s.getPropagationContext(),
      ...r.getPropagationContext()
    };
    o = Nh(
      {
        traceId: a,
        parentSpanId: c,
        ...e
      },
      r,
      u
    ), i && Mh(o, i);
  }
  return GT(o), KT(o, r, s), o;
}
function aw(t) {
  const n = {
    isStandalone: (t.experimental || {}).standalone,
    ...t
  };
  if (t.startTime) {
    const r = { ...n };
    return r.startTimestamp = vn(t.startTime), delete r.startTime, r;
  }
  return n;
}
function Wg() {
  const t = In();
  return ws(t);
}
function Nh(t, e, n) {
  const r = te(), s = r && r.getOptions() || {}, { name: o = "", attributes: a } = t, [i, c] = e.getScopeData().sdkProcessingMetadata[Hg] ? [!1] : YT(s, {
    name: o,
    parentSampled: n,
    attributes: a,
    transactionContext: {
      name: o,
      parentSampled: n
    }
  }), u = new ep({
    ...t,
    attributes: {
      [Nt]: "custom",
      ...t.attributes
    },
    sampled: i
  });
  return c !== void 0 && u.setAttribute(Og, c), r && r.emit("spanStart", u), u;
}
function cw(t, e, n) {
  const { spanId: r, traceId: s } = t.spanContext(), o = e.getScopeData().sdkProcessingMetadata[Hg] ? !1 : bn(t), a = o ? new ep({
    ...n,
    parentSpanId: r,
    traceId: s,
    sampled: o
  }) : new or({ traceId: s });
  Bg(t, a);
  const i = te();
  return i && (i.emit("spanStart", a), n.endTimestamp && i.emit("spanEnd", a)), a;
}
function uw(t) {
  const e = fo(t);
  if (!e)
    return;
  const n = te();
  return (n ? n.getOptions() : {}).parentSpanIsAlwaysRootSpan ? We(e) : e;
}
const io = {
  idleTimeout: 1e3,
  finalTimeout: 3e4,
  childSpanTimeout: 15e3
}, pw = "heartbeatFailed", dw = "idleTimeout", lw = "finalTimeout", hw = "externalFinish";
function Vg(t, e = {}) {
  const n = /* @__PURE__ */ new Map();
  let r = !1, s, o = hw, a = !e.disableAutoFinish;
  const {
    idleTimeout: i = io.idleTimeout,
    finalTimeout: c = io.finalTimeout,
    childSpanTimeout: u = io.childSpanTimeout,
    beforeSpanEnd: p
  } = e, d = te();
  if (!d || !Ft())
    return new or();
  const l = ae(), h = et(), v = vw(t);
  function g(C = He()) {
    const R = ro(v).filter((J) => J !== v);
    if (!R.length) {
      v.end(C);
      return;
    }
    const T = R.map((J) => ee(J).timestamp).filter((J) => !!J), A = T.length ? Math.max(...T) : void 0, U = vn(C), K = ee(v).start_timestamp, Y = Math.min(
      K ? K + c / 1e3 : 1 / 0,
      Math.max(K || -1 / 0, Math.min(U, A || 1 / 0))
    );
    v.end(Y);
  }
  function f() {
    s && (clearTimeout(s), s = void 0);
  }
  function m(C) {
    f(), s = setTimeout(() => {
      !r && n.size === 0 && a && (o = dw, g(C));
    }, i);
  }
  function S(C) {
    s = setTimeout(() => {
      !r && a && (o = pw, g(C));
    }, u);
  }
  function y(C) {
    f(), n.set(C, !0);
    const R = He();
    S(R + u / 1e3);
  }
  function E(C) {
    if (n.has(C) && n.delete(C), n.size === 0) {
      const R = He();
      m(R + i / 1e3);
    }
  }
  function _() {
    r = !0, n.clear(), p && p(v), as(l, h);
    const C = ee(v), { timestamp: R, start_timestamp: T } = C;
    if (!R || !T)
      return;
    (C.data || {})[Xc] || v.setAttribute(Xc, o), I.log(`[Tracing] Idle span "${C.op}" finished`);
    const U = ro(v).filter((Y) => Y !== v);
    let K = 0;
    U.forEach((Y) => {
      Y.isRecording() && (Y.setStatus({ code: ge, message: "cancelled" }), Y.end(R), W && I.log("[Tracing] Cancelling span since span ended early", JSON.stringify(Y, void 0, 2)));
      const J = ee(Y), { timestamp: he = 0, start_timestamp: ve = 0 } = J, re = ve <= R, N = (c + i) / 1e3, X = he - ve < N;
      if (W) {
        const Z = JSON.stringify(Y, void 0, 2);
        re ? X || I.log("[Tracing] Discarding span since it finished after idle span final timeout", Z) : I.log("[Tracing] Discarding span since it happened after idle span was finished", Z);
      }
      (!X || !re) && (WT(v, Y), K++);
    }), K > 0 && v.setAttribute("sentry.idle_span_discarded_spans", K);
  }
  return d.on("spanStart", (C) => {
    if (r || C === v || ee(C).timestamp)
      return;
    ro(v).includes(C) && y(C.spanContext().spanId);
  }), d.on("spanEnd", (C) => {
    r || (E(C.spanContext().spanId), C === v && _());
  }), d.on("idleSpanEnableAutoFinish", (C) => {
    C === v && (a = !0, m(), n.size && S());
  }), e.disableAutoFinish || m(), setTimeout(() => {
    r || (v.setStatus({ code: ge, message: "deadline_exceeded" }), o = lw, g());
  }, c), v;
}
function vw(t) {
  const e = Mn(t);
  return as(ae(), e), W && I.log("[Tracing] Started span is an idle span"), e;
}
function nu(t, e, n, r = 0) {
  return new Qe((s, o) => {
    const a = t[r];
    if (e === null || typeof a != "function")
      s(e);
    else {
      const i = a({ ...e }, n);
      W && a.id && i === null && I.log(`Event processor "${a.id}" dropped event`), xa(i) ? i.then((c) => nu(t, c, n, r + 1).then(s)).then(null, o) : nu(t, i, n, r + 1).then(s).then(null, o);
    }
  });
}
function fw(t, e) {
  const { fingerprint: n, span: r, breadcrumbs: s, sdkProcessingMetadata: o } = e;
  gw(t, e), r && yw(t, r), Cw(t, n), mw(t, s), Sw(t, o);
}
function Lh(t, e) {
  const {
    extra: n,
    tags: r,
    user: s,
    contexts: o,
    level: a,
    sdkProcessingMetadata: i,
    breadcrumbs: c,
    fingerprint: u,
    eventProcessors: p,
    attachments: d,
    propagationContext: l,
    transactionName: h,
    span: v
  } = e;
  Gi(t, "extra", n), Gi(t, "tags", r), Gi(t, "user", s), Gi(t, "contexts", o), Gi(t, "sdkProcessingMetadata", i), a && (t.level = a), h && (t.transactionName = h), v && (t.span = v), c.length && (t.breadcrumbs = [...t.breadcrumbs, ...c]), u.length && (t.fingerprint = [...t.fingerprint, ...u]), p.length && (t.eventProcessors = [...t.eventProcessors, ...p]), d.length && (t.attachments = [...t.attachments, ...d]), t.propagationContext = { ...t.propagationContext, ...l };
}
function Gi(t, e, n) {
  if (n && Object.keys(n).length) {
    t[e] = { ...t[e] };
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[e][r] = n[r]);
  }
}
function gw(t, e) {
  const { extra: n, tags: r, user: s, contexts: o, level: a, transactionName: i } = e, c = je(n);
  c && Object.keys(c).length && (t.extra = { ...c, ...t.extra });
  const u = je(r);
  u && Object.keys(u).length && (t.tags = { ...u, ...t.tags });
  const p = je(s);
  p && Object.keys(p).length && (t.user = { ...p, ...t.user });
  const d = je(o);
  d && Object.keys(d).length && (t.contexts = { ...d, ...t.contexts }), a && (t.level = a), i && t.type !== "transaction" && (t.transaction = i);
}
function mw(t, e) {
  const n = [...t.breadcrumbs || [], ...e];
  t.breadcrumbs = n.length ? n : void 0;
}
function Sw(t, e) {
  t.sdkProcessingMetadata = {
    ...t.sdkProcessingMetadata,
    ...e
  };
}
function yw(t, e) {
  t.contexts = {
    trace: $T(e),
    ...t.contexts
  }, t.sdkProcessingMetadata = {
    dynamicSamplingContext: An(e),
    ...t.sdkProcessingMetadata
  };
  const n = We(e), r = ee(n).description;
  r && !t.transaction && t.type === "transaction" && (t.transaction = r);
}
function Cw(t, e) {
  t.fingerprint = t.fingerprint ? Tg(t.fingerprint) : [], e && (t.fingerprint = t.fingerprint.concat(e)), t.fingerprint && !t.fingerprint.length && delete t.fingerprint;
}
function _w(t, e, n, r, s, o) {
  const { normalizeDepth: a = 3, normalizeMaxBreadth: i = 1e3 } = t, c = {
    ...e,
    event_id: e.event_id || n.event_id || ie(),
    timestamp: e.timestamp || Ts()
  }, u = n.integrations || t.integrations.map((f) => f.name);
  Rw(c, t), Tw(c, u), e.type === void 0 && Pw(c, t.stackParser);
  const p = Iw(r, n.captureContext);
  n.mechanism && os(c, n.mechanism);
  const d = s ? s.getEventProcessors() : [], l = Mg().getScopeData();
  if (o) {
    const f = o.getScopeData();
    Lh(l, f);
  }
  if (p) {
    const f = p.getScopeData();
    Lh(l, f);
  }
  const h = [...n.attachments || [], ...l.attachments];
  h.length && (n.attachments = h), fw(c, l);
  const v = [
    ...d,
    // Run scope event processors _after_ all other processors
    ...l.eventProcessors
  ];
  return nu(v, c, n).then((f) => (f && Ew(f), typeof a == "number" && a > 0 ? ww(f, a, i) : f));
}
function Rw(t, e) {
  const { environment: n, release: r, dist: s, maxValueLength: o = 250 } = e;
  "environment" in t || (t.environment = "environment" in e ? n : Xu), t.release === void 0 && r !== void 0 && (t.release = r), t.dist === void 0 && s !== void 0 && (t.dist = s), t.message && (t.message = xn(t.message, o));
  const a = t.exception && t.exception.values && t.exception.values[0];
  a && a.value && (a.value = xn(a.value, o));
  const i = t.request;
  i && i.url && (i.url = xn(i.url, o));
}
const zh = /* @__PURE__ */ new WeakMap();
function Pw(t, e) {
  const n = Q._sentryDebugIds;
  if (!n)
    return;
  let r;
  const s = zh.get(e);
  s ? r = s : (r = /* @__PURE__ */ new Map(), zh.set(e, r));
  const o = Object.keys(n).reduce((a, i) => {
    let c;
    const u = r.get(i);
    u ? c = u : (c = e(i), r.set(i, c));
    for (let p = c.length - 1; p >= 0; p--) {
      const d = c[p];
      if (d.filename) {
        a[d.filename] = n[i];
        break;
      }
    }
    return a;
  }, {});
  try {
    t.exception.values.forEach((a) => {
      a.stacktrace.frames.forEach((i) => {
        i.filename && (i.debug_id = o[i.filename]);
      });
    });
  } catch {
  }
}
function Ew(t) {
  const e = {};
  try {
    t.exception.values.forEach((r) => {
      r.stacktrace.frames.forEach((s) => {
        s.debug_id && (s.abs_path ? e[s.abs_path] = s.debug_id : s.filename && (e[s.filename] = s.debug_id), delete s.debug_id);
      });
    });
  } catch {
  }
  if (Object.keys(e).length === 0)
    return;
  t.debug_meta = t.debug_meta || {}, t.debug_meta.images = t.debug_meta.images || [];
  const n = t.debug_meta.images;
  Object.keys(e).forEach((r) => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: e[r]
    });
  });
}
function Tw(t, e) {
  e.length > 0 && (t.sdk = t.sdk || {}, t.sdk.integrations = [...t.sdk.integrations || [], ...e]);
}
function ww(t, e, n) {
  if (!t)
    return null;
  const r = {
    ...t,
    ...t.breadcrumbs && {
      breadcrumbs: t.breadcrumbs.map((s) => ({
        ...s,
        ...s.data && {
          data: Ot(s.data, e, n)
        }
      }))
    },
    ...t.user && {
      user: Ot(t.user, e, n)
    },
    ...t.contexts && {
      contexts: Ot(t.contexts, e, n)
    },
    ...t.extra && {
      extra: Ot(t.extra, e, n)
    }
  };
  return t.contexts && t.contexts.trace && r.contexts && (r.contexts.trace = t.contexts.trace, t.contexts.trace.data && (r.contexts.trace.data = Ot(t.contexts.trace.data, e, n))), t.spans && (r.spans = t.spans.map((s) => ({
    ...s,
    ...s.data && {
      data: Ot(s.data, e, n)
    }
  }))), r;
}
function Iw(t, e) {
  if (!e)
    return t;
  const n = t ? t.clone() : new _n();
  return n.update(e), n;
}
function bw(t, e) {
  return ae().captureException(t, void 0);
}
function Aw(t, e) {
  const r = { captureContext: e };
  return ae().captureMessage(t, void 0, r);
}
function Kg(t, e) {
  return ae().captureEvent(t, e);
}
function jh(t) {
  const e = te(), n = wt(), r = ae(), { release: s, environment: o = Xu } = e && e.getOptions() || {}, { userAgent: a } = Q.navigator || {}, i = bT({
    release: s,
    environment: o,
    user: r.getUser() || n.getUser(),
    ...a && { userAgent: a },
    ...t
  }), c = n.getSession();
  return c && c.status === "ok" && Vn(c, { status: "exited" }), Jg(), n.setSession(i), r.setSession(i), i;
}
function Jg() {
  const t = wt(), e = ae(), n = e.getSession() || t.getSession();
  n && AT(n), Gg(), t.setSession(), e.setSession();
}
function Gg() {
  const t = wt(), e = ae(), n = te(), r = e.getSession() || t.getSession();
  r && n && n.captureSession(r);
}
function xh(t = !1) {
  if (t) {
    Jg();
    return;
  }
  Gg();
}
const Mw = "7";
function Ow(t) {
  const e = t.protocol ? `${t.protocol}:` : "", n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`;
}
function kw(t) {
  return `${Ow(t)}${t.projectId}/envelope/`;
}
function Dw(t, e) {
  return jE({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: t.publicKey,
    sentry_version: Mw,
    ...e && { sentry_client: `${e.name}/${e.version}` }
  });
}
function Nw(t, e, n) {
  return e || `${kw(t)}?${Dw(t, n)}`;
}
const Bh = [];
function Lw(t) {
  const e = {};
  return t.forEach((n) => {
    const { name: r } = n, s = e[r];
    s && !s.isDefaultInstance && n.isDefaultInstance || (e[r] = n);
  }), Object.keys(e).map((n) => e[n]);
}
function zw(t) {
  const e = t.defaultIntegrations || [], n = t.integrations;
  e.forEach((a) => {
    a.isDefaultInstance = !0;
  });
  let r;
  Array.isArray(n) ? r = [...e, ...n] : typeof n == "function" ? r = Tg(n(e)) : r = e;
  const s = Lw(r), o = xw(s, (a) => a.name === "Debug");
  if (o !== -1) {
    const [a] = s.splice(o, 1);
    s.push(a);
  }
  return s;
}
function jw(t, e) {
  const n = {};
  return e.forEach((r) => {
    r && Qg(t, r, n);
  }), n;
}
function qh(t, e) {
  for (const n of e)
    n && n.afterAllSetup && n.afterAllSetup(t);
}
function Qg(t, e, n) {
  if (n[e.name]) {
    W && I.log(`Integration skipped because it was already installed: ${e.name}`);
    return;
  }
  if (n[e.name] = e, Bh.indexOf(e.name) === -1 && typeof e.setupOnce == "function" && (e.setupOnce(), Bh.push(e.name)), e.setup && typeof e.setup == "function" && e.setup(t), typeof e.preprocessEvent == "function") {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (s, o) => r(s, o, t));
  }
  if (typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e), s = Object.assign((o, a) => r(o, a, t), {
      id: e.name
    });
    t.addEventProcessor(s);
  }
  W && I.log(`Integration installed: ${e.name}`);
}
function xw(t, e) {
  for (let n = 0; n < t.length; n++)
    if (e(t[n]) === !0)
      return n;
  return -1;
}
const Fh = "Not capturing exception because it's already been captured.";
class Bw {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(e) {
    if (this._options = e, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e.dsn ? this._dsn = zE(e.dsn) : W && I.warn("No DSN provided, client will not send events."), this._dsn) {
      const n = Nw(
        this._dsn,
        e.tunnel,
        e._metadata ? e._metadata.sdk : void 0
      );
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: n
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  captureException(e, n, r) {
    const s = ie();
    if (_h(e))
      return W && I.log(Fh), s;
    const o = {
      event_id: s,
      ...n
    };
    return this._process(
      this.eventFromException(e, o).then(
        (a) => this._captureEvent(a, o, r)
      )
    ), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureMessage(e, n, r, s) {
    const o = {
      event_id: ie(),
      ...r
    }, a = Hu(e) ? e : String(e), i = Wu(e) ? this.eventFromMessage(a, n, o) : this.eventFromException(e, o);
    return this._process(i.then((c) => this._captureEvent(c, o, s))), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureEvent(e, n, r) {
    const s = ie();
    if (n && n.originalException && _h(n.originalException))
      return W && I.log(Fh), s;
    const o = {
      event_id: s,
      ...n
    }, i = (e.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(e, o, i || r)), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureSession(e) {
    typeof e.release != "string" ? W && I.warn("Discarded session because of missing or non-string release") : (this.sendSession(e), Vn(e, { init: !1 }));
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata in @sentry/types
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(e) {
    const n = this._transport;
    return n ? (this.emit("flush"), this._isClientDoneProcessing(e).then((r) => n.flush(e).then((s) => r && s))) : Cn(!0);
  }
  /**
   * @inheritDoc
   */
  close(e) {
    return this.flush(e).then((n) => (this.getOptions().enabled = !1, this.emit("close"), n));
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(e) {
    this._eventProcessors.push(e);
  }
  /** @inheritdoc */
  init() {
    this._isEnabled() && this._setupIntegrations();
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(e) {
    return this._integrations[e];
  }
  /**
   * @inheritDoc
   */
  addIntegration(e) {
    const n = this._integrations[e.name];
    Qg(this, e, this._integrations), n || qh(this, [e]);
  }
  /**
   * @inheritDoc
   */
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = ew(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const o of n.attachments || [])
      r = hT(r, mT(o));
    const s = this.sendEnvelope(r);
    s && s.then((o) => this.emit("afterSendEvent", e, o), null);
  }
  /**
   * @inheritDoc
   */
  sendSession(e) {
    const n = XT(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(e, n, r) {
    if (this._options.sendClientReports) {
      const s = `${e}:${n}`;
      W && I.log(`Adding outcome: "${s}"`), this._outcomes[s] = this._outcomes[s] + 1 || 1;
    }
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(e, n) {
    this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(n);
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(e, ...n) {
    this._hooks[e] && this._hooks[e].forEach((r) => r(...n));
  }
  /**
   * @inheritdoc
   */
  sendEnvelope(e) {
    return this.emit("beforeEnvelope", e), this._isEnabled() && this._transport ? this._transport.send(e).then(null, (n) => (W && I.error("Error while sending event:", n), n)) : (W && I.error("Transport disabled"), Cn({}));
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations: e } = this._options;
    this._integrations = jw(this, e), qh(this, e);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(e, n) {
    let r = !1, s = !1;
    const o = n.exception && n.exception.values;
    if (o) {
      s = !0;
      for (const c of o) {
        const u = c.mechanism;
        if (u && u.handled === !1) {
          r = !0;
          break;
        }
      }
    }
    const a = e.status === "ok";
    (a && e.errors === 0 || a && r) && (Vn(e, {
      ...r && { status: "crashed" },
      errors: e.errors || Number(s || r)
    }), this.captureSession(e));
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(e) {
    return new Qe((n) => {
      let r = 0;
      const s = 1, o = setInterval(() => {
        this._numProcessing == 0 ? (clearInterval(o), n(!0)) : (r += s, e && r >= e && (clearInterval(o), n(!1)));
      }, s);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(e, n, r, s = wt()) {
    const o = this.getOptions(), a = Object.keys(this._integrations);
    return !n.integrations && a.length > 0 && (n.integrations = a), this.emit("preprocessEvent", e, n), e.type || s.setLastEventId(e.event_id || n.event_id), _w(o, e, n, r, this, s).then((i) => {
      if (i === null)
        return i;
      const c = {
        ...s.getPropagationContext(),
        ...r ? r.getPropagationContext() : void 0
      };
      if (!(i.contexts && i.contexts.trace) && c) {
        const { traceId: p, spanId: d, parentSpanId: l, dsc: h } = c;
        i.contexts = {
          trace: je({
            trace_id: p,
            span_id: d,
            parent_span_id: l
          }),
          ...i.contexts
        };
        const v = h || qa(p, this);
        i.sdkProcessingMetadata = {
          dynamicSamplingContext: v,
          ...i.sdkProcessingMetadata
        };
      }
      return i;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(e, n = {}, r) {
    return this._processEvent(e, n, r).then(
      (s) => s.event_id,
      (s) => {
        if (W) {
          const o = s;
          o.logLevel === "log" ? I.log(o.message) : I.warn(o);
        }
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(e, n, r) {
    const s = this.getOptions(), { sampleRate: o } = s, a = Zg(e), i = Yg(e), c = e.type || "error", u = `before send for type \`${c}\``, p = typeof o > "u" ? void 0 : Ug(o);
    if (i && typeof p == "number" && Math.random() > p)
      return this.recordDroppedEvent("sample_rate", "error", e), vo(
        new ut(
          `Discarding event because it's not included in the random sample (sampling rate = ${o})`,
          "log"
        )
      );
    const d = c === "replay_event" ? "replay" : c, h = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(e, n, r, h).then((v) => {
      if (v === null)
        throw this.recordDroppedEvent("event_processor", d, e), new ut("An event processor returned `null`, will not send event.", "log");
      if (n.data && n.data.__sentry__ === !0)
        return v;
      const f = Fw(s, v, n);
      return qw(f, u);
    }).then((v) => {
      if (v === null)
        throw this.recordDroppedEvent("before_send", d, e), new ut(`${u} returned \`null\`, will not send event.`, "log");
      const g = r && r.getSession();
      !a && g && this._updateSessionFromEvent(g, v);
      const f = v.transaction_info;
      if (a && f && v.transaction !== e.transaction) {
        const m = "custom";
        v.transaction_info = {
          ...f,
          source: m
        };
      }
      return this.sendEvent(v, n), v;
    }).then(null, (v) => {
      throw v instanceof ut ? v : (this.captureException(v, {
        data: {
          __sentry__: !0
        },
        originalException: v
      }), new ut(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${v}`
      ));
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(e) {
    this._numProcessing++, e.then(
      (n) => (this._numProcessing--, n),
      (n) => (this._numProcessing--, n)
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const e = this._outcomes;
    return this._outcomes = {}, Object.keys(e).map((n) => {
      const [r, s] = n.split(":");
      return {
        reason: r,
        category: s,
        quantity: e[n]
      };
    });
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
}
function qw(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (xa(t))
    return t.then(
      (r) => {
        if (!Hn(r) && r !== null)
          throw new ut(n);
        return r;
      },
      (r) => {
        throw new ut(`${e} rejected with ${r}`);
      }
    );
  if (!Hn(t) && t !== null)
    throw new ut(n);
  return t;
}
function Fw(t, e, n) {
  const { beforeSend: r, beforeSendTransaction: s, beforeSendSpan: o } = t;
  if (Yg(e) && r)
    return r(e, n);
  if (Zg(e)) {
    if (e.spans && o) {
      const a = [];
      for (const i of e.spans) {
        const c = o(i);
        c && a.push(c);
      }
      e.spans = a;
    }
    if (s)
      return s(e, n);
  }
  return e;
}
function Yg(t) {
  return t.type === void 0;
}
function Zg(t) {
  return t.type === "transaction";
}
function $w(t, e) {
  e.debug === !0 && (W ? I.enable() : Ps(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
  })), ae().update(e.initialScope);
  const r = new t(e);
  Uw(r), r.init();
}
function Uw(t) {
  ae().setClient(t), Hw(t);
}
function Hw(t) {
  const e = Ba(In());
  e.hub && typeof e.hub.getStackTop == "function" && (e.hub.getStackTop().client = t);
}
const Ww = 64;
function Vw(t, e, n = nT(
  t.bufferSize || Ww
)) {
  let r = {};
  const s = (a) => n.drain(a);
  function o(a) {
    const i = [];
    if (Ph(a, (d, l) => {
      const h = Eh(l);
      if (ET(r, h)) {
        const v = $h(d, l);
        t.recordDroppedEvent("ratelimit_backoff", h, v);
      } else
        i.push(d);
    }), i.length === 0)
      return Cn({});
    const c = sr(a[0], i), u = (d) => {
      Ph(c, (l, h) => {
        const v = $h(l, h);
        t.recordDroppedEvent(d, Eh(h), v);
      });
    }, p = () => e({ body: vT(c) }).then(
      (d) => (d.statusCode !== void 0 && (d.statusCode < 200 || d.statusCode >= 300) && W && I.warn(`Sentry responded with status code ${d.statusCode} to sent event.`), r = TT(r, d), d),
      (d) => {
        throw u("network_error"), d;
      }
    );
    return n.add(p).then(
      (d) => d,
      (d) => {
        if (d instanceof ut)
          return W && I.error("Skipped sending event because buffer is full."), u("queue_overflow"), Cn({});
        throw d;
      }
    );
  }
  return {
    send: o,
    flush: s
  };
}
function $h(t, e) {
  if (!(e !== "event" && e !== "transaction"))
    return Array.isArray(t) ? t[1] : void 0;
}
const Uh = "8.4.0";
function Kw(t, e, n = [e], r = "npm") {
  const s = t._metadata || {};
  s.sdk || (s.sdk = {
    name: `sentry.javascript.${e}`,
    packages: n.map((o) => ({
      name: `${r}:@sentry/${o}`,
      version: Uh
    })),
    version: Uh
  }), t._metadata = s;
}
const Jw = 100;
function Rn(t, e) {
  const n = te(), r = wt();
  if (!n)
    return;
  const { beforeBreadcrumb: s = null, maxBreadcrumbs: o = Jw } = n.getOptions();
  if (o <= 0)
    return;
  const i = { timestamp: Ts(), ...t }, c = s ? Ps(() => s(i, e)) : i;
  c !== null && (n.emit && n.emit("beforeAddBreadcrumb", c, e), r.addBreadcrumb(c, o));
}
let Hh;
const Gw = "FunctionToString", Wh = /* @__PURE__ */ new WeakMap(), Qw = () => ({
  name: Gw,
  setupOnce() {
    Hh = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...t) {
        const e = Ku(this), n = Wh.has(te()) && e !== void 0 ? e : this;
        return Hh.apply(n, t);
      };
    } catch {
    }
  },
  setup(t) {
    Wh.set(t, !0);
  }
}), Yw = Qw, Zw = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  /^Cannot redefine property: googletag$/
], Xw = "InboundFilters", eI = (t = {}) => ({
  name: Xw,
  processEvent(e, n, r) {
    const s = r.getOptions(), o = nI(t, s);
    return rI(e, o) ? null : e;
  }
}), tI = eI;
function nI(t = {}, e = {}) {
  return {
    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
    ignoreErrors: [
      ...t.ignoreErrors || [],
      ...e.ignoreErrors || [],
      ...t.disableErrorDefaults ? [] : Zw
    ],
    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
    ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
  };
}
function rI(t, e) {
  return e.ignoreInternal && uI(t) ? (W && I.warn(`Event dropped due to being internal Sentry Error.
Event: ${pn(t)}`), !0) : iI(t, e.ignoreErrors) ? (W && I.warn(
    `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${pn(t)}`
  ), !0) : sI(t, e.ignoreTransactions) ? (W && I.warn(
    `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${pn(t)}`
  ), !0) : oI(t, e.denyUrls) ? (W && I.warn(
    `Event dropped due to being matched by \`denyUrls\` option.
Event: ${pn(
      t
    )}.
Url: ${go(t)}`
  ), !0) : aI(t, e.allowUrls) ? !1 : (W && I.warn(
    `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${pn(
      t
    )}.
Url: ${go(t)}`
  ), !0);
}
function iI(t, e) {
  return t.type || !e || !e.length ? !1 : cI(t).some((n) => ln(n, e));
}
function sI(t, e) {
  if (t.type !== "transaction" || !e || !e.length)
    return !1;
  const n = t.transaction;
  return n ? ln(n, e) : !1;
}
function oI(t, e) {
  if (!e || !e.length)
    return !1;
  const n = go(t);
  return n ? ln(n, e) : !1;
}
function aI(t, e) {
  if (!e || !e.length)
    return !0;
  const n = go(t);
  return n ? ln(n, e) : !0;
}
function cI(t) {
  const e = [];
  t.message && e.push(t.message);
  let n;
  try {
    n = t.exception.values[t.exception.values.length - 1];
  } catch {
  }
  return n && n.value && (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`)), e;
}
function uI(t) {
  try {
    return t.exception.values[0].type === "SentryError";
  } catch {
  }
  return !1;
}
function pI(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function go(t) {
  try {
    let e;
    try {
      e = t.exception.values[0].stacktrace.frames;
    } catch {
    }
    return e ? pI(e) : null;
  } catch {
    return W && I.error(`Cannot extract url for event ${pn(t)}`), null;
  }
}
const dI = "Dedupe", lI = () => {
  let t;
  return {
    name: dI,
    processEvent(e) {
      if (e.type)
        return e;
      try {
        if (vI(e, t))
          return W && I.warn("Event dropped due to being a duplicate of previously captured event."), null;
      } catch {
      }
      return t = e;
    }
  };
}, hI = lI;
function vI(t, e) {
  return e ? !!(fI(t, e) || gI(t, e)) : !1;
}
function fI(t, e) {
  const n = t.message, r = e.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !em(t, e) || !Xg(t, e));
}
function gI(t, e) {
  const n = Vh(e), r = Vh(t);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !em(t, e) || !Xg(t, e));
}
function Xg(t, e) {
  let n = Kh(t), r = Kh(e);
  if (!n && !r)
    return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length))
    return !1;
  for (let s = 0; s < r.length; s++) {
    const o = r[s], a = n[s];
    if (o.filename !== a.filename || o.lineno !== a.lineno || o.colno !== a.colno || o.function !== a.function)
      return !1;
  }
  return !0;
}
function em(t, e) {
  let n = t.fingerprint, r = e.fingerprint;
  if (!n && !r)
    return !0;
  if (n && !r || !n && r)
    return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("");
  } catch {
    return !1;
  }
}
function Vh(t) {
  return t.exception && t.exception.values && t.exception.values[0];
}
function Kh(t) {
  const e = t.exception;
  if (e)
    try {
      return e.values[0].stacktrace.frames;
    } catch {
      return;
    }
}
function mI(t, e, n, r, s = "auto.http.browser") {
  if (!t.fetchData)
    return;
  const o = Ft() && e(t.fetchData.url);
  if (t.endTimestamp && o) {
    const v = t.fetchData.__span;
    if (!v)
      return;
    const g = r[v];
    g && (CI(g, t), delete r[v]);
    return;
  }
  const a = ae(), i = te(), { method: c, url: u } = t.fetchData, p = yI(u), d = p ? hn(p).host : void 0, l = !!et(), h = o && l ? Mn({
    name: `${c} ${u}`,
    attributes: {
      url: u,
      type: "fetch",
      "http.method": c,
      "http.url": p,
      "server.address": d,
      [xe]: s,
      [cs]: "http.client"
    }
  }) : new or();
  if (t.fetchData.__span = h.spanContext().spanId, r[h.spanContext().spanId] = h, n(t.fetchData.url) && i) {
    const v = t.args[0];
    t.args[1] = t.args[1] || {};
    const g = t.args[1];
    g.headers = SI(
      v,
      i,
      a,
      g,
      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
      // we do not want to use the span as base for the trace headers,
      // which means that the headers will be generated from the scope and the sampling decision is deferred
      Ft() && l ? h : void 0
    );
  }
  return h;
}
function SI(t, e, n, r, s) {
  const o = wt(), { traceId: a, spanId: i, sampled: c, dsc: u } = {
    ...o.getPropagationContext(),
    ...n.getPropagationContext()
  }, p = s ? jg(s) : Ju(a, i, c), d = bg(
    u || (s ? An(s) : qa(a, e))
  ), l = r.headers || (typeof Request < "u" && Pt(t, Request) ? t.headers : void 0);
  if (l)
    if (typeof Headers < "u" && Pt(l, Headers)) {
      const h = new Headers(l);
      return h.append("sentry-trace", p), d && h.append(Qc, d), h;
    } else if (Array.isArray(l)) {
      const h = [...l, ["sentry-trace", p]];
      return d && h.push([Qc, d]), h;
    } else {
      const h = "baggage" in l ? l.baggage : void 0, v = [];
      return Array.isArray(h) ? v.push(...h) : h && v.push(h), d && v.push(d), {
        ...l,
        "sentry-trace": p,
        baggage: v.length > 0 ? v.join(",") : void 0
      };
    }
  else
    return { "sentry-trace": p, baggage: d };
}
function yI(t) {
  try {
    return new URL(t).href;
  } catch {
    return;
  }
}
function CI(t, e) {
  if (e.response) {
    Ng(t, e.response.status);
    const n = e.response && e.response.headers && e.response.headers.get("content-length");
    if (n) {
      const r = parseInt(n);
      r > 0 && t.setAttribute("http.response_content_length", r);
    }
  } else
    e.error && t.setStatus({ code: ge, message: "internal_error" });
  t.end();
}
const B = Q;
let ru = 0;
function tm() {
  return ru > 0;
}
function _I() {
  ru++, setTimeout(() => {
    ru--;
  });
}
function Jn(t, e = {}, n) {
  if (typeof t != "function")
    return t;
  try {
    const s = t.__sentry_wrapped__;
    if (s)
      return s;
    if (Ku(t))
      return t;
  } catch {
    return t;
  }
  const r = function() {
    const s = Array.prototype.slice.call(arguments);
    try {
      const o = s.map((a) => Jn(a, e));
      return t.apply(this, o);
    } catch (o) {
      throw _I(), Qu((a) => {
        a.addEventProcessor((i) => (e.mechanism && (Jc(i, void 0), os(i, e.mechanism)), i.extra = {
          ...i.extra,
          arguments: s
        }, i)), bw(o);
      }), o;
    }
  };
  try {
    for (const s in t)
      Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s]);
  } catch {
  }
  fg(r, t), rt(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return t.name;
      }
    });
  } catch {
  }
  return r;
}
const $e = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function tp(t, e) {
  const n = np(t, e), r = {
    type: e && e.name,
    value: wI(e)
  };
  return n.length && (r.stacktrace = { frames: n }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r;
}
function RI(t, e, n, r) {
  const s = te(), o = s && s.getOptions().normalizeDepth, a = OI(e), i = {
    __serialized__: wg(e, o)
  };
  if (a)
    return {
      exception: {
        values: [tp(t, a)]
      },
      extra: i
    };
  const c = {
    exception: {
      values: [
        {
          type: ja(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
          value: AI(e, { isUnhandledRejection: r })
        }
      ]
    },
    extra: i
  };
  if (n) {
    const u = np(t, n);
    u.length && (c.exception.values[0].stacktrace = { frames: u });
  }
  return c;
}
function Pc(t, e) {
  return {
    exception: {
      values: [tp(t, e)]
    }
  };
}
function np(t, e) {
  const n = e.stacktrace || e.stack || "", r = EI(e), s = TI(e);
  try {
    return t(n, r, s);
  } catch {
  }
  return [];
}
const PI = /Minified React error #\d+;/i;
function EI(t) {
  return t && PI.test(t.message) ? 1 : 0;
}
function TI(t) {
  return typeof t.framesToPop == "number" ? t.framesToPop : 0;
}
function wI(t) {
  const e = t && t.message;
  return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message";
}
function II(t, e, n, r) {
  const s = n && n.syntheticException || void 0, o = rp(t, e, s, r);
  return os(o), o.level = "error", n && n.event_id && (o.event_id = n.event_id), Cn(o);
}
function bI(t, e, n = "info", r, s) {
  const o = r && r.syntheticException || void 0, a = iu(t, e, o, s);
  return a.level = n, r && r.event_id && (a.event_id = r.event_id), Cn(a);
}
function rp(t, e, n, r, s) {
  let o;
  if (dg(e) && e.error)
    return Pc(t, e.error);
  if (dh(e) || yE(e)) {
    const a = e;
    if ("stack" in e)
      o = Pc(t, e);
    else {
      const i = a.name || (dh(a) ? "DOMError" : "DOMException"), c = a.message ? `${i}: ${a.message}` : i;
      o = iu(t, c, n, r), Jc(o, c);
    }
    return "code" in a && (o.tags = { ...o.tags, "DOMException.code": `${a.code}` }), o;
  }
  return pg(e) ? Pc(t, e) : Hn(e) || ja(e) ? (o = RI(t, e, n, s), os(o, {
    synthetic: !0
  }), o) : (o = iu(t, e, n, r), Jc(o, `${e}`), os(o, {
    synthetic: !0
  }), o);
}
function iu(t, e, n, r) {
  const s = {};
  if (r && n) {
    const o = np(t, n);
    o.length && (s.exception = {
      values: [{ value: e, stacktrace: { frames: o } }]
    });
  }
  if (Hu(e)) {
    const { __sentry_template_string__: o, __sentry_template_values__: a } = e;
    return s.logentry = {
      message: o,
      params: a
    }, s;
  }
  return s.message = e, s;
}
function AI(t, { isUnhandledRejection: e }) {
  const n = xE(t), r = e ? "promise rejection" : "exception";
  return dg(t) ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\`` : ja(t) ? `Event \`${MI(t)}\` (type=${t.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`;
}
function MI(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0;
  } catch {
  }
}
function OI(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const n = t[e];
      if (n instanceof Error)
        return n;
    }
}
function kI(t, {
  metadata: e,
  tunnel: n,
  dsn: r
}) {
  const s = {
    event_id: t.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...e && e.sdk && {
      sdk: {
        name: e.sdk.name,
        version: e.sdk.version
      }
    },
    ...!!n && !!r && { dsn: Es(r) }
  }, o = DI(t);
  return sr(s, [o]);
}
function DI(t) {
  return [{
    type: "user_report"
  }, t];
}
class NI extends Bw {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(e) {
    const n = {
      // We default this to true, as it is the safer scenario
      parentSpanIsAlwaysRootSpan: !0,
      ...e
    }, r = B.SENTRY_SDK_SOURCE || QE();
    Kw(n, "browser", ["browser"], r), super(n), n.sendClientReports && B.document && B.document.addEventListener("visibilitychange", () => {
      B.document.visibilityState === "hidden" && this._flushOutcomes();
    });
  }
  /**
   * @inheritDoc
   */
  eventFromException(e, n) {
    return II(this._options.stackParser, e, n, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(e, n = "info", r) {
    return bI(this._options.stackParser, e, n, r, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   *
   * @deprecated Use `captureFeedback` instead.
   */
  captureUserFeedback(e) {
    if (!this._isEnabled()) {
      $e && I.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const n = kI(e, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(e, n, r) {
    return e.platform = e.platform || "javascript", super._prepareEvent(e, n, r);
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    const e = this._clearOutcomes();
    if (e.length === 0) {
      $e && I.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      $e && I.log("No dsn provided, will not send outcomes");
      return;
    }
    $e && I.log("Sending outcomes:", e);
    const n = CT(e, this._options.tunnel && Es(this._dsn));
    this.sendEnvelope(n);
  }
}
const Je = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, LI = (t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good", ar = (t, e, n, r) => {
  let s, o;
  return (a) => {
    e.value >= 0 && (a || r) && (o = e.value - (s || 0), (o || s === void 0) && (s = e.value, e.delta = o, e.rating = LI(e.value, n), t(e)));
  };
}, L = Q, zI = () => `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`, Fa = () => L.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], $a = () => {
  const t = Fa();
  return t && t.activationStart || 0;
}, cr = (t, e) => {
  const n = Fa();
  let r = "navigate";
  return n && (L.document && L.document.prerendering || $a() > 0 ? r = "prerender" : L.document && L.document.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-"))), {
    name: t,
    value: typeof e > "u" ? -1 : e,
    rating: "good",
    // If needed, will be updated when reported. `const` to keep the type from widening to `string`.
    delta: 0,
    entries: [],
    id: zI(),
    navigationType: r
  };
}, On = (t, e, n) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(t)) {
      const r = new PerformanceObserver((s) => {
        Promise.resolve().then(() => {
          e(s.getEntries());
        });
      });
      return r.observe(
        Object.assign(
          {
            type: t,
            buffered: !0
          },
          n || {}
        )
      ), r;
    }
  } catch {
  }
}, Ua = (t) => {
  const e = (n) => {
    (n.type === "pagehide" || L.document && L.document.visibilityState === "hidden") && t(n);
  };
  L.document && (addEventListener("visibilitychange", e, !0), addEventListener("pagehide", e, !0));
}, ip = (t) => {
  let e = !1;
  return (n) => {
    e || (t(n), e = !0);
  };
};
let us = -1;
const jI = () => {
  us = L.document.visibilityState === "hidden" && !L.document.prerendering ? 0 : 1 / 0;
}, mo = (t) => {
  L.document.visibilityState === "hidden" && us > -1 && (us = t.type === "visibilitychange" ? t.timeStamp : 0, removeEventListener("visibilitychange", mo, !0), removeEventListener("prerenderingchange", mo, !0));
}, xI = () => {
  addEventListener("visibilitychange", mo, !0), addEventListener("prerenderingchange", mo, !0);
}, Ha = () => (L.document && us < 0 && (jI(), xI()), {
  get firstHiddenTime() {
    return us;
  }
}), Is = (t) => {
  L.document && L.document.prerendering ? addEventListener("prerenderingchange", () => t(), !0) : t();
}, BI = [1800, 3e3], qI = (t, e = {}) => {
  Is(() => {
    const n = Ha(), r = cr("FCP");
    let s;
    const a = On("paint", (i) => {
      i.forEach((c) => {
        c.name === "first-contentful-paint" && (a.disconnect(), c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - $a(), 0), r.entries.push(c), s(!0)));
      });
    });
    a && (s = ar(t, r, BI, e.reportAllChanges));
  });
}, FI = [0.1, 0.25], $I = (t, e = {}) => {
  qI(
    ip(() => {
      const n = cr("CLS", 0);
      let r, s = 0, o = [];
      const a = (c) => {
        c.forEach((u) => {
          if (!u.hadRecentInput) {
            const p = o[0], d = o[o.length - 1];
            s && u.startTime - d.startTime < 1e3 && u.startTime - p.startTime < 5e3 ? (s += u.value, o.push(u)) : (s = u.value, o = [u]);
          }
        }), s > n.value && (n.value = s, n.entries = o, r());
      }, i = On("layout-shift", a);
      i && (r = ar(t, n, FI, e.reportAllChanges), Ua(() => {
        a(i.takeRecords()), r(!0);
      }), setTimeout(r, 0));
    })
  );
}, UI = [100, 300], HI = (t, e = {}) => {
  Is(() => {
    const n = Ha(), r = cr("FID");
    let s;
    const o = (c) => {
      c.startTime < n.firstHiddenTime && (r.value = c.processingStart - c.startTime, r.entries.push(c), s(!0));
    }, a = (c) => {
      c.forEach(o);
    }, i = On("first-input", a);
    s = ar(t, r, UI, e.reportAllChanges), i && Ua(
      ip(() => {
        a(i.takeRecords()), i.disconnect();
      })
    );
  });
};
let nm = 0, Ec = 1 / 0, Ks = 0;
const WI = (t) => {
  t.forEach((e) => {
    e.interactionId && (Ec = Math.min(Ec, e.interactionId), Ks = Math.max(Ks, e.interactionId), nm = Ks ? (Ks - Ec) / 7 + 1 : 0);
  });
};
let su;
const VI = () => su ? nm : performance.interactionCount || 0, KI = () => {
  "interactionCount" in performance || su || (su = On("event", WI, {
    type: "event",
    buffered: !0,
    durationThreshold: 0
  }));
}, JI = [200, 500], GI = 0, rm = () => VI() - GI, Jh = 10, yt = [], Tc = {}, Gh = (t) => {
  const e = yt[yt.length - 1], n = Tc[t.interactionId];
  if (n || yt.length < Jh || t.duration > e.latency) {
    if (n)
      n.entries.push(t), n.latency = Math.max(n.latency, t.duration);
    else {
      const r = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        id: t.interactionId,
        latency: t.duration,
        entries: [t]
      };
      Tc[r.id] = r, yt.push(r);
    }
    yt.sort((r, s) => s.latency - r.latency), yt.splice(Jh).forEach((r) => {
      delete Tc[r.id];
    });
  }
}, QI = () => {
  const t = Math.min(
    yt.length - 1,
    Math.floor(rm() / 50)
  );
  return yt[t];
}, YI = (t, e = {}) => {
  Is(() => {
    KI();
    const n = cr("INP");
    let r;
    const s = (a) => {
      a.forEach((c) => {
        c.interactionId && Gh(c), c.entryType === "first-input" && !yt.some((p) => p.entries.some((d) => c.duration === d.duration && c.startTime === d.startTime)) && Gh(c);
      });
      const i = QI();
      i && i.latency !== n.value && (n.value = i.latency, n.entries = i.entries, r());
    }, o = On("event", s, {
      // Event Timing entries have their durations rounded to the nearest 8ms,
      // so a duration of 40ms would be any event that spans 2.5 or more frames
      // at 60Hz. This threshold is chosen to strike a balance between usefulness
      // and performance. Running this callback for any interaction that spans
      // just one or two frames is likely not worth the insight that could be
      // gained.
      durationThreshold: e.durationThreshold != null ? e.durationThreshold : 40
    });
    r = ar(t, n, JI, e.reportAllChanges), o && ("PerformanceEventTiming" in L && "interactionId" in PerformanceEventTiming.prototype && o.observe({ type: "first-input", buffered: !0 }), Ua(() => {
      s(o.takeRecords()), n.value < 0 && rm() > 0 && (n.value = 0, n.entries = []), r(!0);
    }));
  });
}, ZI = [2500, 4e3], Qh = {}, XI = (t, e = {}) => {
  Is(() => {
    const n = Ha(), r = cr("LCP");
    let s;
    const o = (i) => {
      const c = i[i.length - 1];
      c && c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - $a(), 0), r.entries = [c], s());
    }, a = On("largest-contentful-paint", o);
    if (a) {
      s = ar(t, r, ZI, e.reportAllChanges);
      const i = ip(() => {
        Qh[r.id] || (o(a.takeRecords()), a.disconnect(), Qh[r.id] = !0, s(!0));
      });
      ["keydown", "click"].forEach((c) => {
        L.document && addEventListener(c, () => setTimeout(i, 0), !0);
      }), Ua(i);
    }
  });
}, e1 = [800, 1800], ou = (t) => {
  L.document && L.document.prerendering ? Is(() => ou(t)) : L.document && L.document.readyState !== "complete" ? addEventListener("load", () => ou(t), !0) : setTimeout(t, 0);
}, t1 = (t, e = {}) => {
  const n = cr("TTFB"), r = ar(t, n, e1, e.reportAllChanges);
  ou(() => {
    const s = Fa();
    if (s) {
      const o = s.responseStart;
      if (o <= 0 || o > performance.now())
        return;
      n.value = Math.max(o - $a(), 0), n.entries = [s], r(!0);
    }
  });
}, Zi = {}, So = {};
let im, sm, om, am, cm;
function n1(t, e = !1) {
  return bs("cls", t, a1, im, e);
}
function r1(t, e = !1) {
  return bs("lcp", t, u1, om, e);
}
function i1(t) {
  return bs("fid", t, c1, sm);
}
function s1(t) {
  return bs("ttfb", t, p1, am);
}
function o1(t) {
  return bs("inp", t, d1, cm);
}
function sp(t, e) {
  return um(t, e), So[t] || (l1(t), So[t] = !0), pm(t, e);
}
function ur(t, e) {
  const n = Zi[t];
  if (!(!n || !n.length))
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        Je && I.error(
          `Error while triggering instrumentation handler.
Type: ${t}
Name: ${Et(r)}
Error:`,
          s
        );
      }
}
function a1() {
  return $I(
    (t) => {
      ur("cls", {
        metric: t
      }), im = t;
    },
    // We want the callback to be called whenever the CLS value updates.
    // By default, the callback is only called when the tab goes to the background.
    { reportAllChanges: !0 }
  );
}
function c1() {
  return HI((t) => {
    ur("fid", {
      metric: t
    }), sm = t;
  });
}
function u1() {
  return XI((t) => {
    ur("lcp", {
      metric: t
    }), om = t;
  });
}
function p1() {
  return t1((t) => {
    ur("ttfb", {
      metric: t
    }), am = t;
  });
}
function d1() {
  return YI((t) => {
    ur("inp", {
      metric: t
    }), cm = t;
  });
}
function bs(t, e, n, r, s = !1) {
  um(t, e);
  let o;
  return So[t] || (o = n(), So[t] = !0), r && e({ metric: r }), pm(t, e, s ? o : void 0);
}
function l1(t) {
  const e = {};
  t === "event" && (e.durationThreshold = 0), On(
    t,
    (n) => {
      ur(t, { entries: n });
    },
    e
  );
}
function um(t, e) {
  Zi[t] = Zi[t] || [], Zi[t].push(e);
}
function pm(t, e, n) {
  return () => {
    n && n();
    const r = Zi[t];
    if (!r)
      return;
    const s = r.indexOf(e);
    s !== -1 && r.splice(s, 1);
  };
}
function wc(t) {
  return typeof t == "number" && isFinite(t);
}
function Gn(t, e, n, { ...r }) {
  const s = ee(t).start_timestamp;
  return s && s > e && typeof t.updateStartTime == "function" && t.updateStartTime(e), sw(t, () => {
    const o = Mn({
      startTime: e,
      ...r
    });
    return o && o.end(n), o;
  });
}
function op() {
  return L && L.addEventListener && L.performance;
}
function fe(t) {
  return t / 1e3;
}
const h1 = 2147483647;
let Yh = 0, ce = {}, ct, Xi;
function v1() {
  const t = op();
  if (t && Xe) {
    t.mark && L.performance.mark("sentry-tracing-init");
    const e = y1(), n = m1(), r = S1(), s = C1();
    return () => {
      e(), n(), r(), s();
    };
  }
  return () => {
  };
}
function f1() {
  sp("longtask", ({ entries: t }) => {
    for (const e of t) {
      if (!et())
        return;
      const n = fe(Xe + e.startTime), r = fe(e.duration), s = Mn({
        name: "Main UI thread blocked",
        op: "ui.long-task",
        startTime: n,
        attributes: {
          [xe]: "auto.ui.browser.metrics"
        }
      });
      s && s.end(n + r);
    }
  });
}
function g1() {
  sp("event", ({ entries: t }) => {
    for (const e of t) {
      if (!et())
        return;
      if (e.name === "click") {
        const n = fe(Xe + e.startTime), r = fe(e.duration), s = {
          name: Wn(e.target),
          op: `ui.interaction.${e.name}`,
          startTime: n,
          attributes: {
            [xe]: "auto.ui.browser.metrics"
          }
        }, o = hg(e.target);
        o && (s.attributes["ui.component_name"] = o);
        const a = Mn(s);
        a && a.end(n + r);
      }
    }
  });
}
function m1() {
  return n1(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && (Je && I.log("[Measurements] Adding CLS"), ce.cls = { value: t.value, unit: "" }, Xi = e);
  }, !0);
}
function S1() {
  return r1(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && (Je && I.log("[Measurements] Adding LCP"), ce.lcp = { value: t.value, unit: "millisecond" }, ct = e);
  }, !0);
}
function y1() {
  return i1(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    if (!e)
      return;
    const n = fe(Xe), r = fe(e.startTime);
    Je && I.log("[Measurements] Adding FID"), ce.fid = { value: t.value, unit: "millisecond" }, ce["mark.fid"] = { value: n + r, unit: "second" };
  });
}
function C1() {
  return s1(({ metric: t }) => {
    t.entries[t.entries.length - 1] && (Je && I.log("[Measurements] Adding TTFB"), ce.ttfb = { value: t.value, unit: "millisecond" });
  });
}
function _1(t) {
  const e = op();
  if (!e || !L.performance.getEntries || !Xe)
    return;
  Je && I.log("[Tracing] Adding & adjusting spans using Performance API");
  const n = fe(Xe), r = e.getEntries(), { op: s, start_timestamp: o } = ee(t);
  if (r.slice(Yh).forEach((a) => {
    const i = fe(a.startTime), c = fe(a.duration);
    if (!(s === "navigation" && o && n + i < o))
      switch (a.entryType) {
        case "navigation": {
          P1(t, a, n);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          R1(t, a, i, c, n);
          const u = Ha(), p = a.startTime < u.firstHiddenTime;
          a.name === "first-paint" && p && (Je && I.log("[Measurements] Adding FP"), ce.fp = { value: a.startTime, unit: "millisecond" }), a.name === "first-contentful-paint" && p && (Je && I.log("[Measurements] Adding FCP"), ce.fcp = { value: a.startTime, unit: "millisecond" });
          break;
        }
        case "resource": {
          T1(t, a, a.name, i, c, n);
          break;
        }
      }
  }), Yh = Math.max(r.length - 1, 0), w1(t), s === "pageload") {
    b1(ce), ["fcp", "fp", "lcp"].forEach((i) => {
      if (!ce[i] || !o || n >= o)
        return;
      const c = ce[i].value, u = n + fe(c), p = Math.abs((u - o) * 1e3), d = p - c;
      Je && I.log(`[Measurements] Normalized ${i} from ${c} to ${p} (${d})`), ce[i].value = p;
    });
    const a = ce["mark.fid"];
    a && ce.fid && (Gn(t, a.value, a.value + fe(ce.fid.value), {
      name: "first input delay",
      op: "ui.action",
      attributes: {
        [xe]: "auto.ui.browser.metrics"
      }
    }), delete ce["mark.fid"]), "fcp" in ce || delete ce.cls, Object.keys(ce).forEach((i) => {
      nw(i, ce[i].value, ce[i].unit);
    }), I1(t);
  }
  ct = void 0, Xi = void 0, ce = {};
}
function R1(t, e, n, r, s) {
  const o = s + n, a = o + r;
  return Gn(t, o, a, {
    name: e.name,
    op: e.entryType,
    attributes: {
      [xe]: "auto.resource.browser.metrics"
    }
  }), o;
}
function P1(t, e, n) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((r) => {
    Js(t, e, r, n);
  }), Js(t, e, "secureConnection", n, "TLS/SSL", "connectEnd"), Js(t, e, "fetch", n, "cache", "domainLookupStart"), Js(t, e, "domainLookup", n, "DNS"), E1(t, e, n);
}
function Js(t, e, n, r, s, o) {
  const a = o ? e[o] : e[`${n}End`], i = e[`${n}Start`];
  !i || !a || Gn(t, r + fe(i), r + fe(a), {
    op: "browser",
    name: s || n,
    attributes: {
      [xe]: "auto.ui.browser.metrics"
    }
  });
}
function E1(t, e, n) {
  e.responseEnd && (Gn(
    t,
    n + fe(e.requestStart),
    n + fe(e.responseEnd),
    {
      op: "browser",
      name: "request",
      attributes: {
        [xe]: "auto.ui.browser.metrics"
      }
    }
  ), Gn(
    t,
    n + fe(e.responseStart),
    n + fe(e.responseEnd),
    {
      op: "browser",
      name: "response",
      attributes: {
        [xe]: "auto.ui.browser.metrics"
      }
    }
  ));
}
function T1(t, e, n, r, s, o) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch")
    return;
  const a = hn(n), i = {
    [xe]: "auto.resource.browser.metrics"
  };
  Ic(i, e, "transferSize", "http.response_transfer_size"), Ic(i, e, "encodedBodySize", "http.response_content_length"), Ic(i, e, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in e && (i["resource.render_blocking_status"] = e.renderBlockingStatus), a.protocol && (i["url.scheme"] = a.protocol.split(":").pop()), a.host && (i["server.address"] = a.host), i["url.same_origin"] = n.includes(L.location.origin);
  const c = o + r, u = c + s;
  Gn(t, c, u, {
    name: n.replace(L.location.origin, ""),
    op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
    attributes: i
  });
}
function w1(t) {
  const e = L.navigator;
  if (!e)
    return;
  const n = e.connection;
  n && (n.effectiveType && t.setAttribute("effectiveConnectionType", n.effectiveType), n.type && t.setAttribute("connectionType", n.type), wc(n.rtt) && (ce["connection.rtt"] = { value: n.rtt, unit: "millisecond" })), wc(e.deviceMemory) && t.setAttribute("deviceMemory", `${e.deviceMemory} GB`), wc(e.hardwareConcurrency) && t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency));
}
function I1(t) {
  ct && (Je && I.log("[Measurements] Adding LCP Data"), ct.element && t.setAttribute("lcp.element", Wn(ct.element)), ct.id && t.setAttribute("lcp.id", ct.id), ct.url && t.setAttribute("lcp.url", ct.url.trim().slice(0, 200)), t.setAttribute("lcp.size", ct.size)), Xi && Xi.sources && (Je && I.log("[Measurements] Adding CLS Data"), Xi.sources.forEach(
    (e, n) => t.setAttribute(`cls.source.${n + 1}`, Wn(e.node))
  ));
}
function Ic(t, e, n, r) {
  const s = e[n];
  s != null && s < h1 && (t[r] = s);
}
function b1(t) {
  const e = Fa();
  if (!e)
    return;
  const { responseStart: n, requestStart: r } = e;
  r <= n && (Je && I.log("[Measurements] Adding TTFB Request Time"), t["ttfb.requestTime"] = {
    value: n - r,
    unit: "millisecond"
  });
}
const A1 = 1e3;
let Zh, au, cu;
function M1(t) {
  const e = "dom";
  Tn(e, t), wn(e, O1);
}
function O1() {
  if (!L.document)
    return;
  const t = nt.bind(null, "dom"), e = Xh(t, !0);
  L.document.addEventListener("click", e, !1), L.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach((n) => {
    const r = L[n] && L[n].prototype;
    !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (Pe(r, "addEventListener", function(s) {
      return function(o, a, i) {
        if (o === "click" || o == "keypress")
          try {
            const c = this, u = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {}, p = u[o] = u[o] || { refCount: 0 };
            if (!p.handler) {
              const d = Xh(t);
              p.handler = d, s.call(this, o, d, i);
            }
            p.refCount++;
          } catch {
          }
        return s.call(this, o, a, i);
      };
    }), Pe(
      r,
      "removeEventListener",
      function(s) {
        return function(o, a, i) {
          if (o === "click" || o == "keypress")
            try {
              const c = this, u = c.__sentry_instrumentation_handlers__ || {}, p = u[o];
              p && (p.refCount--, p.refCount <= 0 && (s.call(this, o, p.handler, i), p.handler = void 0, delete u[o]), Object.keys(u).length === 0 && delete c.__sentry_instrumentation_handlers__);
            } catch {
            }
          return s.call(this, o, a, i);
        };
      }
    ));
  });
}
function k1(t) {
  if (t.type !== au)
    return !1;
  try {
    if (!t.target || t.target._sentryId !== cu)
      return !1;
  } catch {
  }
  return !0;
}
function D1(t, e) {
  return t !== "keypress" ? !1 : !e || !e.tagName ? !0 : !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable);
}
function Xh(t, e = !1) {
  return (n) => {
    if (!n || n._sentryCaptured)
      return;
    const r = N1(n);
    if (D1(n.type, r))
      return;
    rt(n, "_sentryCaptured", !0), r && !r._sentryId && rt(r, "_sentryId", ie());
    const s = n.type === "keypress" ? "input" : n.type;
    k1(n) || (t({ event: n, name: s, global: e }), au = n.type, cu = r ? r._sentryId : void 0), clearTimeout(Zh), Zh = L.setTimeout(() => {
      cu = void 0, au = void 0;
    }, A1);
  };
}
function N1(t) {
  try {
    return t.target;
  } catch {
    return null;
  }
}
let Gs;
function ap(t) {
  const e = "history";
  Tn(e, t), wn(e, L1);
}
function L1() {
  if (!IT())
    return;
  const t = L.onpopstate;
  L.onpopstate = function(...n) {
    const r = L.location.href, s = Gs;
    if (Gs = r, nt("history", { from: s, to: r }), t)
      try {
        return t.apply(this, n);
      } catch {
      }
  };
  function e(n) {
    return function(...r) {
      const s = r.length > 2 ? r[2] : void 0;
      if (s) {
        const o = Gs, a = String(s);
        Gs = a, nt("history", { from: o, to: a });
      }
      return n.apply(this, r);
    };
  }
  Pe(L.history, "pushState", e), Pe(L.history, "replaceState", e);
}
const so = {};
function z1(t) {
  const e = so[t];
  if (e)
    return e;
  let n = L[t];
  if (Vc(n))
    return so[t] = n.bind(L);
  const r = L.document;
  if (r && typeof r.createElement == "function")
    try {
      const s = r.createElement("iframe");
      s.hidden = !0, r.head.appendChild(s);
      const o = s.contentWindow;
      o && o[t] && (n = o[t]), r.head.removeChild(s);
    } catch (s) {
      Je && I.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, s);
    }
  return n && (so[t] = n.bind(L));
}
function ev(t) {
  so[t] = void 0;
}
const jn = "__sentry_xhr_v3__";
function dm(t) {
  const e = "xhr";
  Tn(e, t), wn(e, j1);
}
function j1() {
  if (!L.XMLHttpRequest)
    return;
  const t = XMLHttpRequest.prototype;
  Pe(t, "open", function(e) {
    return function(...n) {
      const r = He() * 1e3, s = Rt(n[0]) ? n[0].toUpperCase() : void 0, o = x1(n[1]);
      if (!s || !o)
        return e.apply(this, n);
      this[jn] = {
        method: s,
        url: o,
        request_headers: {}
      }, s === "POST" && o.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
      const a = () => {
        const i = this[jn];
        if (i && this.readyState === 4) {
          try {
            i.status_code = this.status;
          } catch {
          }
          const c = {
            endTimestamp: He() * 1e3,
            startTimestamp: r,
            xhr: this
          };
          nt("xhr", c);
        }
      };
      return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? Pe(this, "onreadystatechange", function(i) {
        return function(...c) {
          return a(), i.apply(this, c);
        };
      }) : this.addEventListener("readystatechange", a), Pe(this, "setRequestHeader", function(i) {
        return function(...c) {
          const [u, p] = c, d = this[jn];
          return d && Rt(u) && Rt(p) && (d.request_headers[u.toLowerCase()] = p), i.apply(this, c);
        };
      }), e.apply(this, n);
    };
  }), Pe(t, "send", function(e) {
    return function(...n) {
      const r = this[jn];
      if (!r)
        return e.apply(this, n);
      n[0] !== void 0 && (r.body = n[0]);
      const s = {
        startTimestamp: He() * 1e3,
        xhr: this
      };
      return nt("xhr", s), e.apply(this, n);
    };
  });
}
function x1(t) {
  if (Rt(t))
    return t;
  try {
    return t.toString();
  } catch {
  }
}
function B1() {
  if (op() && Xe) {
    const e = q1();
    return () => {
      e();
    };
  }
  return () => {
  };
}
const tv = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press"
};
function q1() {
  return o1(({ metric: t }) => {
    const e = te();
    if (!e || t.value == null)
      return;
    const n = t.entries.find((y) => y.duration === t.value && tv[y.name]);
    if (!n)
      return;
    const r = tv[n.name], s = e.getOptions(), o = fe(Xe + n.startTime), a = fe(t.value), i = ae(), c = et(), u = c ? We(c) : void 0, p = u ? ee(u).description : void 0, d = i.getUser(), l = e.getIntegrationByName("Replay"), h = l && l.getReplayId(), v = d !== void 0 ? d.email || d.id || d.ip_address : void 0, g = wT([i, "access", (y) => y.getScopeData, "call", (y) => y(), "access", (y) => y.contexts, "optionalAccess", (y) => y.profile, "optionalAccess", (y) => y.profile_id]), f = Wn(n.target), m = je({
      release: s.release,
      environment: s.environment,
      transaction: p,
      [kg]: t.value,
      user: v || void 0,
      profile_id: g || void 0,
      replay_id: h || void 0
    }), S = Mn({
      name: f,
      op: `ui.interaction.${r}`,
      attributes: m,
      startTime: o,
      experimental: {
        standalone: !0
      }
    });
    S.addEvent("inp", {
      [Yu]: "millisecond",
      [Zu]: t.value
    }), S.end(o + a);
  });
}
function F1(t, e = z1("fetch")) {
  let n = 0, r = 0;
  function s(o) {
    const a = o.body.length;
    n += a, r++;
    const i = {
      body: o.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: t.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions
    };
    if (!e)
      return ev("fetch"), vo("No fetch implementation available");
    try {
      return e(t.url, i).then((c) => (n -= a, r--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }));
    } catch (c) {
      return ev("fetch"), n -= a, r--, vo(c);
    }
  }
  return Vw(t, s);
}
const $1 = 30, U1 = 50;
function lm(t, e, n, r) {
  const s = {
    filename: t,
    function: e === "<anonymous>" ? ir : e,
    in_app: !0
    // All browser frames are considered in_app
  };
  return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s;
}
const H1 = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, W1 = /\((\S*)(?::(\d+))(?::(\d+))\)/, V1 = (t) => {
  const e = H1.exec(t);
  if (e) {
    if (e[2] && e[2].indexOf("eval") === 0) {
      const o = W1.exec(e[2]);
      o && (e[2] = o[1], e[3] = o[2], e[4] = o[3]);
    }
    const [r, s] = hm(e[1] || ir, e[2]);
    return lm(s, r, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0);
  }
}, K1 = [$1, V1], J1 = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, G1 = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, Q1 = (t) => {
  const e = J1.exec(t);
  if (e) {
    if (e[3] && e[3].indexOf(" > eval") > -1) {
      const o = G1.exec(e[3]);
      o && (e[1] = e[1] || "eval", e[3] = o[1], e[4] = o[2], e[5] = "");
    }
    let r = e[3], s = e[1] || ir;
    return [s, r] = hm(s, r), lm(r, s, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0);
  }
}, Y1 = [U1, Q1], Z1 = [K1, Y1], X1 = Sg(...Z1), hm = (t, e) => {
  const n = t.indexOf("safari-extension") !== -1, r = t.indexOf("safari-web-extension") !== -1;
  return n || r ? [
    t.indexOf("@") !== -1 ? t.split("@")[0] : ir,
    n ? `safari-extension:${e}` : `safari-web-extension:${e}`
  ] : [t, e];
}, Qs = 1024, eb = "Breadcrumbs", tb = (t = {}) => {
  const e = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...t
  };
  return {
    name: eb,
    setup(n) {
      e.console && $E(sb(n)), e.dom && M1(ib(n, e.dom)), e.xhr && dm(ob(n)), e.fetch && _g(ab(n)), e.history && ap(cb(n)), e.sentry && n.on("beforeSendEvent", rb(n));
    }
  };
}, nb = tb;
function rb(t) {
  return function(n) {
    te() === t && Rn(
      {
        category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
        event_id: n.event_id,
        level: n.level,
        message: pn(n)
      },
      {
        event: n
      }
    );
  };
}
function ib(t, e) {
  return function(r) {
    if (te() !== t)
      return;
    let s, o, a = typeof e == "object" ? e.serializeAttribute : void 0, i = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
    i && i > Qs && ($e && I.warn(
      `\`dom.maxStringLength\` cannot exceed ${Qs}, but a value of ${i} was configured. Sentry will use ${Qs} instead.`
    ), i = Qs), typeof a == "string" && (a = [a]);
    try {
      const u = r.event, p = ub(u) ? u.target : u;
      s = Wn(p, { keyAttrs: a, maxStringLength: i }), o = hg(p);
    } catch {
      s = "<unknown>";
    }
    if (s.length === 0)
      return;
    const c = {
      category: `ui.${r.name}`,
      message: s
    };
    o && (c.data = { "ui.component_name": o }), Rn(c, {
      event: r.event,
      name: r.name,
      global: r.global
    });
  };
}
function sb(t) {
  return function(n) {
    if (te() !== t)
      return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: iT(n.level),
      message: lh(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1)
        r.message = `Assertion failed: ${lh(n.args.slice(1), " ") || "console.assert"}`, r.data.arguments = n.args.slice(1);
      else
        return;
    Rn(r, {
      input: n.args,
      level: n.level
    });
  };
}
function ob(t) {
  return function(n) {
    if (te() !== t)
      return;
    const { startTimestamp: r, endTimestamp: s } = n, o = n.xhr[jn];
    if (!r || !s || !o)
      return;
    const { method: a, url: i, status_code: c, body: u } = o, p = {
      method: a,
      url: i,
      status_code: c
    }, d = {
      xhr: n.xhr,
      input: u,
      startTimestamp: r,
      endTimestamp: s
    };
    Rn(
      {
        category: "xhr",
        data: p,
        type: "http"
      },
      d
    );
  };
}
function ab(t) {
  return function(n) {
    if (te() !== t)
      return;
    const { startTimestamp: r, endTimestamp: s } = n;
    if (s && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.error) {
        const o = n.fetchData, a = {
          data: n.error,
          input: n.args,
          startTimestamp: r,
          endTimestamp: s
        };
        Rn(
          {
            category: "fetch",
            data: o,
            level: "error",
            type: "http"
          },
          a
        );
      } else {
        const o = n.response, a = {
          ...n.fetchData,
          status_code: o && o.status
        }, i = {
          input: n.args,
          response: o,
          startTimestamp: r,
          endTimestamp: s
        };
        Rn(
          {
            category: "fetch",
            data: a,
            type: "http"
          },
          i
        );
      }
  };
}
function cb(t) {
  return function(n) {
    if (te() !== t)
      return;
    let r = n.from, s = n.to;
    const o = hn(B.location.href);
    let a = r ? hn(r) : void 0;
    const i = hn(s);
    (!a || !a.path) && (a = o), o.protocol === i.protocol && o.host === i.host && (s = i.relative), o.protocol === a.protocol && o.host === a.host && (r = a.relative), Rn({
      category: "navigation",
      data: {
        from: r,
        to: s
      }
    });
  };
}
function ub(t) {
  return !!t && !!t.target;
}
const pb = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], db = "BrowserApiErrors", lb = (t = {}) => {
  const e = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    ...t
  };
  return {
    name: db,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      e.setTimeout && Pe(B, "setTimeout", nv), e.setInterval && Pe(B, "setInterval", nv), e.requestAnimationFrame && Pe(B, "requestAnimationFrame", vb), e.XMLHttpRequest && "XMLHttpRequest" in B && Pe(XMLHttpRequest.prototype, "send", fb);
      const n = e.eventTarget;
      n && (Array.isArray(n) ? n : pb).forEach(gb);
    }
  };
}, hb = lb;
function nv(t) {
  return function(...e) {
    const n = e[0];
    return e[0] = Jn(n, {
      mechanism: {
        data: { function: Et(t) },
        handled: !1,
        type: "instrument"
      }
    }), t.apply(this, e);
  };
}
function vb(t) {
  return function(e) {
    return t.apply(this, [
      Jn(e, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: Et(t)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function fb(t) {
  return function(...e) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((s) => {
      s in n && typeof n[s] == "function" && Pe(n, s, function(o) {
        const a = {
          mechanism: {
            data: {
              function: s,
              handler: Et(o)
            },
            handled: !1,
            type: "instrument"
          }
        }, i = Ku(o);
        return i && (a.mechanism.data.handler = Et(i)), Jn(o, a);
      });
    }), t.apply(this, e);
  };
}
function gb(t) {
  const e = B, n = e[t] && e[t].prototype;
  !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (Pe(n, "addEventListener", function(r) {
    return function(s, o, a) {
      try {
        typeof o.handleEvent == "function" && (o.handleEvent = Jn(o.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: Et(o),
              target: t
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return r.apply(this, [
        s,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Jn(o, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: Et(o),
              target: t
            },
            handled: !1,
            type: "instrument"
          }
        }),
        a
      ]);
    };
  }), Pe(
    n,
    "removeEventListener",
    function(r) {
      return function(s, o, a) {
        const i = o;
        try {
          const c = i && i.__sentry_wrapped__;
          c && r.call(this, s, c, a);
        } catch {
        }
        return r.call(this, s, i, a);
      };
    }
  ));
}
const mb = "GlobalHandlers", Sb = (t = {}) => {
  const e = {
    onerror: !0,
    onunhandledrejection: !0,
    ...t
  };
  return {
    name: mb,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(n) {
      e.onerror && (Cb(n), rv("onerror")), e.onunhandledrejection && (_b(n), rv("onunhandledrejection"));
    }
  };
}, yb = Sb;
function Cb(t) {
  Rg((e) => {
    const { stackParser: n, attachStacktrace: r } = vm();
    if (te() !== t || tm())
      return;
    const { msg: s, url: o, line: a, column: i, error: c } = e, u = Eb(
      rp(n, c || s, void 0, r, !1),
      o,
      a,
      i
    );
    u.level = "error", Kg(u, {
      originalException: c,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    });
  });
}
function _b(t) {
  Pg((e) => {
    const { stackParser: n, attachStacktrace: r } = vm();
    if (te() !== t || tm())
      return;
    const s = Rb(e), o = Wu(s) ? Pb(s) : rp(n, s, void 0, r, !0);
    o.level = "error", Kg(o, {
      originalException: s,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    });
  });
}
function Rb(t) {
  if (Wu(t))
    return t;
  try {
    if ("reason" in t)
      return t.reason;
    if ("detail" in t && "reason" in t.detail)
      return t.detail.reason;
  } catch {
  }
  return t;
}
function Pb(t) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(t)}`
        }
      ]
    }
  };
}
function Eb(t, e, n, r) {
  const s = t.exception = t.exception || {}, o = s.values = s.values || [], a = o[0] = o[0] || {}, i = a.stacktrace = a.stacktrace || {}, c = i.frames = i.frames || [], u = isNaN(parseInt(r, 10)) ? void 0 : r, p = isNaN(parseInt(n, 10)) ? void 0 : n, d = Rt(e) && e.length > 0 ? e : bE();
  return c.length === 0 && c.push({
    colno: u,
    filename: d,
    function: ir,
    in_app: !0,
    lineno: p
  }), t;
}
function rv(t) {
  $e && I.log(`Global Handler attached: ${t}`);
}
function vm() {
  const t = te();
  return t && t.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  };
}
const Tb = () => ({
  name: "HttpContext",
  preprocessEvent(t) {
    if (!B.navigator && !B.location && !B.document)
      return;
    const e = t.request && t.request.url || B.location && B.location.href, { referrer: n } = B.document || {}, { userAgent: r } = B.navigator || {}, s = {
      ...t.request && t.request.headers,
      ...n && { Referer: n },
      ...r && { "User-Agent": r }
    }, o = { ...t.request, ...e && { url: e }, headers: s };
    t.request = o;
  }
}), wb = "cause", Ib = 5, bb = "LinkedErrors", Ab = (t = {}) => {
  const e = t.limit || Ib, n = t.key || wb;
  return {
    name: bb,
    preprocessEvent(r, s, o) {
      const a = o.getOptions();
      EE(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        tp,
        a.stackParser,
        a.maxValueLength,
        n,
        e,
        r,
        s
      );
    }
  };
}, Mb = Ab;
function Ob(t) {
  return [
    tI(),
    Yw(),
    hb(),
    nb(),
    yb(),
    Mb(),
    hI(),
    Tb()
  ];
}
function kb(t = {}) {
  return { ...{
    defaultIntegrations: Ob(),
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : B.SENTRY_RELEASE && B.SENTRY_RELEASE.id ? B.SENTRY_RELEASE.id : void 0,
    autoSessionTracking: !0,
    sendClientReports: !0
  }, ...t };
}
function Db() {
  const t = B, e = t && t.chrome && t.chrome.runtime && t.chrome.runtime.id, n = B;
  return !!(n && n.browser && n.browser.runtime && n.browser.runtime.id) || !!e;
}
function Nb(t = {}) {
  const e = kb(t);
  if (Db()) {
    Ps(() => {
      console.error(
        "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
      );
    });
    return;
  }
  $e && (yg() || I.warn(
    "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
  ));
  const n = {
    ...e,
    stackParser: qE(e.stackParser || X1),
    integrations: zw(e),
    transport: e.transport || F1
  };
  $w(NI, n), e.autoSessionTracking && Lb();
}
function Lb() {
  if (typeof B.document > "u") {
    $e && I.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  jh({ ignoreDuration: !0 }), xh(), ap(({ from: t, to: e }) => {
    t !== void 0 && t !== e && (jh({ ignoreDuration: !0 }), xh());
  });
}
const uu = {
  traceFetch: !0,
  traceXHR: !0,
  enableHTTPTimings: !0
};
function zb(t) {
  const { traceFetch: e, traceXHR: n, shouldCreateSpanForRequest: r, enableHTTPTimings: s, tracePropagationTargets: o } = {
    traceFetch: uu.traceFetch,
    traceXHR: uu.traceXHR,
    ...t
  }, a = typeof r == "function" ? r : (u) => !0, i = (u) => qb(u, o), c = {};
  e && _g((u) => {
    const p = mI(u, a, i, c);
    if (p) {
      const d = fm(u.fetchData.url), l = d ? hn(d).host : void 0;
      p.setAttributes({
        "http.url": d,
        "server.address": l
      });
    }
    s && p && iv(p);
  }), n && dm((u) => {
    const p = Fb(u, a, i, c);
    s && p && iv(p);
  });
}
function jb(t) {
  return t.entryType === "resource" && "initiatorType" in t && typeof t.nextHopProtocol == "string" && (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest");
}
function iv(t) {
  const { url: e } = ee(t).data || {};
  if (!e || typeof e != "string")
    return;
  const n = sp("resource", ({ entries: r }) => {
    r.forEach((s) => {
      jb(s) && s.name.endsWith(e) && (Bb(s).forEach((a) => t.setAttribute(...a)), setTimeout(n));
    });
  });
}
function xb(t) {
  let e = "unknown", n = "unknown", r = "";
  for (const s of t) {
    if (s === "/") {
      [e, n] = t.split("/");
      break;
    }
    if (!isNaN(Number(s))) {
      e = r === "h" ? "http" : r, n = t.split(r)[1];
      break;
    }
    r += s;
  }
  return r === t && (e = r), { name: e, version: n };
}
function at(t = 0) {
  return ((Xe || performance.timeOrigin) + t) / 1e3;
}
function Bb(t) {
  const { name: e, version: n } = xb(t.nextHopProtocol), r = [];
  return r.push(["network.protocol.version", n], ["network.protocol.name", e]), Xe ? [
    ...r,
    ["http.request.redirect_start", at(t.redirectStart)],
    ["http.request.fetch_start", at(t.fetchStart)],
    ["http.request.domain_lookup_start", at(t.domainLookupStart)],
    ["http.request.domain_lookup_end", at(t.domainLookupEnd)],
    ["http.request.connect_start", at(t.connectStart)],
    ["http.request.secure_connection_start", at(t.secureConnectionStart)],
    ["http.request.connection_end", at(t.connectEnd)],
    ["http.request.request_start", at(t.requestStart)],
    ["http.request.response_start", at(t.responseStart)],
    ["http.request.response_end", at(t.responseEnd)]
  ] : r;
}
function qb(t, e) {
  const n = B.location && B.location.href;
  if (n) {
    let r, s;
    try {
      r = new URL(t, n), s = new URL(n).origin;
    } catch {
      return !1;
    }
    const o = r.origin === s;
    return e ? ln(r.toString(), e) || o && ln(r.pathname, e) : o;
  } else {
    const r = !!t.match(/^\/(?!\/)/);
    return e ? ln(t, e) : r;
  }
}
function Fb(t, e, n, r) {
  const s = t.xhr, o = s && s[jn];
  if (!s || s.__sentry_own_request__ || !o)
    return;
  const a = Ft() && e(o.url);
  if (t.endTimestamp && a) {
    const l = s.__sentry_xhr_span_id__;
    if (!l)
      return;
    const h = r[l];
    h && o.status_code !== void 0 && (Ng(h, o.status_code), h.end(), delete r[l]);
    return;
  }
  const i = fm(o.url), c = i ? hn(i).host : void 0, u = !!et(), p = a && u ? Mn({
    name: `${o.method} ${o.url}`,
    attributes: {
      type: "xhr",
      "http.method": o.method,
      "http.url": i,
      url: o.url,
      "server.address": c,
      [xe]: "auto.http.browser",
      [cs]: "http.client"
    }
  }) : new or();
  s.__sentry_xhr_span_id__ = p.spanContext().spanId, r[s.__sentry_xhr_span_id__] = p;
  const d = te();
  return s.setRequestHeader && n(o.url) && d && $b(
    s,
    d,
    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
    // we do not want to use the span as base for the trace headers,
    // which means that the headers will be generated from the scope and the sampling decision is deferred
    Ft() && u ? p : void 0
  ), p;
}
function $b(t, e, n) {
  const r = ae(), s = wt(), { traceId: o, spanId: a, sampled: i, dsc: c } = {
    ...s.getPropagationContext(),
    ...r.getPropagationContext()
  }, u = n && Ft() ? jg(n) : Ju(o, a, i), p = bg(
    c || (n ? An(n) : qa(o, e))
  );
  Ub(t, u, p);
}
function Ub(t, e, n) {
  try {
    t.setRequestHeader("sentry-trace", e), n && t.setRequestHeader(Qc, n);
  } catch {
  }
}
function fm(t) {
  try {
    return new URL(t, B.location.origin).href;
  } catch {
    return;
  }
}
function Hb() {
  B && B.document ? B.document.addEventListener("visibilitychange", () => {
    const t = et();
    if (!t)
      return;
    const e = We(t);
    if (B.document.hidden && e) {
      const n = "cancelled", { op: r, status: s } = ee(e);
      $e && I.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`), s || e.setStatus({ code: ge, message: n }), e.setAttribute("sentry.cancellation_reason", "document.hidden"), e.end();
    }
  }) : $e && I.warn("[Tracing] Could not set up background tab detection due to lack of global document");
}
const Wb = "BrowserTracing", Vb = {
  ...io,
  instrumentNavigation: !0,
  instrumentPageLoad: !0,
  markBackgroundSpan: !0,
  enableLongTask: !0,
  enableInp: !0,
  _experiments: {},
  ...uu
}, Kb = (t = {}) => {
  VT();
  const {
    enableInp: e,
    enableLongTask: n,
    _experiments: { enableInteractions: r },
    beforeStartSpan: s,
    idleTimeout: o,
    finalTimeout: a,
    childSpanTimeout: i,
    markBackgroundSpan: c,
    traceFetch: u,
    traceXHR: p,
    shouldCreateSpanForRequest: d,
    enableHTTPTimings: l,
    instrumentPageLoad: h,
    instrumentNavigation: v
  } = {
    ...Vb,
    ...t
  }, g = v1();
  e && B1(), n && f1(), r && g1();
  const f = {
    name: void 0,
    source: void 0
  };
  function m(S, y) {
    const E = y.op === "pageload", _ = s ? s(y) : y, C = _.attributes || {};
    y.name !== _.name && (C[Nt] = "custom", _.attributes = C), f.name = _.name, f.source = C[Nt];
    const R = Vg(_, {
      idleTimeout: o,
      finalTimeout: a,
      childSpanTimeout: i,
      // should wait for finish signal if it's a pageload transaction
      disableAutoFinish: E,
      beforeSpanEnd: (A) => {
        g(), _1(A);
      }
    });
    function T() {
      ["interactive", "complete"].includes(B.document.readyState) && S.emit("idleSpanEnableAutoFinish", R);
    }
    return E && B.document && (B.document.addEventListener("readystatechange", () => {
      T();
    }), T()), R;
  }
  return {
    name: Wb,
    afterAllSetup(S) {
      let y, E = B.location && B.location.href;
      S.on("startNavigationSpan", (_) => {
        te() === S && (y && ($e && I.log(`[Tracing] Finishing current root span with op: ${ee(y).op}`), y.end()), y = m(S, {
          op: "navigation",
          ..._
        }));
      }), S.on("startPageLoadSpan", (_, C = {}) => {
        if (te() !== S)
          return;
        y && ($e && I.log(`[Tracing] Finishing current root span with op: ${ee(y).op}`), y.end());
        const R = C.sentryTrace || sv("sentry-trace"), T = C.baggage || sv("baggage"), A = lT(R, T);
        ae().setPropagationContext(A), y = m(S, {
          op: "pageload",
          ..._
        });
      }), S.on("spanEnd", (_) => {
        const C = ee(_).op;
        if (_ !== We(_) || C !== "navigation" && C !== "pageload")
          return;
        const R = ae(), T = R.getPropagationContext();
        R.setPropagationContext({
          ...T,
          sampled: T.sampled !== void 0 ? T.sampled : bn(_),
          dsc: T.dsc || An(_)
        });
      }), B.location && (h && Jb(S, {
        name: B.location.pathname,
        // pageload should always start at timeOrigin (and needs to be in s, not ms)
        startTime: Xe ? Xe / 1e3 : void 0,
        attributes: {
          [Nt]: "url",
          [xe]: "auto.pageload.browser"
        }
      }), v && ap(({ to: _, from: C }) => {
        if (C === void 0 && E && E.indexOf(_) !== -1) {
          E = void 0;
          return;
        }
        C !== _ && (E = void 0, Gb(S, {
          name: B.location.pathname,
          attributes: {
            [Nt]: "url",
            [xe]: "auto.navigation.browser"
          }
        }));
      })), c && Hb(), r && Qb(o, a, i, f), zb({
        traceFetch: u,
        traceXHR: p,
        tracePropagationTargets: S.getOptions().tracePropagationTargets,
        shouldCreateSpanForRequest: d,
        enableHTTPTimings: l
      });
    }
  };
};
function Jb(t, e, n) {
  t.emit("startPageLoadSpan", e, n), ae().setTransactionName(e.name);
  const r = et();
  return (r && ee(r).op) === "pageload" ? r : void 0;
}
function Gb(t, e) {
  ae().setPropagationContext(ov()), wt().setPropagationContext(ov()), t.emit("startNavigationSpan", e), ae().setTransactionName(e.name);
  const n = et();
  return (n && ee(n).op) === "navigation" ? n : void 0;
}
function sv(t) {
  const e = AE(`meta[name=${t}]`);
  return e ? e.getAttribute("content") : void 0;
}
function Qb(t, e, n, r) {
  let s;
  const o = () => {
    const a = "ui.action.click", i = et(), c = i && We(i);
    if (c) {
      const u = ee(c).op;
      if (["navigation", "pageload"].includes(u)) {
        $e && I.warn(`[Tracing] Did not create ${a} span because a pageload or navigation span is in progress.`);
        return;
      }
    }
    if (s && (s.setAttribute(Xc, "interactionInterrupted"), s.end(), s = void 0), !r.name) {
      $e && I.warn(`[Tracing] Did not create ${a} transaction because _latestRouteName is missing.`);
      return;
    }
    s = Vg(
      {
        name: r.name,
        op: a,
        attributes: {
          [Nt]: r.source || "url"
        }
      },
      {
        idleTimeout: t,
        finalTimeout: e,
        childSpanTimeout: n
      }
    );
  };
  B.document && addEventListener("click", o, { once: !1, capture: !0 });
}
function ov() {
  return {
    traceId: ie(),
    spanId: ie().substring(16)
  };
}
function Yb(t, e) {
  if (e)
    return Nb({
      dsn: wS,
      integrations: [Kb()],
      tracesSampleRate: 1e-3,
      enabled: !0,
      environment: IS,
      initialScope: {
        tags: {
          agentId: t
        }
      }
    }), {
      populateWithAgent: (n) => {
        var r;
        Mg().setTags({
          owner: n.owner_id,
          plan: (r = n.metadata) == null ? void 0 : r.plan
        });
      },
      onErrorSendAlert: (n, r) => {
        Qu((s) => {
          s.setExtra("error data", r), Aw(n);
        });
      }
    };
}
function av(t) {
  window.DID_AGENTS_API = {}, window.dataLayer = window.dataLayer || [];
  const {
    isOwner: e,
    enabled: n,
    onError: r,
    onClose: s,
    styles: o,
    didSocketApiUrl: a,
    didApiUrl: i,
    customMixpanelKey: c,
    offline: u,
    monitor: p = !0,
    ...d
  } = t;
  if (!t.targetElement && d.mode === "full")
    throw new Error("No target element provided for full mode");
  if (d.agentId) {
    if (!d.auth)
      throw new Error("No auth provider");
  } else
    throw new Error("No agent provider ");
  const l = typeof t.targetElement == "string" ? document.getElementById(t.targetElement) : t.targetElement, h = document.createElement("div");
  h.className = "didagent_target", document.body.appendChild(h);
  const {
    populateWithAgent: v,
    onErrorSendAlert: g
  } = Yb(d.agentId, p) ?? {}, f = (S, y) => {
    g == null || g(S.message, y), r == null || r(S, y);
  }, m = setInterval(() => {
    l && !document.body.contains(l) && (uo(null, h), h.remove(), clearInterval(m));
  }, 2e3);
  uo(w(xS, {
    initialConfigurations: {
      ...d,
      targetElement: l
    },
    children: w(SE, {
      isOwner: e,
      onClose: s,
      onAgentReady: v,
      styles: o,
      offline: u,
      didApiUrl: i,
      didSocketApiUrl: a,
      customMixpanelKey: c,
      enabled: n,
      onError: f
    })
  }), h);
}
function cv(t) {
  const {
    token: e,
    username: n,
    password: r,
    clientKey: s
  } = t;
  if (!s) {
    if (!e) {
      if (!n || !r)
        throw new Error("Failed to load agent. No auth method provided");
      return {
        type: "basic",
        username: n,
        password: r
      };
    }
    return {
      type: "bearer",
      token: e
    };
  }
  return {
    type: "key",
    clientKey: s
  };
}
const qe = document.querySelector('script[data-name="did-agent"]');
if (qe) {
  const t = new URLSearchParams(""), e = t.get("agent_id"), n = t.get("key"), r = qe.getAttribute("data-mode") ?? "fabio", s = qe.getAttribute("data-target-id"), o = e || qe.getAttribute("data-agent-id"), a = qe.getAttribute("data-api-url"), i = qe.getAttribute("data-token"), c = qe.getAttribute("data-username"), u = qe.getAttribute("data-password"), p = n || qe.getAttribute("data-client-key"), d = qe.getAttribute("data-chat-mode") ?? M.Functional, l = qe.getAttribute("data-track") !== "false", h = qe.getAttribute("data-monitor") !== "false", v = qe.getAttribute("data-position") ?? "right", g = qe.getAttribute("data-orientation") ?? "vertical";
  if (o) {
    if (!Object.values(M).includes(d))
      throw new Error(`Invalid chat mode, must be one of: ${Object.values(M).join(", ")}`);
  } else
    throw new Error("No agent id");
  window.DID_AGENTS_API = {};
  const f = {
    didApiUrl: a,
    monitor: h
  }, m = {
    mode: r,
    targetElement: s,
    auth: cv({
      token: i,
      username: c,
      password: u,
      clientKey: p
    }),
    agentId: o,
    track: l,
    chatMode: d,
    position: v,
    orientation: g
  };
  av({
    ...m,
    ...f
  });
} else
  window.DID_AGENT_INIT = ({
    token: t,
    username: e,
    password: n,
    clientKey: r,
    ...s
  }) => {
    av({
      ...s,
      auth: cv({
        token: t,
        username: e,
        password: n,
        clientKey: r
      })
    });
  };
